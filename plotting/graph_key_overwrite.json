{
  "15": {
    "pattern-meta-model": "{\n  \"name\": \"n/a\",\n  \"description\": \"Based on a meta model for source code and design patterns defined in \\n\\nMario Luca Bernardi, Marta Cimitile, and Giuseppe Di Lucca. 2014. Design\\npattern detection using a DSL-driven graph matching approach. Journal of\\nSoftware: Evolution and Process 26, 12 (2014), 1233\\u00e2\\u20ac\\u201c1266. https://doi.org/\\n10.1002/smr.1674\\n\\nThis describes graphs for design patterns\",\n  \"artefacts\": [\n    {\n      \"name\": \"Design Pattern Specifications\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Nodes from meta-model.\\n\\nGraphs are centered around pivotal nodes (classes, interfaces, methods);\\nother types of nodes are thus ignored.\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Edges from meta-model\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a (unclear how node embeddings are initialised)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "code-meta-model": "{\n  \"name\": \"n/a\",\n  \"description\": \"Based on a meta model for source code and design patterns defined in \\n\\nMario Luca Bernardi, Marta Cimitile, and Giuseppe Di Lucca. 2014. Design\\npattern detection using a DSL-driven graph matching approach. Journal of\\nSoftware: Evolution and Process 26, 12 (2014), 1233\\u00e2\\u20ac\\u201c1266. https://doi.org/\\n10.1002/smr.1674\\n\\nThis describes graphs for source code.\\n\\nFor source code specifically, k-hop neighbourhoods are extracted from the\\nsystem (metamodel) graph.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Nodes from meta-model\\n\\nGraphs are centered around pivotal nodes (classes, interfaces, methods);\\nother types of nodes are thus ignored.\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Edges from meta-model\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a (unclear how node embeddings are initialised)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}"
  },
  "160": {
    "ast": "[\n  {\n    \"name\": \"AST\",\n    \"description\": \"n/a\",\n    \"artefacts\": [\n      {\n        \"name\": \"Source code\",\n        \"details\": \"n/a\"\n      }\n    ],\n    \"vertex-type\": [\n      {\n        \"name\": \"AST Node\",\n        \"details\": \"n/a\"\n      }\n    ],\n    \"edge-type\": [\n      {\n        \"name\": \"AST Edge\",\n        \"details\": \"n/a\"\n      }\n    ],\n    \"vertex-features\": \"First of all, for each node, its type, content, and position (line nr, column),\\nare combined into a string and embedded using a document embedding (flair)\\n\\nPaths from the root to leaf nodes are extracted, and embedded in the same way.\\n\\nPath embeddings are added to node embeddings to augment them.\",\n    \"edge-features\": \"n/a\",\n    \"connectivity-features\": \"Adjacency Matrix\",\n    \"graph-features\": \"n/a\",\n    \"other-features\": \"n/a\"\n  }\n]"
  },
  "sb-002": {
    "graph": "{\n  \"name\": \"n/a\",\n  \"description\": \"ast with additional edges. The AST is the thing being generated by the model.\",\n  \"artefacts\": null,\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/sibling/parent/next-use/next token\",\n  \"vertex-features\": null,\n  \"edge-features\": null,\n  \"connectivity-features\": null,\n  \"graph-features\": null,\n  \"other-features\": \"Context code (which contains the hole to be filled in) is used as feature.\"\n}"
  },
  "sb-065": {
    "ast": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"node type\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"byte code sequence \\n\\nsequence of identifiers and constants from the code\\n\\npre-order sequence of ast node types\"\n}",
    "cfg": "{\n  \"name\": \"cfg\",\n  \"description\": \"n/a\",\n  \"vertex-type\": \"statement\",\n  \"edge-type\": \"control flow\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"High-Order Proximity preserved Embedding (HOPE) for node embedding; then take average\",\n  \"other-features\": \"n/a\"\n}"
  },
  "sb-126": {
    "graph": "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/sibling\",\n  \"vertex-features\": \"type (nonterminal), code tokens (terminal)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"presumably adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"source code text is used as feature\"\n}"
  }
}