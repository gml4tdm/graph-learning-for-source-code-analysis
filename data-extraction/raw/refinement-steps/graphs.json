{
  "raw": [
    "{\n  \"name\": \"n/a\",\n  \"description\": \"AST with added control and data flow edges\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code (methods)\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"Edges between different uses of the same variable.\\n\\nType 1: Starting from the declaration, each usage of the \\nvariable points to the next usage.\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"Edges between Statement node. \\nEvery statement node points to all statements node which can \\nimmediately follow it in execution. \\nExample: fallible operations pointing to the next statement,\\nbut also the encapsulating catch block.\"\n    }\n  ],\n  \"vertex-features\": \"Node type is one-hot encoded.\\n\\nThe source code snippets corresponding to every node \\n(including comments) is represented as a sequence of \\ntokens, where every token is encoded using CodeBERT.\\n\\nThe average vector of all encoded tokens is computed,\\nand concatenated to the one-hot encoded node type.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"AST with added control and data flow edges\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code (methods)\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"Edges between different uses of the same variable.\\n\\nType 2: The declaration of a variable points to every usage of that variable.\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"Edges between Statement node. \\nEvery statement node points to all statements node which can \\nimmediately follow it in execution. \\nExample: fallible operations pointing to the next statement,\\nbut also the encapsulating catch block.\"\n    }\n  ],\n  \"vertex-features\": \"Node type is one-hot encoded.\\n\\nThe source code snippets corresponding to every node \\n(including comments) is represented as a sequence of \\ntokens, where every token is encoded using CodeBERT.\\n\\nThe average vector of all encoded tokens is computed,\\nand concatenated to the one-hot encoded node type.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"AST with added control and data flow edges\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code (methods)\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"Edges between different uses of the same variable.\\n\\nType 3: The declaration of a variable points to every usage of that variable.\\nAdditionally, starting from the declaration, each usage of the \\nvariable points to the next usage. (combined type 1 and type 2)\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"Edges between Statement node. \\nEvery statement node points to all statements node which can \\nimmediately follow it in execution. \\nExample: fallible operations pointing to the next statement,\\nbut also the encapsulating catch block.\"\n    }\n  ],\n  \"vertex-features\": \"Node type is one-hot encoded.\\n\\nThe source code snippets corresponding to every node \\n(including comments) is represented as a sequence of \\ntokens, where every token is encoded using CodeBERT.\\n\\nThe average vector of all encoded tokens is computed,\\nand concatenated to the one-hot encoded node type.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"In this setting, the source code is obtained from decompiled byte code.\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Generic and specific node type \\n(e.g. a variable of specific type \\\"Variable\\\" has generic type \\\"Expression\\\")\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"Mixture of AST and CFG.\\n\\nCode slicing is performed based on function calls,\\narithmetic expressions, pointer usage, and array usage.\\nSlicing was done based on control and data dependencies. \\n\\nEvery function may result into multiple code slices!\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Source code slice from function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Token\",\n      \"details\": \"Each unique token has a vertex\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Co-occurrence edge\",\n      \"details\": \"Edge between tokens if they co-occur in a sliding window of some given size\"\n    }\n  ],\n  \"vertex-features\": \"Tokens encoded using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"undirected\"\n    }\n  ],\n  \"vertex-features\": \"Tokens encoded using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"Combination of AST and CFG\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"User defined names are normalised \\nNode type one-hot encoded \\ncontent of node is the average of the word2vec embeddings of all tokens in the content\\nthe two embeddings are concatenated\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Slice Property Graph\",\n  \"description\": \"Similar to code property graph, but with program slicing.\\n\\nFirst, AST is used to detect SyVC's. \\nThese are used as a basis for slicing in the PDG.\\nNext, a graph with data, control, and function call dependence edges is created.\\n\\nNote: one function may have multiple slices.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Also function focussed, but not exclusively\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Dependence Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependence Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Function Call Dependence Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Statements in nodes are tokenized, encoded using word2vec,\\nand enhanced with positional labels. \\n\\nNode types are one-hot encoded.\",\n  \"edge-features\": \"Edges are labelled according to type (d \\\\in D)\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"Three subgraphs are created by considering different edge types\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Variable names are normalised.\\nNode payload embedded using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"Obtained from PDG through slicing based on system API calls \\nand statements containing arithmetic operations\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Dependence Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependence Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Names are normalised\\nStatements encoded using doc2vec (DM-PV)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Code Property Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Node type is one-hot encoded \\nSource code is encoded by summing word2vec vectors of all tokens in the fragment \\nThe two encodings are concatenated\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix (?)\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"API Context Graph\",\n  \"description\": \"Describes (Java STD) API usages and their context\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code (method)\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"API method call\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"API field access\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Variable declaration\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Assignment\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Unit\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Hole\",\n      \"details\": \"Hole to be filled in with an API recommendation. Should be _1_ node in the graph.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"S\",\n      \"details\": \"There is an edge (u, v) of type S in one of two cases:\\n  1) v is the Hole node and u represents a statement directly preceding the hole.\\n  2) u is the Hole node and v represents a statement directly following the hole.\"\n    },\n    {\n      \"name\": \"CD\",\n      \"details\": \"There is a direct data flow and a direct control flow from the source to the target node\"\n    },\n    {\n      \"name\": \"C\",\n      \"details\": \"There is a control flow from the source to the target node, but no data flow\"\n    },\n    {\n      \"name\": \"D\",\n      \"details\": \"There is a data flow from the source to the target node, but no control flow\"\n    }\n  ],\n  \"vertex-features\": \"Node names are generated based upon a set or rules; \\n\\n1) Declaration -> [Full Class Name].Declaration (String str -> java.lang.String.Declaration)\\n2) Declaration w/ constant assignment -> [Full Class Name].Constant \\n3) Declaration w/ null assignment -> [Full Class Name].Null\\n4) Declaration w/ object creation -> [Full Class Name].new([parameter types])\\n5) API Method Call -> [Full Method Name]([parameter types])\\n6) API Field Access -> [Full Field Name]\\n7) Control unit -> [Name] (if -> if)\\n8) Nested API method call/field access (e.g. call inside call) -> list calls following above rules, inner to outer\\n9) cascading method calls/field access -> Keep cascading structure; only expand initial call\\n(note: cascading = chained)\",\n  \"edge-features\": \"Edge labels are not used as features\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Names as described for vertex features are tokenized by;\\n1) removing trailing numbers\\n2) splitting on underscores, numbers, dollar signs, camelCasing\\n3) duplicate and meaningless (single letter) tokens are discarded\\n4) remaining tokens are encoded using GloVe\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"Mix of AST, CFG, DFG, NCS\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"functions\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"NCS Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Node type encoded using label encoding\\nSource code encoded using word2vec\\nthe two encodings are concatenated\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"Graph structure for use in variable misuse prediction.\\nA graph structure is build for every single possible variable\\nwhich can be substituted in the spot of interest. \\nA graph structure with the node at the point of interest removed is \\nalso built.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Function (C#)\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST  Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"NCS Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"(Data Flow) Last Use\",\n      \"details\": \"Connect variable use with all previous reads and definitions with (still) the same value\"\n    },\n    {\n      \"name\": \"(Data Flow) Last Write\",\n      \"details\": \"Connect use of variable with all its definitions\"\n    },\n    {\n      \"name\": \"(Data Flow) Last Lexical Use\",\n      \"details\": \"Represent the shortcut in reversed token chain between nearest entries of the specified variable\"\n    },\n    {\n      \"name\": \"(Data Flow) Computed From\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"(Data Flow) Formal Args\",\n      \"details\": \"Connect actual arguments and formal parameters of a method\"\n    },\n    {\n      \"name\": \"(Data Flow) Next Operand\",\n      \"details\": \"Connect operands of a single operation and parameters of a method (in lexical order)\"\n    }\n  ],\n  \"vertex-features\": \"Syntax tokens have their node type encoded using word2vec Token tokens have their tokens and language type (variable/property/field) encoded using word2vec.\\nFor encoding, text (camel case, underscores) is split up, and the final vector is the average.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Child Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Next Token Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Computed From Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Last Use Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Guarded By Negation Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Guarded By Edge\",\n      \"details\": \"e.g. Edge to surrounding if statement\"\n    },\n    {\n      \"name\": \"Jump Edge\",\n      \"details\": \"e.g. from if to else\"\n    }\n  ],\n  \"vertex-features\": \"Normalise names.\\nNode type and tokens encoded using word2vec\\n(return) type of variables, functions, constants encoded using word2vec\\ntype and type/payload embeddings concatenated.\",\n  \"edge-features\": null,\n  \"connectivity-features\": \"Adjacency matrices (one for each edge type; 9 in total)\",\n  \"graph-features\": null,\n  \"other-features\": null\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"AST is linearised using depth first traversal\\nto obtain sequence of tokens.\\n\\nTokens are encoded using word2vec\\n\\nSequence used as input for following network: \\nLSTM\\nGlobal Max Pooling\\nFNN Layer w/ tanh\\nFNN Layer w/ linear \\nFNN Layer w/ sigmoid\\n\\nafter training, the last two layers are removed \\nin order to obtain function level representations.\\n\\nThe network is trained on the vulnerability \\ndetection task. After training, it is used for embedding.\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"AST Nodes are sequenced using \\ndepth first traversal.\\n\\nFed into the following network:\\nEmbedding Layer \\nLSTM\\nLSTM \\nFNN w/ ReLU \\nFNN w/ Linear\\n\\nGoal is to predict the \\\"essential complexity\\\",\\na proxy task of predicting a metric associated \\nwith vulnerabilities. \\n\\nThe outputs of the last LSTM layer are used as \\ngraph representations.\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"For each method in a commit, a PDG of both the old \\nand new version of that method is constructed.\\n\\nThe PDGs are sliced based on the nodes changed in \\nthe commit.\\n\\nAll graphs are represented as a sequence \\nL = (s, p_1, \\\\hdots, p_x, n_1, \\\\hdots, n_y, t_1, \\\\hdots, t_z)\\n\\ns is the sliced graph, p_i are control flow paths, n_i are statements,\\nand t_i are tokens.\\n\\n(Note: many of the edge types/relations boil down to: control and dependence edges)\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"Diff\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Code Change Slice Node\",\n      \"details\": \"Represents the sliced graph\"\n    },\n    {\n      \"name\": \"Path\",\n      \"details\": \"Represents a control flow path in the sliced graph,\\nfrom the \\\"root\\\" node (method entry) to an exit point (i.e. return, throw, etc)\"\n    },\n    {\n      \"name\": \"Statement\",\n      \"details\": \"Statement in the source code\"\n    },\n    {\n      \"name\": \"Token\",\n      \"details\": \"Token in the source code\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"R1 - Control Flow Path\",\n      \"details\": \"Edge between code change slide node and path node\"\n    },\n    {\n      \"name\": \"R2 - Control Flow Path (2)\",\n      \"details\": \"Edge between control flow path and nodes contained in said path\"\n    },\n    {\n      \"name\": \"R3 - Changed node relation\",\n      \"details\": \"Denote a relation (data or dependency) between two changed nodes.\"\n    },\n    {\n      \"name\": \"R4 - Data Dependency\",\n      \"details\": \"Denote data dependency between two nodes which are members of \\nN_{change} \\\\cup N_{ctrl}, \\nwhere the first set is the set of changed nodes,\\nand the second is the set of nodes with a control dependency on \\nsome node in the set of changed nodes\"\n    },\n    {\n      \"name\": \"R5 - Data Dependency\",\n      \"details\": \"Denote data dependency between two nodes from N_{data},\\nWhere N_{data} is the set of nodes with a data dependency on \\nsome node in the set of changed nodes\"\n    },\n    {\n      \"name\": \"R6 - Control Dependency\",\n      \"details\": \"Denote control dependency between two nodes which are members of \\nN_{change} \\\\cup N_{data}, \\nwhere the first set is the set of changed nodes,\\nand the second is the set of nodes with a data dependency on \\nsome node in the set of changed nodes\"\n    },\n    {\n      \"name\": \"R7 - Control Dependency\",\n      \"details\": \"Denote control dependency between two nodes from N_{ctrl},\\nWhere N_{ctrl} is the set of nodes with a control dependency on \\nsome node in the set of changed nodes\"\n    },\n    {\n      \"name\": \"R8 - Token Edge\",\n      \"details\": \"Edge between statement and the nodes of tokens it contains\"\n    }\n  ],\n  \"vertex-features\": \"Token nodes are encoded using a word embedding.\\n\\nOther node types are encoded as zeros.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Augmented Socio-Technical Graph\",\n  \"description\": \"Graph spanning and combining multiple repositories\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Repository (including pull requests)\"\n    },\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"File\"\n    },\n    {\n      \"name\": \"User Data\",\n      \"details\": \"Comments\"\n    },\n    {\n      \"name\": \"Work Items\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Pull Request\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Work Item\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Author\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Reviewer\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"File\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Repository\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Token\",\n      \"details\": \"Tokens occurring in e.g. pull requests\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"creates\",\n      \"details\": \"author creates a pull request\"\n    },\n    {\n      \"name\": \"reviews\",\n      \"details\": \"created between reviewer and pull request\"\n    },\n    {\n      \"name\": \"contains\",\n      \"details\": \"repository contains pull request\"\n    },\n    {\n      \"name\": \"changes\",\n      \"details\": \"pull request changes file\"\n    },\n    {\n      \"name\": \"linked to\",\n      \"details\": \"pull request linked to work item\"\n    },\n    {\n      \"name\": \"comments on\",\n      \"details\": \"between pull request and reviewer\"\n    },\n    {\n      \"name\": \"parent of\",\n      \"details\": \"between work item nodes\"\n    },\n    {\n      \"name\": \"Token Edge\",\n      \"details\": \"Edge between e.g. a pull request and a token,\\nor between two tokens based on pointwise mutual information.\"\n    }\n  ],\n  \"vertex-features\": \"Information is one-hot encoded (?)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"one-hot encoding of AST node type\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": null,\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"Graph representing a commit.\\nBased on the \\\"hunks\\\" (added and removed lines)\\nfrom a commit.\\n\\nBoth hunks are parsed into ASTs,\\ncalled the old and new AST.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"commit\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Code Node\",\n      \"details\": \"Either an AST node, \\nor a result of the fact that\\nSnake and camel case names are split up; the tokens are added as child nodes of the original AST node\"\n    },\n    {\n      \"name\": \"Edit Node\",\n      \"details\": \"Several different types:\\nV_ADD: For nodes not present in the old AST, but which are present in the new AST\\nV_DEL: Connect a node which is present in the old AST, but not in the new AST\\nV_MOVE: Connect two nodes present in both ASTs, but the subtree has moved in the new AST\\nV_UPDATE: Connect two nodes present in both ASTs, but the content of the node was updated in the new AST.\\nV_MATCH: Connect two nodes present in both AST, with matching location and content\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Edit Edge\",\n      \"details\": \"Each edit node is connect to two AST nodes using edit edges\"\n    },\n    {\n      \"name\": \"Token Node\",\n      \"details\": \"The leaf nodes in the AST (containing the tokens) are connected in token (NCS) order\"\n    }\n  ],\n  \"vertex-features\": null,\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow EDge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Node type (nonterminal, terminal, or value (contains actual token)) is used as feature\\nType of syntactic node is used as feature \\n\\nUnclear what exact features are used, and how they are encoded.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Control Flow Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Statements in nodes are tokenized\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Some node types are discarded, others are kept\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"Seen as undirected\"\n    }\n  ],\n  \"vertex-features\": \"Node \\\"strings\\\" mapped to numerical vectors; unclear what this means exactly\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"PDG\",\n  \"description\": \"All source files in a project are processed.\\nFurthermore, every function in a source file is \\nrepresented using its own graph.\\n\\nGiven a bug report, the model must pinpoint the file \\nwith the defect;\\n\\nTo avoid confusion, remember that the artefacts in the \\n\\\"artefacts\\\" section are not related _beforehand_, but their\\nrelatedness must be predicted\",\n  \"artefacts\": [\n    {\n      \"name\": \"Bug report\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"Every function in a source file has its own PDG\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Dependence Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Dependence Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"Graphs Represented using Graph2Vec.\\n\\nAll graph representations are aggregated into a single vector \\nthrough k-medoids with Hausdorff distance\",\n  \"other-features\": \"Summary and description of bug reports are encoded using word2vec.\\n\\nContent of source code files is encoded using word2vec,\\nafter removal of keywords and splitting up identifiers.\"\n}",
    "{\n  \"name\": \"CFG\",\n  \"description\": \"To avoid confusion, remember that the artefacts in the \\n\\\"artefacts\\\" section are not related _beforehand_, but their\\nrelatedness must be predicted\",\n  \"artefacts\": [\n    {\n      \"name\": \"Bug report\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"Every function in a source file has its own PDG\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Statements in nodes are encoded using CodeBERT.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Source code text is also used as input.\\n\\nBug report text is cleaned up (e.g. formatting removal)\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"The AST of the old and of the new function are both extracted. \\nThree subtrees are extracted\\n  1) The old (buggy) subtree\\n  2) The new (fixed) subtree\\n  3) The common context\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"patch\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"The tokens of leaf nodes are extracted as features.\\nNames are split up\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"All paths from the AST connecting two leaf nodes are extracted.\\nIf multiple paths are possible, the shorted is used.\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"File\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Only method calls (incl. class creation), declarations, and control flow nodes are kept.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Content of tokens is put into a sequence\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"File\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Only method calls (incl. class creation), declarations, and control flow nodes are kept.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Node types are put into a sequence\"\n}",
    "{\n  \"name\": \"Class Dependency Network (CDN)\",\n  \"description\": \"Serves as the \\\"larger\\\" context (``external features'') for the file.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Files/project\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Class\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Dependency\",\n      \"details\": \"Inheritance/implementation, fields (A has field of type B), method invocation (A calls method of B)\"\n    }\n  ],\n  \"vertex-features\": \"Various static code analysis metrics (e.. LOC, afferent coupling, CBO)\\nNetwork metrics generated using node2vec.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"FAST (Flow of Abstract Syntax Tree)\",\n  \"description\": \"Hybrid of control flow graph, call graph, and abstract syntax tree\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Basic Block\",\n      \"details\": \"Extracted from the AST. \\n\\nEach block represents a control flow transfer.\\nSlightly more course-grained than the control flow graph,\\nbecause e.g. assignment statements do not have dedicated nodes.\"\n    },\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Intra-procedural Edge\",\n      \"details\": \"Represents control flow between basic block.\\n\\nA Basis block points to every basic block that may follow it.\"\n    },\n    {\n      \"name\": \"Inter-procedural Edge\",\n      \"details\": \"Comes in two types: Call Edge and Return Edge.\\n\\nCall Edge: Edge from a basic block calling a function, to the \\n            first block (\\\"start block\\\") of the called function.\\n\\nReturn Edge: Edge from a basic block returning from a function, \\n        to the basic block in that called the function.\"\n    },\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Block/AST Edge\",\n      \"details\": \"Edge connecting a basic block to an AST node. \\nUnclear whether this is actually considered as a different \\ntype of edge by the authors. \\nAnyway, connects a basic block to the sub-tree of the AST \\n\\\"contained\\\" in said block.\"\n    }\n  ],\n  \"vertex-features\": \"AST nodes are embedded using Word2Vec\\n\\nSpecifically, for non-leave nodes, the type is encoded (no payload);\\nLeave nodes have no type but have a payload (token) that is encoded.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Per block, a log message is assumed to be given. \\nEvery word in the message is embedded using Word2Vec.\\nA final feature vector is obtained through averaging all these embeddings.\"\n}",
    "{\n  \"name\": \"Code-NoN (network of networks)\",\n  \"description\": \"Control Flow Graph in which each node is an AST.\\n\\nTo avoid confusion, remember that the artefacts in the \\n\\\"artefacts\\\" section are not related _beforehand_, but their\\nrelatedness must be predicted\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Bug Report\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST\",\n      \"details\": \"A full blown AST corresponding to the basic block in the original CFG,\\nconsisting of AST nodes and AST edges. \\nThe AST nodes are referred to as token nodes,\\nwhile the CFG nodes are referred to as block nodes.\\n\\nIn token nodes, compound names are split up.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"From a bug report (summary + description),\\nso-called \\\"bug clues\\\" are extracted,\\nwhich are encoded using word2vec\"\n}",
    "{\n  \"name\": \"CFG\",\n  \"description\": \"To avoid confusion, remember that the artefacts in the \\n\\\"artefacts\\\" section are not related _beforehand_, but their\\nrelatedness must be predicted\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"files\"\n    },\n    {\n      \"name\": \"Bug Report\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Punctuation in statements is removed, names are broken up,\\ntokens are encoded using word2vec, and put into a matrix.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Bug reports are preprocessed (standard NLP steps),\\nand encoded as matrix of word vectors using word2vec\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"File\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Only method calls (incl. class creation), declarations, and control flow nodes are kept.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Content of tokens is put into a sequence\"\n}",
    "{\n  \"name\": \"Class Dependency Network (CDN)\",\n  \"description\": \"Serves as the \\\"larger\\\" context for the file.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Files/project\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Class\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Dependency\",\n      \"details\": null\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"Graph encoded using node2vec\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"one-hot encoding of node type\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"The information in a node is divided into three \\\"perspectives\\\":\\nPerspective 0: node type    (e.g. \\\"MethodDeclaration\\\")  \\nPerspective 1: Node value   (e.g. Method name)\\nPerspective 2: Additional Information (e.g. Method visibility)\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Literals are generalised. \\nNames are split up based on camel case naming,\\nregardless of perspective.\\n\\nAn unsupervised training procedure is used to encode node types.\\nThe training is essentially equivalent to word2vec training \\n(with negative sampling), but the neighbourhood of tokens is \\ndetermine using certain structural patterns in the AST.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"First, node features are computed. \\nThen, all node embeddings are put into a linear sequence to obtain a matrix.\"\n}",
    "{\n  \"name\": \"Augmented Code Property Graph\",\n  \"description\": \"Code property graph, including call information\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"file\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Three main attributes; 1) node type, 2) node code, 3) node location \\n\\nNodes are pruned:\\n1) Nodes with syntactic elements which are characteristics of certain bugs are selected\\n2) All nodes making up the statements these nodes are part of are selected \\n3) all nodes making up statements with data and call relationships to these statements are selected.\\n4) For all selected nodes, a nearest neighbour set is computed \\n5) All selected nodes are kept \\n\\nThe result is multiple possible graphs per file.\\nFurthermore, each graph is associated with a certain defect type.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"Every edge has three main attributes; 1) source node, 2) destination node, 3) edge type\\nNote that the node type is actually one of 24 possible types (the four shown here is a simplification)\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"Every edge has three main attributes; 1) source node, 2) destination node, 3) edge type\\nNote that the node type is actually one of 24 possible types (the four shown here is a simplification)\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"Every edge has three main attributes; 1) source node, 2) destination node, 3) edge type\\nNote that the node type is actually one of 24 possible types (the four shown here is a simplification)\"\n    },\n    {\n      \"name\": \"Call Edge\",\n      \"details\": \"Every edge has three main attributes; 1) source node, 2) destination node, 3) edge type\\nNote that the node type is actually one of 24 possible types (the four shown here is a simplification)\"\n    }\n  ],\n  \"vertex-features\": \"The tokens in the node value are encoded using word2vec,\\nand combined using kernel PCA.\\n\\nnode type is embedded using integer,\\n\\nThe two embeddings are concatenated.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"(sparse) adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Whole program\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"For terminal nodes:\\n  Node content (name, e.g. getMaxInt) and node type are both\\n  split up based on camel casing, resulting in two matrices.\\n\\nFor internal nodes, the mode typs is used as a feature (no splitting)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Short path (t, p, n): path p from terminal node t to internal node n with >= 2 children.\\nPath pair (t_s, p_s, t_e, p_e): Two short paths with same internal node \\nSpan of a path pair: Let c_k denote the k-th child of the shared internal node of the two\\n                      short paths. Suppose p_s leads through c_i and p_e leads through c_j.\\n                      Then the span of the path pair is defined as j - i\\nLength of a pair path: |p_s| + |p_e| + 1\\nNumber of shor paths is reduced by limiting length and span.\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Method\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"For terminal nodes:\\n  Node content (name, e.g. getMaxInt) and node type are both\\n  split up based on camel casing, resulting in two matrices.\\n\\nFor internal nodes, the mode typs is used as a feature (no splitting)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Short path (t, p, n): path p from terminal node t to internal node n with >= 2 children.\\nPath pair (t_s, p_s, t_e, p_e): Two short paths with same internal node \\nSpan of a path pair: Let c_k denote the k-th child of the shared internal node of the two\\n                      short paths. Suppose p_s leads through c_i and p_e leads through c_j.\\n                      Then the span of the path pair is defined as j - i\\nLength of a pair path: |p_s| + |p_e| + 1\\nNumber of shor paths is reduced by limiting length and span.\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"For terminal nodes, content (names) and type \\nare both split up.\\n\\nFor non-terminal nodes, the mode typs is used as a feature (no splitting)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Cross block paths are extracted, \\nwhere a cross block path is a path from one \\nterminal node to another terminal node,\\nwhere the top node of the path defines a block\\nstructure (e.g. if block), and both nodes \\nare nested under said top node,\\nOR\\nthe left and right paths belong to two\\ndifferent parallel block structures \\n(e.g. two consecutive blocks nested in a block).\\nCertain amount of paths is sampled.\"\n}",
    "{\n  \"name\": \"Program Feedback Graph\",\n  \"description\": null,\n  \"artefacts\": [\n    {\n      \"name\": \"Compiler Feedback\",\n      \"details\": \"Line number i_err and error message m_err\"\n    },\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Token\",\n      \"details\": \"Token in the compiler error message. Specifically, the tokens \\nfound between quotation marks. (e.g. object \\\"a\\\" of type \\\"x\\\" has no attribute \\\"y\\\")\"\n    },\n    {\n      \"name\": \"Token\",\n      \"details\": \"Token from code. Specifically, variable names and occurrences of tokens\\nextracted from the error message.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Token Edge\",\n      \"details\": \"Undirected edge between identical tokens\"\n    }\n  ],\n  \"vertex-features\": \"Lines in the source code are tokenized\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Compiler message is tokenized \\nCompiler line number is used as feature\"\n}",
    "{\n  \"name\": \"Rep-HG\",\n  \"description\": \"Heterogeneous graph structure connecting repositories,\\nusers, and topics (tags) on Github.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code (repository)\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Metadata (repository)\",\n      \"details\": \"Non-source code artefacts in a repository (e.g. README file)\"\n    },\n    {\n      \"name\": \"User Profile Data\",\n      \"details\": \"Bio information. E.g. name, description, contact information\"\n    },\n    {\n      \"name\": \"Topic\",\n      \"details\": \"Topic on Github\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Repository\",\n      \"details\": \"Comprises two types of artefacts\"\n    },\n    {\n      \"name\": \"User\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Topic\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"R1; repository-belongto-user\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"R2; repository-contain-topic\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"R3; repository-forkby-user\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"R4; repository-starby-user\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"For repository nodes, all metadata and source code is combined into a single feature vector using BERT.\\nFor users, the user profile data as well as the _metadata_ of repositories belonging to the user are combined into a single feature vector using BERT.\\nThe topic is encoded as a single feature vector using BERT.\\nUsing the above features as-is will be referred to as the regular HG-graph, or node view.\\nThree meta-paths are also used. There are i) Repo --forkby--> User --forky^-1--> Repo i) Repo --starby--> User --starby^-1--> Repo i) Repo --contain--> Topic --contain^-1--> Repo\\nEach meta path is used separately in combination with random walk with restart in order to sample a subgraph defined by the meta-path.\",\n  \"edge-features\": null,\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Code Change Genealogy\",\n  \"description\": \"Graph representing the dependencies between code changes. \\nRoughly speaking, a code change is related to the previously \\nmost recent related code change, for some definition \\nof relatedness. For instance, when a call to a method is added,\\nthe change may be related to the last change modifying \\n(the signature of) said method.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code Changes\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Code Change\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Change Dependency Edge\",\n      \"details\": \"According to the rules of Herzig et al.\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Random walks over the graph are used.\\nA random walk produces a sequence of nodes,\\nwhich can be seen as a sentence. \\nA collection of random walks thus makes for a corpus of \\\"sentences\\\",\\nsimilar to what word2vec was trained on.\\n\\nFor the semantic-model task, the changed tokens (as a sequence)\\nper change are also included as features.\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"AST augmented with additional information\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Variable Node\",\n      \"details\": \"One node for each variable.\\nAll occurrences of a variable are attached to the unique note for that variable\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Child Edge\",\n      \"details\": \"Regular AST Edge\"\n    },\n    {\n      \"name\": \"Sibling Edge\",\n      \"details\": \"Connect child node to its sibling successor (represent order or \\\"arguments\\\" for an AST Node)\"\n    },\n    {\n      \"name\": \"Read Edge\",\n      \"details\": \"Used to connect a variable occurrence to the unique node for that variable\"\n    },\n    {\n      \"name\": \"Write Edge\",\n      \"details\": \"Used to connect a variable occurrence to the unique node for that variable\"\n    },\n    {\n      \"name\": \"Chronological Edge\",\n      \"details\": \"Establish order between nodes referencing the same variable name\"\n    }\n  ],\n  \"vertex-features\": \"Not specified what is used for node features\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"Graph describing and connecting multiple Python packages\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Packages\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Function\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Class field\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Class\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Module\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Class Method\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Non-indexed Symbol\",\n      \"details\": \"Not clearly explained\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Call\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Define/contain\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Type use\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Import\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Inherit\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Augmented AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"Undirected\"\n    },\n    {\n      \"name\": \"Next Token Edge (NCS)\",\n      \"details\": \"Undirected\"\n    },\n    {\n      \"name\": \"Computed From\",\n      \"details\": \"Undirected\"\n    },\n    {\n      \"name\": \"Last Read\",\n      \"details\": \"Undirected; connect use of variable to all possible moments of last read\"\n    },\n    {\n      \"name\": \"Last Write\",\n      \"details\": \"Undirected; connect use of variable to all possible moments of last write\"\n    },\n    {\n      \"name\": \"Returns To\",\n      \"details\": \"Undirected; Node in return statement points to the return type declaration in a method\"\n    },\n    {\n      \"name\": \"Last Scope Use\",\n      \"details\": \"Undirected; point variable to previous use in the scope\"\n    },\n    {\n      \"name\": \"Last Field Lex\",\n      \"details\": \"Undirected; Connect field access to the last of use said field\"\n    },\n    {\n      \"name\": \"Field\",\n      \"details\": \"Undirected; point field access to the point the field was declared\"\n    }\n  ],\n  \"vertex-features\": \"node type is one-hot encoded\",\n  \"edge-features\": \"edge type is one-hot encoded\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"Global graph state is one-hot encoded (unclear what is)\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"AST with various additional edges\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Syntax Node\",\n      \"details\": \"internal node/corresponds to nonterminal\"\n    },\n    {\n      \"name\": \"Syntax Token\",\n      \"details\": \"leaf node/contains program tokens\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Child Edge\",\n      \"details\": \"AST Edge (undirected)\"\n    },\n    {\n      \"name\": \"Next Token Edge\",\n      \"details\": \"NCS (undirected)\"\n    },\n    {\n      \"name\": \"Last Read Edge\",\n      \"details\": \"For syntax tokens corresponding to variables,\\nwe connect those tokens to all possible places \\nthe variable could have been read last. \\n(undirected)\"\n    },\n    {\n      \"name\": \"Last Write Edge\",\n      \"details\": \"For syntax tokens corresponding to variables,\\nwe connect those tokens to all possible places \\nthe variable could have been written to last.\\n(undirected)\"\n    },\n    {\n      \"name\": \"Computed From\",\n      \"details\": \"In an assignment v = expr, connect v to all\\nvariables used in the expression\\n(undirected)\"\n    },\n    {\n      \"name\": \"Last Lexical Use\",\n      \"details\": \"Connect occurrences of same variable in different \\ndata flow, e.g. if (...) { ... v ... } else { ... v ... }\\n(undirected)\"\n    },\n    {\n      \"name\": \"Returns To\",\n      \"details\": \"Connect return token to the method declaration (undirected)\"\n    },\n    {\n      \"name\": \"Formal Arg Name\",\n      \"details\": \"Connect actual arguments the formal arguments;\\ne.g. given bar(x) and bar(Integer y), connect x to y\\n(undirected)\"\n    },\n    {\n      \"name\": \"Guarded By\",\n      \"details\": \"Connect every variable token guarded by a conditional (if) \\nto the guard expression \\n(undirected)\"\n    },\n    {\n      \"name\": \"Guarded By Negation\",\n      \"details\": \"Connect every variable token guarded by the negation of a \\nconditional (else) to the guard expression \\n(undirected)\"\n    }\n  ],\n  \"vertex-features\": \"Syntax nodes use the node type name as a text feature.\\nSyntax tokens use the program content as a text feature.\\n\\nText payload is split into subtokens, each of which is \\nembedded (unclear how); average of embedding is computed.\\n\\nAll types are embedded using a trainable embedding layer.\\nEach variable has a type, which is encoded as the \\nelement-wise maximum of that type, and all its super-types\\n(including implementation relations).\",\n  \"edge-features\": \"In case of the var-misuse task, some adjustments are made to the graph:\\n1) The node corresponding to the slot is removed, and replaced with a context node\\n2) All LastUse, LastWrite, LastLexicalUse, and GuardedBy edges to the context node are removed \\n3) For every possible candidate variable, a new node is added, connected by the \\n    LastUse, LastWrite, and LastLexicalUse edges of the old node\",\n  \"connectivity-features\": \"adjacency list\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Heterogeneous Syntax Graph\",\n  \"description\": \"AST with explicitly heterogeneous edges\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Child Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"AST Parent Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"AST Left Sibling Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"AST Right Sibling Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Next Data Flow Node Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Previous Data Flow Node Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Not clearly specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Each token is enhanced with its line number and position (in terms of tokens) in the line it came from.\\n\\nThe goal of the model is to predict the next token in the summary.\\nAs such, the summary generated thus far is also an input.\"\n}",
    "{\n  \"name\": \"Heterogeneous Syntax Graph\",\n  \"description\": \"AST with explicitly heterogeneous edges\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Some nodes (e.g. \\\"Block\\\") are removed to reduce tree size\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Child Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"AST Parent Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"AST Left Sibling Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"AST Right Sibling Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Next Data Flow Node Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Previous Data Flow Node Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Previous Leaf Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Next Leaf Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Identifiers in nodes are split up\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"The goal of the model is to predict the next token in the summary.\\nAs such, the summary generated thus far is also an input.\"\n}",
    "{\n  \"name\": \"Control Flow Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Natural Sequence Edge\",\n      \"details\": \"natural control flow\"\n    },\n    {\n      \"name\": \"True Edge\",\n      \"details\": \"True branch of conditional\"\n    },\n    {\n      \"name\": \"False Edge\",\n      \"details\": \"False branch of conditional\"\n    }\n  ],\n  \"vertex-features\": \"Tokens in nodes are embedded using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Identifier names in tokens are split up; punctuation is removed \\nTokens from the code are encoded using word2vec.\\n\\nAlready generated words are encoded using word2vec.\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"AST with data flow information\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Nodes are one-hot encoded.\\n\\nUnclear what specifically is encoded.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Source code is tokenizes line-by-line, with CamelCase and under_scores split up. Tokens are one-hot encoded.\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Every node has three attributes:\\nx: Depth \\ny: left-to-right sequential position of its parent in the layer\\nz: left-to-right sequential position among its siblings\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"Each edge has the (x, y, z) attribute as its destination node as attributes\"\n    }\n  ],\n  \"vertex-features\": \"(x, y, z), and the token payload (type or token)\\nNote: vertices are used on their own, not as part of a graph\",\n  \"edge-features\": \"(x, y, z), and the pair of token payloads (type or token) of the nodes it is connecting \\nNote: edges are used on their own, not as part of a graph\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"The comment generated thus far (in token form) is also used as an input.\\nEach token is enhanced with positional information describing its location in the sequence.\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"Based on a meta model for source code and design patterns defined in \\n\\nMario Luca Bernardi, Marta Cimitile, and Giuseppe Di Lucca. 2014. Design\\npattern detection using a DSL-driven graph matching approach. Journal of\\nSoftware: Evolution and Process 26, 12 (2014), 1233\\u00e2\\u20ac\\u201c1266. https://doi.org/\\n10.1002/smr.1674\\n\\nThis describes graphs for source code.\\n\\nFor source code specifically, k-hop neighbourhoods are extracted from the\\nsystem (metamodel) graph.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Nodes from meta-model\\n\\nGraphs are centered around pivotal nodes (classes, interfaces, methods);\\nother types of nodes are thus ignored.\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Edges from meta-model\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a (unclear how node embeddings are initialised)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"Based on a meta model for source code and design patterns defined in \\n\\nMario Luca Bernardi, Marta Cimitile, and Giuseppe Di Lucca. 2014. Design\\npattern detection using a DSL-driven graph matching approach. Journal of\\nSoftware: Evolution and Process 26, 12 (2014), 1233\\u00e2\\u20ac\\u201c1266. https://doi.org/\\n10.1002/smr.1674\\n\\nThis describes graphs for design patterns\",\n  \"artefacts\": [\n    {\n      \"name\": \"Design Pattern Specifications\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Nodes from meta-model.\\n\\nGraphs are centered around pivotal nodes (classes, interfaces, methods);\\nother types of nodes are thus ignored.\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Edges from meta-model\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a (unclear how node embeddings are initialised)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Augmented AST\",\n  \"description\": \"AST augmented with additional edges\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"method\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"Undirected\"\n    },\n    {\n      \"name\": \"Computed From\",\n      \"details\": \"Undirected\"\n    },\n    {\n      \"name\": \"Last Use\",\n      \"details\": \"Undirected\"\n    },\n    {\n      \"name\": \"Returns To\",\n      \"details\": \"Undirected; Node in return statement points to the return type declaration in a method\"\n    },\n    {\n      \"name\": \"Next Token Edge\",\n      \"details\": \"Undirected; Connect nodes on the same level in sequential order (perhaps not named to aptly)\"\n    }\n  ],\n  \"vertex-features\": \"Not specified\",\n  \"edge-features\": \"When I say undirected, I mean back-edges are added\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Summary generated thus far (in tokens) is also given as input\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"The string represented by each node is embedded using word embeddings,\\nto obtain a matrix per node.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"CFG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Basic Block\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"The instructions in basic clock are one-hot encoded\\nto obtain a matrix per node.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"ADG (API Dependency Graph)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"API Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Dependency Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"AST with additional edges\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Next Subtree Edge\",\n      \"details\": \"Connects node on the same level\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Not specified\",\n  \"edge-features\": \"Edge type\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Source code is used as input\\n\\nCode summary generated thus far is used as input.\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Code tokens (in sequence) are also used as separate input.\\n\\nComment generated thus far (in tokens) is also given as input.\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"AST with additional edges\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Child\",\n      \"details\": \"Regular AST Edge\"\n    },\n    {\n      \"name\": \"Subtoken\",\n      \"details\": \"From a token (AST leaf node) to its subtokens (after splitting)\"\n    },\n    {\n      \"name\": \"Next Token\",\n      \"details\": \"NCS\"\n    },\n    {\n      \"name\": \"Last Lexical Use\",\n      \"details\": \"Connect occurrence of variable name to its most recent previous occurrence\"\n    }\n  ],\n  \"vertex-features\": null,\n  \"edge-features\": null,\n  \"connectivity-features\": null,\n  \"graph-features\": null,\n  \"other-features\": \"During training, ground truth token is given as input x'_j;\\nduring testing, previous token x'_j is given as input.\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"Simplified AST\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"Pairs of files; One old file and a revised version\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Some statement (internal) nodes are removed\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Word embedding is used to encode nodes. \\n\\nUnclear what exactly (node type, token payload) is encoded.\\nThe images in the paper suggests that the node type is encoded\\nfor internal nodes, and the payload for lexical nodes.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Tokens are split into subtokens with separate nodes\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"undirected\"\n    }\n  ],\n  \"vertex-features\": null,\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Tokenised Code is also used as input.\\n\\nPrevious summary tokens are also given as input\"\n}",
    "{\n  \"name\": \"Code Relationship Graph (CRG)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"Method\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Tokens are decomposed into sub-tokens\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Child\",\n      \"details\": \"AST Edge\"\n    },\n    {\n      \"name\": \"Next Token\",\n      \"details\": \"NCS\"\n    },\n    {\n      \"name\": \"Last Use\",\n      \"details\": \"Connect variable to all possible last uses\"\n    },\n    {\n      \"name\": \"Computed From\",\n      \"details\": \"Connect expression node to all variables occurring in it\"\n    },\n    {\n      \"name\": \"Return To\",\n      \"details\": \"Connect return tokens to method declaration\"\n    },\n    {\n      \"name\": \"Subtoken Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Not explicitly specified what is encoded/used as features, but \\nfigures suggest node type for internal node, and content (tokens) for other nodes.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Token sequence is used as input.\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Every node has three attributes:\\nx: Depth \\ny: left-to-right sequential position of its parent in the layer\\nz: left-to-right sequential position among its siblings (-1 for lexical nodeS)\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"(x, y, z), and the code token itself (type or token)\",\n  \"edge-features\": \"\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Tokenised code is used as a feature, where each token is enhanced with positional information\\n\\nThe comment generated thus far (in token form) is also used as an input.\\nEach token is enhanced with positional information describing its location in the sequence.\"\n}",
    "{\n  \"name\": \"Statement-centered AST\",\n  \"description\": null,\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": null\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Statement Node\",\n      \"details\": \"Statement node (one of the following must be met):\\n1) Node is expression statement, declaration statement, or branching statement (break, continue, return)\\n  --> This definition makes sure a statement contains no statement in its subtree (because if/for/while excluded)\\n2) A node represents an expression in a program and its parent node is a decision or loop statement.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge (directed, augmented)\",\n      \"details\": \"Use normal AST edges (directed), _but_ when a statement \\nnode is detected, reverse the direction of all edges in \\nthe subtree(s) of the statement node, so that they point\\nto the statement node.\"\n    }\n  ],\n  \"vertex-features\": \"Not specified\",\n  \"edge-features\": \"Edge type (up or down); encoding not specified\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "[\n  {\n    \"name\": \"AST\",\n    \"description\": \"n/a\",\n    \"artefacts\": [\n      {\n        \"name\": \"Source code\",\n        \"details\": \"n/a\"\n      }\n    ],\n    \"vertex-type\": [\n      {\n        \"name\": \"AST Node\",\n        \"details\": \"n/a\"\n      }\n    ],\n    \"edge-type\": [\n      {\n        \"name\": \"AST Edge\",\n        \"details\": \"n/a\"\n      }\n    ],\n    \"vertex-features\": \"First of all, for each node, its type, content, and position (line nr, column),\\nare combined into a string and embedded using a document embedding (flair)\\n\\nPaths from the root to leaf nodes are extracted, and embedded in the same way.\\n\\nPath embeddings are added to node embeddings to augment them.\",\n    \"edge-features\": \"n/a\",\n    \"connectivity-features\": \"Adjacency Matrix\",\n    \"graph-features\": \"n/a\",\n    \"other-features\": \"n/a\"\n  }\n]",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"All paths from the root to a terminal node are extracted, where\\n  1) the root has a value (content), 2) the leaf has a value (content), 3) the other nodes only have types.\\n\\n  Types are one-hot encoded.\\n\\nPreviously generated tokens are also given as input.\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"Heterogeneous graph mapping tokens to \\\"sentences\\\"\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Sentence Node\",\n      \"details\": \"For Java code, a sentence is a statement. For control statement, the portion before the opening { is used as a sentence.\\nFor Python code, each line is considered a sentence.\"\n    },\n    {\n      \"name\": \"Token Node\",\n      \"details\": \"Represents a single token. One unique node for every unique token\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"sentence/token edge\",\n      \"details\": \"connects a sentence node to every token contained in said sentence\"\n    }\n  ],\n  \"vertex-features\": \"Node payload, embedded using embedding layers\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Previously generated tokens are used as input.\"\n}",
    "{\n  \"name\": \"PDG\",\n  \"description\": \"based on Java compiled to (Jimple) IR\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Method\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"Jimple; Intermediate Representation\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Dependence Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Dependence Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Random walk is used to generate a bag of paths from the PDG.\\nEach path n_1 e_1 n_2 e_2 ... is seen as a sentence. \\nNode are replaced by their statements, edges with their type (data or control).\\nNLP preprocessing (tokenization, name splitting, remove non-alphabet characters,\\nremove locals, transform to lower case).\\n\\nThe IR is represented as a sequence and enhanced with type information.\\nSpecifically, the type of the instruction, and every token in the IR \\nstatement is prefixed with its nonterminal type according to the Jimple grammar. \\n\\nFirst comment of JavaDoc comment describing the method is also included as input.\\n\\nAll \\\"sentences\\\" obtained this way are combined into a single set of |N| + |P| + 1 sentences.\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"method\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Tokens are split into subtokens\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Child Edge\",\n      \"details\": \"Regular AST Edge\"\n    },\n    {\n      \"name\": \"Next Token Edge\",\n      \"details\": \"NCS\"\n    },\n    {\n      \"name\": \"Subtoken Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Last Lexical Use Edge\",\n      \"details\": \"Connect identifiers to their most recent use\"\n    }\n  ],\n  \"vertex-features\": \"Not specified how initial node features are computed\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Code Property Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Node content is used as feature\",\n  \"edge-features\": \"Edge type is used as feature\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"For a given code sample c, the most similar _known_\\n(code, summary) sample (c', s') is used as features,\\nwhere c' is also represented using a graph.\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Augmented AST\",\n  \"description\": \"AST augmented with additional edges\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"method\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"Undirected\"\n    },\n    {\n      \"name\": \"Computed From\",\n      \"details\": \"Undirected\"\n    },\n    {\n      \"name\": \"Last Use\",\n      \"details\": \"Undirected\"\n    },\n    {\n      \"name\": \"Returns To\",\n      \"details\": \"Undirected; Node in return statement points to the return type declaration in a method\"\n    },\n    {\n      \"name\": \"Next Token Edge\",\n      \"details\": \"Undirected; Connect nodes on the same level in sequential order (perhaps not named to aptly)\"\n    }\n  ],\n  \"vertex-features\": \"Not specified\",\n  \"edge-features\": \"When I say undirected, I mean back-edges are added\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Summary generated thus far (in tokens) is also given as input\"\n}",
    "{\n  \"name\": \"Function Call Graph\",\n  \"description\": null,\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Function\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Call Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"Edge weights calculated using Ricci curvature\",\n  \"connectivity-features\": \"Not  specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"AST with data flow information\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"Data flow between leaf nodes\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Code tokens are one-hot encoded (unclear how  this works)\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"Control flow graph with data flow and AST subtrees\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": null\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST node\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Basic Block node\",\n      \"details\": \"Not entirely clear whether this is a node type on its own.\\n\\nEvery basic block is represented using an AST.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Call flow edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Exception flow edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data flow edge\",\n      \"details\": \"Links variable definitions to their uses\"\n    },\n    {\n      \"name\": \"Exception Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Sequential Execution Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Conditional True Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Conditional False Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"Hypergraph based on AST\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Internal node (non-token)\"\n    },\n    {\n      \"name\": \"Identifier Node\",\n      \"details\": \"Token node\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Directed Hyper Edge\",\n      \"details\": \"If a node aggregates multiple items in e.g. a list,\\nthen the items in the list are connected to the parent \\nnode using a hyper edge (going _from_ multiple children _to_ the parent).\\n\\nEdges have distinct types, based on the type of relation \\nbetween parent and children (e.g. \\\"elements\\\" for list elements).\"\n    }\n  ],\n  \"vertex-features\": \"Node value (payload)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"DFG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Temporary Operand\",\n      \"details\": \"temporary \\\"variables\\\" that only exists in program execution\"\n    },\n    {\n      \"name\": \"Non-temporary Operand\",\n      \"details\": \"Variable/constant that explicitly exists in code\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Operation Edge\",\n      \"details\": \"Data flow for operators\"\n    },\n    {\n      \"name\": \"Function Edge\",\n      \"details\": \"data flow for arguments and return  values\"\n    }\n  ],\n  \"vertex-features\": \"Operation/operand types are one-hot encoded\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"CFG\",\n  \"description\": \"slightly altered compared to normal; different types of nodes\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Operation in Source code\",\n      \"details\": \"including standard operations, function calls, returns\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"PosNext\",\n      \"details\": \"Conditional Jumps in loops or branches.\"\n    },\n    {\n      \"name\": \"NegNext\",\n      \"details\": \"Conditional Jumps in loops or branches.\"\n    },\n    {\n      \"name\": \"IterJump\",\n      \"details\": \"Connect end of loop to begin\"\n    },\n    {\n      \"name\": \"CallNext\",\n      \"details\": \"From function call operation to first operation in called function\"\n    },\n    {\n      \"name\": \"ReturnNext\",\n      \"details\": \"From last operation in called function to operations right after function call\"\n    },\n    {\n      \"name\": \"Next\",\n      \"details\": \"Denote most common execution order\"\n    }\n  ],\n  \"vertex-features\": \"Operation/operand types are one-hot encoded\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Read-write Graph (RWG)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Operand\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Operation\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Read\",\n      \"details\": \"From operand to operations; operations required to compute the operand\"\n    },\n    {\n      \"name\": \"Write\",\n      \"details\": \"From operations to operand; variables receiving the operation result\"\n    }\n  ],\n  \"vertex-features\": \"Operation/operand types are one-hot encoded\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Combination of DFG, CFG and RWG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Temporary Operand\",\n      \"details\": \"temporary \\\"variables\\\" that only exists in program execution\"\n    },\n    {\n      \"name\": \"Non-temporary Operand\",\n      \"details\": \"Variable/constant that explicitly exists in code\"\n    },\n    {\n      \"name\": \"Operation in Source code\",\n      \"details\": \"including standard operations, function calls, returns\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Operation Edge\",\n      \"details\": \"Data flow for operators\"\n    },\n    {\n      \"name\": \"Function Edge\",\n      \"details\": \"data flow for arguments and return  values\"\n    },\n    {\n      \"name\": \"PosNext\",\n      \"details\": \"Conditional Jumps in loops or branches.\"\n    },\n    {\n      \"name\": \"NegNext\",\n      \"details\": \"Conditional Jumps in loops or branches.\"\n    },\n    {\n      \"name\": \"IterJump\",\n      \"details\": \"Connect end of loop to begin\"\n    },\n    {\n      \"name\": \"CallNext\",\n      \"details\": \"From function call operation to first operation in called function\"\n    },\n    {\n      \"name\": \"ReturnNext\",\n      \"details\": \"From last operation in called function to operations right after function call\"\n    },\n    {\n      \"name\": \"Next\",\n      \"details\": \"Denote most common execution order\"\n    },\n    {\n      \"name\": \"Read\",\n      \"details\": \"From operand to operations; operations required to compute the operand\"\n    },\n    {\n      \"name\": \"Write\",\n      \"details\": \"From operations to operand; variables receiving the operation result\"\n    }\n  ],\n  \"vertex-features\": \"Operation/operand types are one-hot encoded\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Heterogeneous Program Graph (HPG)\",\n  \"description\": \"Based on AST\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Every node has a type and a value.\\nThe type is the composite or primitive type of the node (e.g. statement),\\nthe value is either the Constructor (e.g. FunctionDef, for a statement in the\\nAbstract Syntax Description Language (ASDL), or the token payload \\nof the node (leaf nodes)\"\n    },\n    {\n      \"name\": \"Subtoken\",\n      \"details\": \"Two variants:\\nshared subtokens (one node for every _unique_ subtoken),\\nor separate subtoken node per occurrence\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Child\",\n      \"details\": null\n    },\n    {\n      \"name\": \"Next Sibling Edge\",\n      \"details\": null\n    },\n    {\n      \"name\": \"Next Token Edge\",\n      \"details\": null\n    },\n    {\n      \"name\": \"AST Parent\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Previous Sibling Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Previous Token Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Subtoken of\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Subtoken of reversed\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"type and value\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Structure Graph (SG)\",\n  \"description\": \"Essentially an AST\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Nodes representing variables are replaced with the types of those variables\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Child Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"AST Parent Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Encode tokens (either actual tokens or node type) using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Execution Data Flow Graph\",\n  \"description\": \"Based on AST\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Nodes representing variables are replaced with the types of those variables\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Route Edge\",\n      \"details\": \"Denotes execution flow between nodes (incl. branching)\"\n    },\n    {\n      \"name\": \"Value Edge\",\n      \"details\": \"Connects nodes representing variables to nodes providing the values for those variables\"\n    }\n  ],\n  \"vertex-features\": \"Encode tokens (either actual tokens or node type) using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"Mix of AST, CFG, DFG, NCS\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"functions\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Certain node types are merged. Nodes representing the same variables are merged.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"NCS Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Source code in node tokenised and \\nencoded using word2vec. \\nFinal vector is average of token embeddings.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Node types are used as features (encoded using embedding layer)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Pre-order traversal sequence of node types\"\n}",
    "{\n  \"name\": \"FDA\",\n  \"description\": \"Mixture of AST, FCG, and DFG\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge - LastUse\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge - Compute\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge - Formal\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge - Return\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge - Operand\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Function Call Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Unclear what node features are used\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"Each AST is split into subtrees.\\nSpecifically, each composite structure (e.g. if, while)\\nis replaced with a placeholder node, and the \\ncorresponding subtree is isolated from its parent tree.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"unclear how nodes in tokens are initially embedded\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"Structure tree (tree representing how all subtrees fit together) \\nis also used as graph.\",\n  \"other-features\": \"Raw code snippets are used as features\\n\\nFor code search, a query is given in text form.\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"directed\"\n    }\n  ],\n  \"vertex-features\": \"Node type and Node payload tokens are encoded using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Stacked adjacency tensor.\\n\\nFor every graph, the adjacency matrix is determined.\\nThe four matrices are then combined into a third order tensor.\\n\\nSelf connections are added to all graphs\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Control Flow Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"Edges representing control flow between basic blocks\"\n    }\n  ],\n  \"vertex-features\": \"Node type and Node payload tokens are encoded using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Stacked adjacency tensor.\\n\\nFor every graph, the adjacency matrix is determined.\\nThe four matrices are then combined into a third order tensor.\\n\\nSelf connections are added to all graphs\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Data Flow Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"Edges represent subsequent modification or access of the same variables\"\n    }\n  ],\n  \"vertex-features\": \"Node type and Node payload tokens are encoded using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Stacked adjacency tensor.\\n\\nFor every graph, the adjacency matrix is determined.\\nThe four matrices are then combined into a third order tensor.\\n\\nSelf connections are added to all graphs\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Natural Code Sequence\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Code Sequence Edge\",\n      \"details\": \"Edge from one AST leaf node to the next\"\n    }\n  ],\n  \"vertex-features\": \"Node type and Node payload tokens are encoded using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Stacked adjacency tensor.\\n\\nFor every graph, the adjacency matrix is determined.\\nThe four matrices are then combined into a third order tensor.\\n\\nSelf connections are added to all graphs\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"AST with various augmentations\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST node\",\n      \"details\": \"Basic structure is AST, with some simplifications:\\n\\n1) mentions of the same variable inside the name function are merged into a single node\\n2) mentions of the same function/class in a file are merged into a single node\\n3) All constants are erased and replaced with one global (shared) node \\n3) All identifiers are suffixed with their (inner-most) scope\"\n    },\n    {\n      \"name\": \"Subword node\",\n      \"details\": \"Identifiers in code are split into subwords, and each subword is represented by a separate node\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Next/Prev edge\",\n      \"details\": \"Next/prev edges between successive expressions\"\n    },\n    {\n      \"name\": \"Control block edge\",\n      \"details\": \"All expressions in a control block (e.g. if) link back to the parent control operator (e.g. if)\"\n    },\n    {\n      \"name\": \"function call edge (cross-file)\",\n      \"details\": \"Function callee is linked to called function\"\n    },\n    {\n      \"name\": \"Inheritance edge (cross-file)\",\n      \"details\": \"Child class is linked to parent class\"\n    },\n    {\n      \"name\": \"Import edge (cross-file)\",\n      \"details\": \"Link items in one file to items from other files\"\n    },\n    {\n      \"name\": \"Subword edge\",\n      \"details\": \"Edge from every subword (e.g. \\\"a\\\") to all nodes containing that subword (e.g. \\\"a@FunctionDef_scale\\\")\"\n    }\n  ],\n  \"vertex-features\": \"Not specified (unclear how initial vector representation is determined)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"AST augmented with information from markdown\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"snippets from Jupyter notebooks\"\n    },\n    {\n      \"name\": \"Markdown Text\",\n      \"details\": \"Natural language from Markdown from the Jupyter notebooks\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Virtual / classification token ([CLS])\",\n      \"details\": \"Always at the start of the token sequence\"\n    },\n    {\n      \"name\": \"Markdown token node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Classification ([CLS]) Edge\",\n      \"details\": \"Every node is connected to the [CLS] node\"\n    },\n    {\n      \"name\": \"Markdown Edge\",\n      \"details\": \"For a given snippet, each AST node in its AST is connected \\nto a node for every token the most recent markdown block \\n(occurring within 3 blocks)\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"The entire graph is sequenced using depth-first traversal,\\nbeginning with [CLS]\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": null,\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Various matrices are derived from the AST:\\n  1) Shortest path length; M_{ij} denotes the shortest path length from node i to node j (assuming undirected nodes)\\n  2) Ancestor distance; D_{ij} denotes the signed distance between \\\"familial\\\" nodes i and node j in the ast\\n  3) Sibling Distance; D_{ij} denotes the signed distance between sibling nodes i and node j in the ast\\n  4) Personalised PageRank scores \\nAll matrices are \\\"encoded\\\" by applying sinusoidal encoding to them. \\n\\nEvery token in the input is associated with an AST node (for the positional encoding).\\nAST node type is added to the token.\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast (some node types are removed)\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"not content (embedded by model)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"$\\\\sigma$-0 graph\",\n  \"description\": \"Mostly based on PDG, but with more variety in node types\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Entry Node\",\n      \"details\": \"Entrypoint of control flow into the graph\"\n    },\n    {\n      \"name\": \"Exit Node\",\n      \"details\": \"Exit point of control flow from the graph\"\n    },\n    {\n      \"name\": \"Data Node\",\n      \"details\": \"Represent data, e.g. constants, variables, literals\"\n    },\n    {\n      \"name\": \"Action Node\",\n      \"details\": \"Represent actions, e.g. function calls, operators, etc.\"\n    },\n    {\n      \"name\": \"Control Node\",\n      \"details\": \"Represent control points, e.g branches, looping\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Entry Node: \\\"ENTRY\\\"\\nExit Node: \\\"EXIT\\\" \\nVariable Node: name of the variable type \\nControl Node: Name of control structure (e.g. \\\"IF\\\")\\nAction node: not specified \\n\\nFeatures encoded using fast text, and average of tokens is used\",\n  \"edge-features\": \"Regular Control edge: Not specified \\nException control edge (catch): type of exception\\ndata edge: receiver, parameter, definition, condition, qualifier \\n\\nFeatures encoded using fast text, and average of tokens is used\",\n  \"connectivity-features\": \"Method not specified \\n\\nreverse edges are added\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"$\\\\sigma$-1 graph\",\n  \"description\": \"Mostly based on $\\\\sigma$-0 graph, but with additional information\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Entry Node\",\n      \"details\": \"Entrypoint of control flow into the graph\"\n    },\n    {\n      \"name\": \"Exit Node\",\n      \"details\": \"Exit point of control flow from the graph\"\n    },\n    {\n      \"name\": \"Data Node\",\n      \"details\": \"Represent data, e.g. constants, variables, literals\"\n    },\n    {\n      \"name\": \"Action Node\",\n      \"details\": \"Represent actions, e.g. function calls, operators, etc.\"\n    },\n    {\n      \"name\": \"Control Node\",\n      \"details\": \"Represent control points, e.g branches, looping\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Edge\",\n      \"details\": null\n    },\n    {\n      \"name\": \"Data Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Variable Usage Edges\",\n      \"details\": \"Multiple types, but unclear. At least FirstUse and LastUse\"\n    },\n    {\n      \"name\": \"Node Aliasing\",\n      \"details\": \"Not explained\"\n    },\n    {\n      \"name\": \"Control Dependence Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Same as $\\\\sigma$-0, but Node types (according to AST) are also used as features\",\n  \"edge-features\": \"Regular Control edge: Not specified \\nException control edge (catch): type of exception\\ndata edge: receiver, parameter, definition, condition, qualifier \\n\\nFeatures encoded using fast text, and average of tokens is used\",\n  \"connectivity-features\": \"Method not specified \\n\\nreverse edges are added\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Semantic Flow Graph (SFG)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Changesets (for bug localisation)\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Variable Node\",\n      \"details\": \"One for every _occurrence_ of a variable in the source code.\"\n    },\n    {\n      \"name\": \"Control Instruction Node\",\n      \"details\": \"For control structures such as if (if would have IfCondition, IfThen, IfElse, IfConverge)\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Sequential Computation Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Mask matrix for attention\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"1) Comment Input Sequence\\n    A (doc) comment associated with the source code, as tokens, beginning with the classification token [CLS]\\n2) Source Code Input Sequence\\n    [C] Cleaned source code tokens [SEP]\\n3) Node List \\n    [N] List of nodes \\n4) Type List \\n    [T] Type information of nodes -- out of list of 55 possible types \\n5) Role List \\n  [R] Role information of nodes -- out of list of 43 possible roles [SEP]\\n\\nFor bug localisation, the bug report is also given as feature\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"The AST is traversed (depth first order), and the resulting sequence of \\nAST node is used as the AST representation (types for internal nodes,\\ntokens for leaf nodes)\\n\\nThe original sequence of code tokens is also used as a feature\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"BERT for embedding nodes\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Sequence input is given. Per task this is:\\n  1) Comment and code for comment classification\\n  2) code and author for author attribution \\n  3) 2x code for duplicate function detection\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"AST with various additional edges\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Syntax Node\",\n      \"details\": \"internal node/corresponds to nonterminal\"\n    },\n    {\n      \"name\": \"Syntax Token\",\n      \"details\": \"leaf node/contains program tokens\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Child Edge\",\n      \"details\": \"AST Edge\"\n    },\n    {\n      \"name\": \"Subtoken Edge\",\n      \"details\": \"Sub token\"\n    },\n    {\n      \"name\": \"Next Token Edge\",\n      \"details\": \"NCS\"\n    },\n    {\n      \"name\": \"Last Read Edge\",\n      \"details\": \"For syntax tokens corresponding to variables,\\nwe connect those tokens to all possible places \\nthe variable could have been read last.\"\n    },\n    {\n      \"name\": \"Last Write Edge\",\n      \"details\": \"For syntax tokens corresponding to variables,\\nwe connect those tokens to all possible places \\nthe variable could have been written to last.\"\n    },\n    {\n      \"name\": \"Computed From\",\n      \"details\": \"In an assignment v = expr, connect v to all\\nvariables used in the expression\"\n    }\n  ],\n  \"vertex-features\": \"Unclear how tokens are embedded\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Dependency Parse Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Summary of code (training), query for search (testing)\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Token\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Dependency Edge\",\n      \"details\": \"One of 49 different types\"\n    },\n    {\n      \"name\": \"Next Token Edge\",\n      \"details\": \"NCS\"\n    },\n    {\n      \"name\": \"Subtoken Edge\",\n      \"details\": \"Sub token\"\n    }\n  ],\n  \"vertex-features\": \"Unclear how tokens are embedded\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Code Semantic Representation Graph (CSRG)\",\n  \"description\": \"AST with data flow information\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code with docstring\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"Directed edges are added between leaf nodes \\\"to determine branch statements in the AST\\\" (NOT NCS)\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Node representations computed using DeepWalk\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Code and summary/query are tokenised and put into a sequence,\\nand tokenised using FastText\"\n}",
    "{\n  \"name\": \"Heterogeneous Contract Graph\",\n  \"description\": \"Combination of heterogeneous control flow and heterogeneous call graphs at multiple levels of granularity.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Source code of smart contracts\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Different node types for different control flow (e.g ENTRY_POINT, NEW_VARIABLE, RETURN, IF, END_IF, FUNCTION_START)\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"FALLBACK_NODE\",\n      \"details\": \"Node to represent the call to a fallback function\"\n    },\n    {\n      \"name\": \"FUNCTION_NAME\",\n      \"details\": \"Node to represent the name of a function;\\nused combined with INTERNAL_CALL/EXTERNAL_CALL to represent FCG information,\\nand is connected to the ENTRY_POINT of a function (and thus forms the merging points for call and control flow graphs)\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Different types for control flow (e.g. TRUE, FALSE, NEXT)\",\n      \"details\": null\n    },\n    {\n      \"name\": \"INTERNAL_CALL\",\n      \"details\": \"Call to function within the same smart contract\"\n    },\n    {\n      \"name\": \"EXTERNAL_CALL\",\n      \"details\": \"Call to function in another smart contract\"\n    }\n  ],\n  \"vertex-features\": \"One-hot encoded node types, _but_ that is not used for most evaluations\",\n  \"edge-features\": \"All length 2 meta-paths for all pairs of node types are extracted. Not used for all evaluations. \\n(Note -- length 2 meta path is like A -> B -> C)\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Next Token Edge\",\n      \"details\": \"NCS\"\n    },\n    {\n      \"name\": \"Last Lexical Use Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Unclear how nodes are encoded\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Parse Tree\",\n  \"description\": \"Text is first transformed using T5 transformer\",\n  \"artefacts\": [\n    {\n      \"name\": \"Summary of the source code (training) or query (working)\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Token\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Constituency Symbol\",\n      \"details\": \"e.g. \\\"VB\\\" (verb)\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Constituency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Word Ordering Edge\",\n      \"details\": \"Undirected\"\n    }\n  ],\n  \"vertex-features\": \"Unclear how nodes are encoded\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"PDG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Method\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"Has as attribute the variable involved in the dependency\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Special traversal algorithm is used to sequence the graph.\\nThe process is reversible (i.e. retains some form of the structural information);\\nthe content of every node is then placed in its place in the sequence. \\n\\nThe method name is tokenised; the sequence is used as a feature \\n\\nTokens in the method body are used as a feature\\n\\nCode summary/query is tokenised and used as a feature\"\n}",
    "{\n  \"name\": \"APDG (Advanced PDG)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": null\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Method Declaration\",\n      \"details\": null\n    },\n    {\n      \"name\": \"Parameter\",\n      \"details\": null\n    },\n    {\n      \"name\": \"Unary Expression\",\n      \"details\": null\n    },\n    {\n      \"name\": \"Variable Declaration Expression\",\n      \"details\": null\n    },\n    {\n      \"name\": \"Method Call Expression\",\n      \"details\": null\n    },\n    {\n      \"name\": \"Assign Expression\",\n      \"details\": null\n    },\n    {\n      \"name\": \"Construction Declaration\",\n      \"details\": null\n    },\n    {\n      \"name\": \"Try Statement\",\n      \"details\": null\n    },\n    {\n      \"name\": \"Class Or Interface Declaration\",\n      \"details\": null\n    },\n    {\n      \"name\": \"Condition\",\n      \"details\": null\n    },\n    {\n      \"name\": \"Return Statement\",\n      \"details\": null\n    },\n    {\n      \"name\": \"Assert Statement\",\n      \"details\": null\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Dependence Edge\",\n      \"details\": null\n    },\n    {\n      \"name\": \"Control Dependence -- Child\",\n      \"details\": \"Essentially an AST Edge\"\n    },\n    {\n      \"name\": \"Control Dependence -- Next Statement\",\n      \"details\": null\n    },\n    {\n      \"name\": \"Control Dependence -- Judge\",\n      \"details\": \"True/False branches of if; back to condition for loop; denote conditional flow control\"\n    }\n  ],\n  \"vertex-features\": \"Graph Node is a set of (unordered) tokens (obtained from camel case for every node)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Summary (Training) or query (working) is also used as feature\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Next Token Edge\",\n      \"details\": \"NCS\"\n    },\n    {\n      \"name\": \"Last Lexical Use Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Unclear how nodes are encoded\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Parse Tree\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Summary of the source code (training) or query (working)\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Token\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Constituency Symbol\",\n      \"details\": \"e.g. \\\"VB\\\" (verb)\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Constituency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Word Ordering Edge\",\n      \"details\": \"Undirected\"\n    }\n  ],\n  \"vertex-features\": \"Unclear how nodes are encoded\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": null\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Token representation of the code is used as feature\"\n}",
    "{\n  \"name\": \"CFG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": null\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"See AST\"\n}",
    "{\n  \"name\": \"Flow-Enriched AST\",\n  \"description\": \"AST with control and data flow\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": null\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"undirected\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"undirected\"\n    },\n    {\n      \"name\": \"Data Flow Edge -- LastRead\",\n      \"details\": \"undirected\"\n    },\n    {\n      \"name\": \"Data Flow Edge -- LastWrite\",\n      \"details\": \"undirected\"\n    },\n    {\n      \"name\": \"Data Flow Edge -- ComputeFrom\",\n      \"details\": \"undirected\"\n    }\n  ],\n  \"vertex-features\": \"One-hot encoded node type\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"CFG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"Edges sometimes have labels, e.g. labelled \\\"true\\\" or \\\"false\\\" for conditionals\"\n    }\n  ],\n  \"vertex-features\": \"Tokens in node encoded using word2vec\",\n  \"edge-features\": \"Encoded using word2vec (0 padded if empty)\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"PDG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"Annotated with variable name\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"sometimes have labels, e.g. labelled \\\"true\\\" or \\\"false\\\" for conditionals\"\n    }\n  ],\n  \"vertex-features\": \"Tokens in node encoded using word2vec\",\n  \"edge-features\": \"Encoded using word2vec (0 padded if empty)\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"Mix of AST, CFG, DF G\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"file\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"PDG\",\n  \"description\": \"b/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Dependence Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependence Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"One-hot encoding of statement type\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Tree Graph\",\n  \"description\": \"Simplified version of AST\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node Type Node\",\n      \"details\": \"Every node type in the AST has _one_ node in the tree graph\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Edge\",\n      \"details\": \"There is an edge between two node types in the tree graph \\nif and only if there exists an edge between two nodes of \\nthose types in the original AST.\"\n    }\n  ],\n  \"vertex-features\": \"1) Degree Centrality\\n2) Katz Centrality \\n3) Betweenness Centrality\\n4) Eigenvector Centrality\\n5) Closeness Centrality\\n6) Harmonic Centrality\\n7) Mean Centrality: average of the six above\\n8) Concatenate Centrality: concatenation of the first six\\n\\nEach centrality measure is tested _individually_.\\nThe feature vectors (obtained by concatenating the measures \\nfor all [72] node types) for two code samples asre concatenated \\nand passed to a classifier.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"PDG (Program Dependence Graph)\",\n  \"description\": \"Based on Jimple IR\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Multiple files\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Instruction\",\n      \"details\": \"Based on the Jimple instructions\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data flow edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control flow edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Method call edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Embedding instructions (as learned by the Lexical Embedding Model)\",\n  \"edge-features\": \"n/a (edge type)\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Each Jimple instruction is split into subwords.\\nA Word2Vec model is trained on the subwords.\"\n}",
    "{\n  \"name\": \"LR-FA-AST (Less Redundancy Flow Augmented AST)\",\n  \"description\": \"Flow-augmented AST with pruning applied.\\nSpecifically, only \\\"important\\\" nodes and their edges \\nare kept, where important nodes are nodes dealing \\nwith variable/method declarations, and control structures (e.g. if, loops)\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Certain node types are pruned (see description)\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Block Edge\",\n      \"details\": \"Edges between the child node of block structures\"\n    },\n    {\n      \"name\": \"Conditional Edge\",\n      \"details\": \"Edges between child nodes of control structures (e.g. while, if)\"\n    },\n    {\n      \"name\": \"Leaf Edge\",\n      \"details\": \"Edges between (successive) leaf nodes\"\n    },\n    {\n      \"name\": \"Control Edge\",\n      \"details\": \"Edges for function calls(?)\"\n    }\n  ],\n  \"vertex-features\": \"Unclear; presumably node type based on images in the paper\",\n  \"edge-features\": \"Edges have weights; unclear how they are computed. It seems to be the edge type\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Fused Clone PDG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Code Clone Source Code\",\n      \"details\": \"For a given pair of code clones, where one has been modified,\\nthree artefacts are used:\\n1) Original code of the changed clone \\n2) Modified code of the changed clone\\n3) Code of the other clone\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"Every node has a triple-vector (Existence Vector), \\nindicating whether that node is present in the PDG \\nof every included code snippet.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Dependence Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependence Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Execution Edge\",\n      \"details\": \"Represent order of node execution\"\n    },\n    {\n      \"name\": \"Mapping Edge\",\n      \"details\": \"Edge connecting two \\\"corresponding\\\" nodes originating from the PDGs of two code snippets,\\nbut which do not contain the exact same statement\"\n    }\n  ],\n  \"vertex-features\": \"Code encoded using CodeBERT; vector concatenated with the existence vector\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"AST with additional edges\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Next Token Edge\",\n      \"details\": \"NCS\"\n    },\n    {\n      \"name\": \"Hub Edge (My name; does not have a name in the paper)\",\n      \"details\": \"Connects node with types which generally have \\nmany child nodes (e.g. ClassDeclaration, MethodDeclaration)\"\n    }\n  ],\n  \"vertex-features\": \"Word vectors are used to encode node (unclear what exactly is encoded; could be node type for internal nodes, token for leafs)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency List\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"AST with additional edges. \\n\\nThere might be more edges than listed in the list below. \\nThe paper is unclear about this.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"If Edge\",\n      \"details\": \"Connects If statement node with condition and block\"\n    },\n    {\n      \"name\": \"For Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"While Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"CFG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Basic Block\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/ a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"The node centrality is computed for every node.\\nThis centrality is \\\"assigned\\\" to every token in the node.\\nThe centralitities of the same token in different blocks are summed.\\nThese tokens are encoded using word2vec; \\nThe word vectors are multiplied with the summed node centrality.\\nThis sequence is used as the model input.\"\n}",
    "{\n  \"name\": \"FA-AST (Flow-augmented AST)\",\n  \"description\": \"AST with additional edges (all edges undirected)\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Child Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"AST Parent Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Next Sibling Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Next Token Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Next Use Edge\",\n      \"details\": \"Connect variable to its next use\"\n    },\n    {\n      \"name\": \"If Edge\",\n      \"details\": \"Connect if statement to its condition, ThenStatement, and ElseStatement\"\n    },\n    {\n      \"name\": \"While Edge\",\n      \"details\": \"Connect while statement to its condition and body\"\n    },\n    {\n      \"name\": \"For Edge\",\n      \"details\": \"Connect for statement to its control, and body\"\n    },\n    {\n      \"name\": \"Sequential Execution Edge\",\n      \"details\": \"Sequential execution between statements _in a code block_\"\n    }\n  ],\n  \"vertex-features\": \"Unclear what exactly is used. Seems to be at least the actual token payload for leaf nodes.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"CFG where each \\\"node\\\" has its own AST subtree\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"Smart contract\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement (CFG)\",\n      \"details\": \"Each such node has an AST tree as \\\"value\\\".\\n\\nEach statement has as type, based on the type \\nof the root of its AST subtree.\\nFor some types (e.g. Assignment), more analysis is \\nperformed to refine  the type (e.g. \\\"Memory Assignment\\\")\"\n    },\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Only occurs as the child of a CFG Node\"\n    },\n    {\n      \"name\": \"Virtual Function Node\",\n      \"details\": \"All CFG node in the graph has an edge to this node\"\n    },\n    {\n      \"name\": \"Virtual Loop Node\",\n      \"details\": \"All CFG nodes in a loop point to a Virtual Loop Node\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"Edge between CFG Nodes\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"Edge between CFG Nodes\"\n    },\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"Edge between AST Nodes\"\n    }\n  ],\n  \"vertex-features\": \"InferCode is used to encode nodes in AST subtrees,\\nand to encode the statement type of each CFG node\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Code Property Graph\",\n  \"description\": \"Slicing is applied based on vulnerable functions and vulnerable data\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"smart contracts\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Tokens encoded using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"9 handcrafted expert features are used\"\n}",
    "{\n  \"name\": \"Propagation Chain\",\n  \"description\": \"Denotes relationships between different variables.\\n\\nThe graph described below is further trimmed based on \\ncertain \\\"key information\\\". The information nor the process \\nis described in detail.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Smart contracts\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Variable at token\",\n      \"details\": \"Each node represents the occurrence of variable, identified with its index in the sequence of program tokens\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Value Comes From\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Value Computed From\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified (Mask Matrix)\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"The token sequence of the source code (CT)\\nThe positions of the tokens in the source code \\nThe sequence of variables in the source code (V)\\nThe positions of the variables.\\nCT and V are concatenated to obtain I_1; the position sets are concatenated to obtain I_2.\\n\\nFor every variable\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"AST with additional data- and control flow edges\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"smart contract\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Next Node\",\n      \"details\": \"Added if two nodes are adjacent in the depth first traversal of the AST\"\n    },\n    {\n      \"name\": \"Next Token\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Condition True\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Condition False\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"While Exec\",\n      \"details\": \"Connect root of condition subtree to root of body subtree\"\n    },\n    {\n      \"name\": \"For Exec\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Last Read\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Last Write\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Next Use\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Unclear what exactly is used as feature. \\nSeems to be token for leaf nodes, nonterminal for non-leaf nodes.\\nPaper does not mention specific features.\\n\\nUnclear how feature are encoded.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"FA-AST (Flow-Augmented AST)\",\n  \"description\": null,\n  \"artefacts\": [\n    {\n      \"name\": \"Source code (file)\",\n      \"details\": null\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Purely syntactic nodes (e.g. \\\"{\\\") removed\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST child\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"AST parent\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"FA Next Token\",\n      \"details\": \"Connects one terminal leaf node to next terminal leaf node\"\n    },\n    {\n      \"name\": \"FA Next Sibling\",\n      \"details\": \"Connects each node to its next sibling\"\n    },\n    {\n      \"name\": \"FA Next Use\",\n      \"details\": \"Connects a node representing a variable to the next use of said variable\"\n    },\n    {\n      \"name\": \"FA If Flow\",\n      \"details\": \"Connects condition of if statement with code block that is executed if the condition is true\"\n    },\n    {\n      \"name\": \"FA Else Flow\",\n      \"details\": \"Connects condition of if statement with code block that is executed if the condition is false\"\n    },\n    {\n      \"name\": \"FA While Flow\",\n      \"details\": \"Connects condition of while statement with code block that is executed while the condition is true.\\n\\nThe block also has a FA Next Use back to the condition\"\n    },\n    {\n      \"name\": \"FA For Flow\",\n      \"details\": \"Connects condition of for statement with code block that is executed while the condition is true.\\n\\nThe block also has a FA Next Use back to the condition\"\n    },\n    {\n      \"name\": \"FA Next Statement Flow\",\n      \"details\": \"Edge to the directly following statement\"\n    }\n  ],\n  \"vertex-features\": \"na / Not specified (unclear how embeddings are initialised)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Line Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"Smart Contracts\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Line\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Function Edge\",\n      \"details\": \"Connect first and last lines of function declaration\"\n    },\n    {\n      \"name\": \"Control Edge\",\n      \"details\": \"end to end connections between control blocks (if/for/while)\"\n    },\n    {\n      \"name\": \"Sequential Edge\",\n      \"details\": \"Connect lines in top to bottom order\"\n    },\n    {\n      \"name\": \"Variable Edge\",\n      \"details\": \"Connect nodes containing the same variables\"\n    },\n    {\n      \"name\": \"Modifier Edge\",\n      \"details\": \"connect definitions of modifiers to their corresponding uses\"\n    },\n    {\n      \"name\": \"Reentrancy Edge\",\n      \"details\": \"Connect nodes contain \\\"call.value\\\" to all other nodes belonging to the same function\"\n    }\n  ],\n  \"vertex-features\": \"Text content of every line is used as feature (after preprocessing; normalisation of identifiers etc)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not explicitly specified, but seems to be 6 adjacency matrices\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"Graph representing program elements in a smart contract. \\nIt is not entirely clear what constitutes a program element.\\nIt seems to be variables and function invocations, based on the \\nproposed node features.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"smart contract\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Core Node\",\n      \"details\": \"Critical for vulnerability detection (e.g. money transfer, call.value)\"\n    },\n    {\n      \"name\": \"Normal Node\",\n      \"details\": \"Nodes that are not marked as core\"\n    },\n    {\n      \"name\": \"Fallback Node\",\n      \"details\": \"Simulates fallback function of a contract\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Fallback Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Depend on node type:\\n  1) Function Invocation Nodes\\n      i) Function Identifier\\n      ii) Caller Address\\n      iii) Node Type\\n      iv) Flag indicating whether the function has limited access (e.g. must be owner)\\n\\n  2) Variable/fallback nodes\\n      i) Identifier\\n      ii) Node Type\\n\\n  Next, feedback and normal nodes are removed. \\n  Their features are \\\"assigned\\\" to the nearest core\\n  node (to multiple in case of multiple closest core nodes).\\n  The removed edges become self-loops on the core nodes. \\n\\n  As a result, only core vertices remain, and they have \\n  three sets of features:\\n  1) Self-features (their original ones)\\n  2) In-features: all features from normal nodes that\\n      were pointing toward the core node\\n  3) Out-features: all features from normal nodes that\\n      were pointed away from the core node\\n\\n  It is unclear how exactly the features are _encoded_\",\n  \"edge-features\": \"Order (sequential order in the function), edge type\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Various hand-crafted/expert features are used (0/1 values indicating existence of certain patterns)\"\n}",
    "{\n  \"name\": \"Heterogeneous Contract Graph\",\n  \"description\": \"Combination of heterogeneous control flow and heterogeneous call graphs at multiple levels of granularity.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Source code of smart contracts\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"ROOT (cfg node)\",\n      \"details\": \"Entry point of the control flow graph of a function\"\n    },\n    {\n      \"name\": \"BASIC (cfg node)\",\n      \"details\": \"Basic block\"\n    },\n    {\n      \"name\": \"DISPATCHER (cfg node)\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"LEAF (cfg node)\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"EXIT (cfg node)\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"FALLBACK NODE (cfg node)\",\n      \"details\": \"Node to represent the call to a fallback function\"\n    },\n    {\n      \"name\": \"FUNCTION_NAME\",\n      \"details\": \"Node to represent the name of a function;\\nused combined with INTERNAL_CALL/EXTERNAL_CALL to represent FCG information,\\nand is connected to the ENTRY_POINT of a function (and thus forms the merging points for call and control flow graphs)\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Different types for control flow (e.g. TRUE, FALSE, NEXT)\",\n      \"details\": null\n    },\n    {\n      \"name\": \"INTERNAL_CALL\",\n      \"details\": \"Call to function within the same smart contract\"\n    },\n    {\n      \"name\": \"EXTERNAL_CALL\",\n      \"details\": \"Call to function in another smart contract\"\n    }\n  ],\n  \"vertex-features\": \"Four different schemes of generating node features, used separately:\\n  1) One-hot encoded node types\\n  2) metapath2vec (random walk + skipgram)\\n  3) LINE \\n  4) node2vec\",\n  \"edge-features\": \"All length 2 meta-paths for all pairs of node types are extracted. (Note -- length 2 meta path is like A -> B -> C)\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"smart contract\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"AST is normalised (normalise identifiers), serialized (depth first order), and encoded using word2vec\"\n}",
    "{\n  \"name\": \"CFG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"smart contract\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Basic Block  (statement)\",\n      \"details\": \"consecutive operations without jump\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Encode statements using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"CFG\",\n  \"description\": \"Control flow graph extracted from the bytecode of a smart contract\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"smart contract\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Entry Point\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"New Variable\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"If\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Expression\",\n      \"details\": \"assignment without declaration\"\n    },\n    {\n      \"name\": \"EndIf\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Return\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"True Branch Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"False Branch Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"TF/IDF weighted sum of the Word2Vec embeddings in the opcodes of a node\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"S-AST\",\n  \"description\": \"AST with control flow information and subtokens\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"Method level\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST non-leave node\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"AST leave node\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"API Invocation node\",\n      \"details\": \"e.g. \\\"Method Invocation\\\" node in the AST.\"\n    },\n    {\n      \"name\": \"Subtoken Node\",\n      \"details\": \"Every identifier in a node (e.g \\\"getLarger\\\") is split into subtokens (\\\"get\\\", \\\"L\\\", \\\"arger\\\").\\nFirst first one (\\\"get\\\") is kept as the parent node in place of the identifier; \\nthe other subtokens are kept as child nodes.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Leaf Edge\",\n      \"details\": \"Edge to the next leaf node (which may be of type \\\"Subtoken\\\" in case of a subtoken parent node)\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"Edge to next usage of a variable, starting from declaration\"\n    },\n    {\n      \"name\": \"Subtoken Edge\",\n      \"details\": \"Edge between subtoken child and parent node\"\n    }\n  ],\n  \"vertex-features\": \"Not specified/unclear how initial embedding are intialised\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"1) Leaf Edges and edges linking variables are removed \\n2) Graph is partitioned into subtrees, where each subtree represents a statement\\n3) Subtrees are grouped (left-to-right) into subgraphs based on their size using a threshold lamda\\n4) Leaf Edges and variable linking edges are re-instated per subgraph\",\n  \"other-features\": \"The raw code of the method is converted to AST. The token types (or payloads for leaves)\\nare linearised through pre-order traversal. The API description is aded to this text.\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": null\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Tokens\",\n      \"details\": \"Source code is tokenized. Every token has a node\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Edge\",\n      \"details\": \"There exists an edge between successive tokens.\\n\\nTODO: This is probably not right but I do not understand \\nwhat the authors mean by \\\"co-occurrence\\\"\"\n    }\n  ],\n  \"vertex-features\": \"Tokens are embedding using BERT\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Weighted Directed Class Coupling Network (WDCCN)\",\n  \"description\": \"Graph representing different types of coupling between classes,\\nwith different weights depending on the type of coupling.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code (project)\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Class\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"LVA\",\n      \"details\": \"Local Variable; For edge (u, v), class u contains a local variable of type v in a method.\"\n    },\n    {\n      \"name\": \"GVA\",\n      \"details\": \"Global Variable; For edge (u, v), class u contains a field of type v.\"\n    },\n    {\n      \"name\": \"INH\",\n      \"details\": \"Inheritance;  For edge (u, v), class u inherits from class v.\"\n    },\n    {\n      \"name\": \"IMP\",\n      \"details\": \"Implementation; For edge (u, v), class u implements interface v.\"\n    },\n    {\n      \"name\": \"PAR\",\n      \"details\": \"Parameter; For edge (u, v), class u contains method with a parameter of type v.\"\n    },\n    {\n      \"name\": \"RET\",\n      \"details\": \"Return; For edge (u, v), class u contains method with a return type of type v.\"\n    },\n    {\n      \"name\": \"INS\",\n      \"details\": \"Instantiates; For edge (u, v), class u instantiates class v.\"\n    },\n    {\n      \"name\": \"ACC\",\n      \"details\": \"Access; For edge (u, v), class u accesses a field of class v\"\n    },\n    {\n      \"name\": \"MEC\",\n      \"details\": \"Method Call; For edge (u, v), class u calls a method of class v.\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"Edge features based on distribution with which coupling occurs in a project.\\n\\nLet N denote the intra-package coupling of some type, and M the inter-package coupling.\\nThen, the weight is defined as:\\n\\n10 if N > 0 and M = 0\\n1 if N = M = 0\\nround(0.5 + 10 * N / (N + M)) otherwise\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Weighted Directed Class Coupling Network (WDCCN)\",\n  \"description\": \"Graph representing different types of coupling between classes,\\nwith different weights depending on the type of coupling.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code (project)\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Class\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"LVA\",\n      \"details\": \"Local Variable; For edge (u, v), class u contains a local variable of type v in a method.\"\n    },\n    {\n      \"name\": \"GVA\",\n      \"details\": \"Global Variable; For edge (u, v), class u contains a field of type v.\"\n    },\n    {\n      \"name\": \"INH\",\n      \"details\": \"Inheritance;  For edge (u, v), class u inherits from class v.\"\n    },\n    {\n      \"name\": \"IMP\",\n      \"details\": \"Implementation; For edge (u, v), class u implements interface v.\"\n    },\n    {\n      \"name\": \"PAR\",\n      \"details\": \"Parameter; For edge (u, v), class u contains method with a parameter of type v.\"\n    },\n    {\n      \"name\": \"RET\",\n      \"details\": \"Return; For edge (u, v), class u contains method with a return type of type v.\"\n    },\n    {\n      \"name\": \"INS\",\n      \"details\": \"Instantiates; For edge (u, v), class u instantiates class v.\"\n    },\n    {\n      \"name\": \"ACC\",\n      \"details\": \"Access; For edge (u, v), class u accesses a field of class v\"\n    },\n    {\n      \"name\": \"MEC\",\n      \"details\": \"Method Call; For edge (u, v), class u calls a method of class v.\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"Edge weights based on existing ordinal rankings in literature,\\nre-mapped to correspond to the proposed edge types.\\n  \\nWeights:\\nLVA: 1\\nGVA: 5.5\\nINH: 9\\nIMP: 10\\nPAR: 1\\nRET: 1\\nINS: ignored \\nACC: ignored \\nMEC: 1\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Weighted Directed Class Coupling Network (WDCCN)\",\n  \"description\": \"Graph representing different types of coupling between classes,\\nwith different weights depending on the type of coupling.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code (project)\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Class\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"LVA\",\n      \"details\": \"Local Variable; For edge (u, v), class u contains a local variable of type v in a method.\"\n    },\n    {\n      \"name\": \"GVA\",\n      \"details\": \"Global Variable; For edge (u, v), class u contains a field of type v.\"\n    },\n    {\n      \"name\": \"INH\",\n      \"details\": \"Inheritance;  For edge (u, v), class u inherits from class v.\"\n    },\n    {\n      \"name\": \"IMP\",\n      \"details\": \"Implementation; For edge (u, v), class u implements interface v.\"\n    },\n    {\n      \"name\": \"PAR\",\n      \"details\": \"Parameter; For edge (u, v), class u contains method with a parameter of type v.\"\n    },\n    {\n      \"name\": \"RET\",\n      \"details\": \"Return; For edge (u, v), class u contains method with a return type of type v.\"\n    },\n    {\n      \"name\": \"INS\",\n      \"details\": \"Instantiates; For edge (u, v), class u instantiates class v.\"\n    },\n    {\n      \"name\": \"ACC\",\n      \"details\": \"Access; For edge (u, v), class u accesses a field of class v\"\n    },\n    {\n      \"name\": \"MEC\",\n      \"details\": \"Method Call; For edge (u, v), class u calls a method of class v.\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"Weights fine-tuned based on performance in architecture reconstruction.\\n  \\nWeights:\\nLVA: 1\\nGVA: 3\\nINH: 3\\nIMP: 4\\nPAR: 3\\nRET: 3\\nINS: 2 \\nACC: 2 \\nMEC: 2\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"CAG (Code Aggregate Graph)\",\n  \"description\": \"Combination of AST, CFG, PDG (Program Dependence Graph), DT (Dominator Tree), and PDT (Post-dominator Tree)\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Seemingly method level\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge (Tree labels; true, false, empty)\",\n      \"details\": \"Edge from one statement ot other statements that may directly follow it\"\n    },\n    {\n      \"name\": \"Dominator Edge\",\n      \"details\": \"Edge from a node to every node that it dominates\"\n    },\n    {\n      \"name\": \"Post-dominator Edge\",\n      \"details\": \"Edge from a node to every node that is post-dominates\"\n    },\n    {\n      \"name\": \"Data Dependence Edge\",\n      \"details\": \"Edge from variable declaration to all its uses\"\n    }\n  ],\n  \"vertex-features\": \"Code statement and node type are encoded using Word2Vec (CBOW)\\n\\nThis is concatenated with a one-hot encoding of the node type.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"CAG (Code Aggregate Graph)\",\n  \"description\": \"Combination of AST, CFG, PDG (Program Dependence Graph), DT (Dominator Tree), and PDT (Post-dominator Tree)\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Seemingly method level\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge (Tree labels; true, false, empty)\",\n      \"details\": \"Edge from one statement ot other statements that may directly follow it\"\n    },\n    {\n      \"name\": \"Dominator Edge\",\n      \"details\": \"Edge from a node to every node that it dominates\"\n    },\n    {\n      \"name\": \"Post-dominator Edge\",\n      \"details\": \"Edge from a node to every node that is post-dominates\"\n    },\n    {\n      \"name\": \"Data Dependence Edge\",\n      \"details\": \"Edge from variable declaration to all its uses\"\n    }\n  ],\n  \"vertex-features\": \"Code statement and node type are encoded using FastText \\n\\nThis is concatenated with a one-hot encoding of the node type.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"CAG (Code Aggregate Graph)\",\n  \"description\": \"Combination of AST, CFG, PDG (Program Dependence Graph), DT (Dominator Tree), and PDT (Post-dominator Tree)\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Seemingly method level\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge (Tree labels; true, false, empty)\",\n      \"details\": \"Edge from one statement ot other statements that may directly follow it\"\n    },\n    {\n      \"name\": \"Dominator Edge\",\n      \"details\": \"Edge from a node to every node that it dominates\"\n    },\n    {\n      \"name\": \"Post-dominator Edge\",\n      \"details\": \"Edge from a node to every node that is post-dominates\"\n    },\n    {\n      \"name\": \"Data Dependence Edge\",\n      \"details\": \"Edge from variable declaration to all its uses\"\n    }\n  ],\n  \"vertex-features\": \"Code statement and node type are encoded using GloVe\\n\\nThis is concatenated with a one-hot encoding of the node type.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"Interconnected ASTs with data flow and control flow edges\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"Source code taken from multiple source files.\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"First, file containing unit tests are parsed. \\nTest _bodies_ are isolated and used to construct the initial graph.\\nThe graph is expanded by including the AST bodies of all (possibly non-test)\\nmethods called in the unit test.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data flow edge\",\n      \"details\": \"No details given\"\n    },\n    {\n      \"name\": \"Control flow edge\",\n      \"details\": \"No details given\"\n    }\n  ],\n  \"vertex-features\": \"Not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Program Dependency Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"PDG Node\",\n      \"details\": \"Nodes are created for AST nodes containing \\n1) method calls\\n2) assignment\\n3) control statements \\n4) declarations \\n5) API field access \\n\\nFurthermore, every node involving a type has the type name fully expanded (e.g. java.lang.String)\"\n    },\n    {\n      \"name\": \"Hole\",\n      \"details\": \"Node in the graph for which a type must be predicted.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"PDG Edge\",\n      \"details\": \"Both data and control flow edges\"\n    },\n    {\n      \"name\": \"Prediction Flow Dependency Edge\",\n      \"details\": \"Edge from a node in the PDF to the hole\"\n    }\n  ],\n  \"vertex-features\": \"n/a (embedding layer)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Textual elements are extracted. Specifically:\\n1) The name of the method in which a prediction is made. Compound name (e.g. getFileLine) are split into individual words.\\n2) All (full) names of all API classes used in the method\\n3) Variable Names\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"Combination of a graph showing module/class/function/method/field/variable relations\\nand an abstract syntax tree.\\n\\nNote that although vertices represent different things, in practice, there is only 1 vertex type.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Module\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Class\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Function\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Method\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Class Field\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Module Variable\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"AST Type\",\n      \"details\": \"Every AST Node has a type node pointing to it.\\nFor instance, every function definition has an incoming edge from the \\\"FunctionDef\\\" node.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Define\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Use\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Type use\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Import\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Call\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Import\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"AST Type Edge\",\n      \"details\": \"Every AST Node has a type node pointing to it.\\nFor instance, every function definition has an incoming edge from the \\\"FunctionDef\\\" node.\"\n    }\n  ],\n  \"vertex-features\": \"Not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Source code is tokenized. A FastText model is trained on the tokens.\\nThe tokens are encoded using FastText.\\n\\nFor every token, prefix and suffix information is collected.\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"Based on syntactic dependency parsing from NLP\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code (methods)\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST leaf nodes\",\n      \"details\": \"During evaluation, tokens in the leaf nodes were lowered,\\nnon-identifier tokens were removed, and rare tokens were \\nalso removed, thus reducing the number of nodes present \\nin the final graph.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"n/a\",\n      \"details\": \"For every (source, target) pair (v1, v2) of AST nodes, \\nfind the least common ancestor of v1 and v2 in the AST.\\nThe edge label is given by \\n1) taking every node in the path from v1 to the ancestor,\\n  and adding an \\\"up\\\" arrow after every node type name\\n2) Taking every node in the path from the ancestor to v2,\\n  and adding an \\\"down\\\" arrow after every node type name\\n3) Concatenating all nodes in the path (as described above)\\n  using \\\"-\\\" symbols.\\n\\nIf the path is longer than some threshold, it is ignored.\\nOtherwise, the edge is present in the final graph.\"\n    }\n  ],\n  \"vertex-features\": \"Not specified, nor specified how vertex features are initialised\",\n  \"edge-features\": \"Not specified\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"AST with some simplifications;\\n1) only function are kept\\n2) all functions are aggregated under a single root node\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Encoded using Embedding Layer\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Computed using word embeddings\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"AST with additional control and data flow edges. Note that all edges are undirected\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Next token\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Computed From\",\n      \"details\": \"e.g. assigment target to expression\"\n    },\n    {\n      \"name\": \"Guarded By\",\n      \"details\": \"Edge from each variable in an if-block to the condition of the if-block\"\n    },\n    {\n      \"name\": \"Jump\",\n      \"details\": \"Edge between variables with control dependencies\"\n    },\n    {\n      \"name\": \"Last Use\",\n      \"details\": \"Edge between uses of the same variable\"\n    },\n    {\n      \"name\": \"Last Lexical Use\",\n      \"details\": \"Edge between uses of variable with the same name in different branches of a conditional\"\n    }\n  ],\n  \"vertex-features\": \"Vertex payload (instruction, token, node type) is encoded using Word2Vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"For every edge type, a separate adjacency matrix is created, where \\nback-edges are added for every edge (i.e. the adjacency matrix is symmetric).\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"CDFG (Control-Data Flow Graph)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"IR instructions and types\",\n      \"details\": \"Variable names are replaced with their type\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Sequential IR flow\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data flow\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control flow\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Vertex payload (instruction, token, node type) is encoded using Word2Vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"For every edge type, a separate adjacency matrix is created, where \\nback-edges are added for every edge (i.e. the adjacency matrix is symmetric).\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"Combination of AST, PDF, and CFG\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Nodes\",\n      \"details\": \"Some degree of abstraction is applied to the node labels. \\nSpecifically, concrete identifiers are replaced by abstract ones.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"Edge from statement to every possible next statement\"\n    },\n    {\n      \"name\": \"Data Dependence Edge\",\n      \"details\": \"Assignment points to all variables usages\"\n    },\n    {\n      \"name\": \"Control Dependence Edge\",\n      \"details\": \"Edge from one statement which is affected by another (e.g. increment in loop body)\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"A graph is represented using a bag of subgraphs feature.\\n\\nRoughly, every subgraph of size i is assigned a label. \\nThe feature vector is generated using some control parameter h;\\nthe final feature vector consists of a \\\"vector\\\" of all sets of subgraphs \\nof size 1, 2, ..., h.\\n\\n(Note: slightly inaccurate for simplicity))\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"Based on bag of graphs (Silva et al.)\\n\\nFirst, authors define Nodes of Interest (NOIs).\\nThese NOIs are used to capture three types of GOIs:\\n\\n1) NOI w/ source code text \\n2) Trees with the NOI as their root\\n3) Shortest path from AST root to the NOI\\n\\nFor each GOI, concatenate all node payloads (text) and hash them. \\n\\nNext, for each NOI, generate a feature vector of all GOI corresponding\\nto the NOI by concatenating the hashes. \\n\\nSince number of NOI is variable, sample a fixed number through \\nrandom sampling with replacement. \\n\\nCluster vectors using K-means.\\n\\nGenerate graph features by creating a histogram of how many \\nNOI of each type (cluster) are present in the graph.\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"modified control flow graph\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Token\",\n      \"details\": \"CFG is created based on statements, then every statement is split into tokens\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow\",\n      \"details\": \"CFG is created based on statements, then every statement is split into tokens\"\n    },\n    {\n      \"name\": \"Next Token (statement)\",\n      \"details\": \"Connect consecutive tokens in a statement\"\n    }\n  ],\n  \"vertex-features\": \"token\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"modified control flow graph, where multiple control flow graphs of calling/callee functions are combined\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow\",\n      \"details\": \"CFG is created based on statements\"\n    }\n  ],\n  \"vertex-features\": \"tokens (in the statement)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Source code comments\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Not specified (unclear how node embeddings are initialised)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Type Dependency Graph\",\n  \"description\": \"Hypergraph representing relationships between types.\\n\\nIn this hypergraph, each edge may connect an arbitrary number of vertices.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Type\",\n      \"details\": \"Some types are intermediary/placeholder types, e.g. introduced for untyped var declarations.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Bool(a)\",\n      \"details\": \"True if a is used as a Boolean\"\n    },\n    {\n      \"name\": \"Subtype(a, b)\",\n      \"details\": \"a is a subtype of b\"\n    },\n    {\n      \"name\": \"Assign(a, b)\",\n      \"details\": \"b is assigned to a\"\n    },\n    {\n      \"name\": \"Function(a, b_1, b_2, ..., b_k, b*)\",\n      \"details\": \"a is a function taking b_1, b_2, ..., b_k as arguments, and returning b*\"\n    },\n    {\n      \"name\": \"Call(a, b*, b_1, b_2,, ..., b_k)\",\n      \"details\": \"The result of calling function of type b* with arguments b_1, b_2, ..., b_k is assigned to a\"\n    },\n    {\n      \"name\": \"Object_{l_1, \\\\hdots, l_k}(a, b_1, ..., b_k)\",\n      \"details\": \"a is an object {l_1 -> b_1,  \\\\hdots, l_k -> b_k}\"\n    },\n    {\n      \"name\": \"Access_l(a, b)\",\n      \"details\": \"a = b.l\"\n    },\n    {\n      \"name\": \"Name_l(a)\",\n      \"details\": \"a has name l\"\n    },\n    {\n      \"name\": \"NameSimilar(a, b)\",\n      \"details\": \"a and b have similar names\\n\\nThe names of a and b are considered similar if their sets of tokens have nonempty intersection.\\nTokenization occurs by splitting on underscores, camelcase, and numbers, and then converting\\nto lowercase.\"\n    },\n    {\n      \"name\": \"Usage_l((a*, b*), (a_1, b_1), ..., (a_k, b_k))\",\n      \"details\": \"Usages involving name l\"\n    }\n  ],\n  \"vertex-features\": \"Nodes corresponding to constants (with known type) are set to a vector which is never updated further.\\n\\nOther nodes are all initialised with the same generic vector.\",\n  \"edge-features\": \"Edge features are based on identifier names (i.e. l_k).\\nEach name is tokenized (as explained above). \\nEach token occurring > 1 times is kept as-is.\\nOther tokens are mapped randomly to one of the <Unknown-i> tokens,\\nwhere 0 <= i <= 50\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Dataflow Enriched AST (AST+DF)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Nodes of types ImplicitCastExpr and DeclRefExpr are merged\\nwith their AST edge successor to reduce graph diameter.\\n\\nNodes are two-tuples (type, property), where\\nthe property is \\n1) data type (Function, FunctionArg, DeclStmt)\\n2) operator (Operator)\\n3) function name (CallExpr)\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"Edge from every usage of a variable to its definition\"\n    }\n  ],\n  \"vertex-features\": \"n/a (used embedding layer)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"CDFG + CALL + MEM\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"LLVM IR Instructions\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"MEM Edge\",\n      \"details\": \"Store/load dependencies\"\n    },\n    {\n      \"name\": \"CALL Edge\",\n      \"details\": \"Dependencies to return values of functions\"\n    }\n  ],\n  \"vertex-features\": \"n/a (used embedding layer)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"API Enhanced AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"A new AST node _type_ is added for every API called;\\ni.e. every function call node gains a new child node whose\\ntype is equal to the API name\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Node type is encoded using Word2Vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Traverse AST in BFS order.\\nFor every node, output the pair (parent payload, node payload).\\n\\nThe resulting text is then tokenized (four different ways; see paper for details).\\n\\nFor BOW models, the tokens are used to compute a BOW representation \\n(4 different ways; see paper for details).\"\n}",
    "{\n  \"name\": \"User-file interaction graph\",\n  \"description\": \"Models interactions between users and files in open source systems.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Contributor Data\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Source Code File\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"User\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Contributed to\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Vertex features are initialised with user embeddings for users,\\nand the structure-enhanced file representations for source files.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"The source code of files is partitioned into N_C code segments,\\nwhich are encoded using CodeBERT.\\n\\nA number N_Q of historical users are sampled and encoded.\\n\\nFor every file, the code segments (C) and users (U) are used \\nto compute (and learn) attention weights h, which are used \\nto compute the _file attention representation_ h = a^T C\"\n}",
    "{\n  \"name\": \"User-project interaction graph\",\n  \"description\": \"Models interactions between users and projects in open source systems.\\n\\nNote that multiple such graphs may exists based on multiple \\ninteraction types (\\\"behaviours\\\").\",\n  \"artefacts\": [\n    {\n      \"name\": \"Repository\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Contributor Data\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Repository\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"User\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Contributed to\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Vertex features are initialised with user embeddings for users,\\nand the structure-enhanced repository representations for projects.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"Graph representation of repositories\",\n  \"artefacts\": [\n    {\n      \"name\": \"Repository\",\n      \"details\": \"Source files, directories, repository information\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Source File\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Directory\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Repository\",\n      \"details\": \"Used as \\\"root\\\" node\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"n/a (Parent)\",\n      \"details\": \"Each node (e.g. file) is connected to its parent. \\nTop-level nodes are connected to the repository nodes.\"\n    }\n  ],\n  \"vertex-features\": \"Files use the file attention representation based on the \\nuser-file interaction graph.\\n\\nFor directories, their names are split up into words,\\nwhich are encoded using TF-IDF.\\n\\nRepository features are obtained by combining\\nproject owners, creation timestamps, and top 5 \\nprogramming languages.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"Network connecting developers, issues, source files, and tags assigned to issues.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Issues\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"User Data\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"Files\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Developer\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Issue\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Source File\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Issue Tag\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Labelled\",\n      \"details\": \"Connects issues with their labels\"\n    },\n    {\n      \"name\": \"Review\",\n      \"details\": \"Linked Developers with Issues they were involved in\"\n    },\n    {\n      \"name\": \"Commit\",\n      \"details\": \"Link developers to source files they committed\"\n    },\n    {\n      \"name\": \"Similar\",\n      \"details\": \"Link issues to possibly related source files, based on cosine similarity (len(issue & code) / len(code))\"\n    }\n  ],\n  \"vertex-features\": \"Nodes are embedded of numerical vectors with equal dimensions for all node types.\\n\\nFor issues, they are encoded using Word2Vec, by taking the average of all words in the issue description.\\n\\nDevelopers are encoded by taking the average of the embeddings of all the issues created by the developer.\\n\\nEmbeddings for other nodes are not discussed.\",\n  \"edge-features\": \"Various meta paths are used\",\n  \"connectivity-features\": \"Adjacency matrix\",\n  \"graph-features\": \"Link and node masking are applied.\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"for GGNN model:\\n  Three separate mechanics:\\n  1) Ordinal encoding of node type\\n  2) Ordinal encoding of node type + Ordinal encoding of the tokens in the node \\n  3) Ordinal encoding of node type + average word2vec encoding of tokens in the node\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"For the LSTM model:\\n  1) tokenisation,\\n      abstraction of literaturs,\\n      removal of uncommon identifiers, \\n      splitting snake and camel case into separate words\\n  2) Converting into a stream of tokens\"\n}",
    "{\n  \"name\": \"PDG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"PDG Node\",\n      \"details\": \"Forward and backward slicing is performed to only keep relevant nodes\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"for GGNN model:\\n  Three separate mechanics:\\n  1) Ordinal encoding of node type\\n  2) Ordinal encoding of node type + encoded variant of some additional info (e.g. functions mentioned by node)\\n  3) Ordinal encoding of node type + average word2vec encoding of tokens in the node\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"For the LSTM model:\\n  1) tokenisation,\\n      abstraction of literaturs,\\n      removal of uncommon identifiers, \\n      splitting snake and camel case into separate words\\n      remove certain uninformative node types\\n  2) Converting into a stream of tokens\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"AST\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code (method)\",\n      \"details\": \"adjustable\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"One-hot encoding of node type\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Edge Index List (Adjacency List)\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Dependency Graph\",\n  \"description\": null,\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"project\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Module\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Dependency\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"For every pair of nodes, compute the following features:\\n  1) topological features (common neighbours, Salton, Sorensen, Adamic-Adar, Katz, SimRank, Russel-Rao, Resource Allocation)\\n  2) content-based features:\\n      i) For every class in a module, compute the BoW representation of\\n          field attributes, method names, names of invoked methods, parameter names, comments, and JavaDoc documentation\\n      ii) Recursively take the union of class-based BoW representations to obtain the module-level BoW representation\\n      iii) Compute similarity between the two module-level BoW representations using cosine similarity\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"method\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Node content is encoded using Word2Vec\\n\\nNote that all nodes, even e.g. BlockStm, are considered \\nto contain a text payload (e.g. \\\"{}\\\")\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"For every graph, the minimum set of long paths covering \\nall nodes in the AST is computed.\\nHere, a long path is a path from one leaf node to another,\\nvia the root, possibly sharing one or multiple nodes along \\nthe path.\\n\\nDuring the generation of training data,\\nIf a long path contains a node which was present in a \\nbug/vulnerability fix, all embeddings in the path\\nare multiplied by a weight w.\\n\\nFor the GRU model, the nodes in a long path are seen \\nas a sequence of token.\\n\\nFor the CNN model, the nodes in a long path are combined \\ninto a matrix.\\n\\nJoint model, with two parallel paths:\\n  1) Attention-based GRU layer\\n  2) Attention-based CNN layer followed by FNN\\nBoth paths are combined w/ a multi-head attention layer. \\n\\nThis method is used to encode every path into a (local) vector.\\n\\nFor every long path, the nodes in the PDG and DFG (partially) \\ncovered by the long path are extracted, and formed into two matrices.\\nThese matrices (global) are multiplied with the local vector and \\nthen concatenated in order to obtain a vector \\nwith both local and global information for each path.\\n\\nThe vectors for each path are then concatenated in order to obtain a\\nmatrix representing the entire method, with additional global information.\"\n}",
    "{\n  \"name\": \"Program Dependence Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Multiple methods\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"PDG Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Vertices encoded using node2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Data Flow Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Multiple methods\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Vertices encoded using node2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"methods\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Continuous Binary Tree\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"Obtained by taking the continuous binary tree \\nrepresentation of the AST (root), and passing\\nit to a VAE.\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Inter-procedural Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Dependence Edge\",\n      \"details\": \"From PDG\"\n    },\n    {\n      \"name\": \"Data Dependence Edge\",\n      \"details\": \"From PDG\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Function Call Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Nodes represent statements, which consists of tokens.\\nNodes are embedding by summing the embeddings of the tokens, \\nwhere tokens are embedded using a learnable embedding.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"Sample subgraphs using vulnerability-specific program slicing;\\nIdentify start and end of possible vulnerability, and select \\nthe graph of all paths between the two.\\n\\nExtract six subgraphs for: \\n  1) buffer overflow\\n  2) memory leak\\n  3) null pointer dereference\\n  4) integer overflow\\n  5) use after free \\n  6) double free\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Function Call Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Function\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Call Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Function Name, encoded using Word2Vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Vulnerability Property Graph\",\n  \"description\": \"Code property graph enhanced for vulnerability detection\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Token Edge\",\n      \"details\": \"Edge from one token (leaf node) to the next\"\n    }\n  ],\n  \"vertex-features\": \"Features based on AST payload; identifiers, keywords, names, types etc. (yes, the paper says etcetera).\\n\\nEncoded using Word2Vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Code Property Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Some AST nodes, specifically those without \\nchild nodes and only contain AST edges,\\nare pruned.\\n\\nContent of AST nodes is simplified. \\nIn particular, user defined names are \\nreplaced with standardised placeholders.\\nExamples: F<i> for functions, V<i> for variables.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Payload of node encoded using Word2Vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Code Property Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Node type one-hot encoded\\nStatement fragments/tokens encoded using word2vec \\none-hot and word2vec embeddings are concatenated\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Code Property Graph\",\n  \"description\": \"AST augmented with control and data flow information.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code (arbitrary snippets)\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"Points from one statement node to every other statement node which can immediately follow it.\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"Declaration node points to all statement nodes using the declared variable.\"\n    }\n  ],\n  \"vertex-features\": \"1) Collect node types and tokens (snippets from leaf nodes) by traversing the network\\n2) Train Word2Vec on the corpus of node types and tokens, and project all to d-dimensional space\\n3) Concatenate the embeddings for the node type and lexical tokens. For nodes without lexical tokens, use the zero vector.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Control Flow Chart\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Local block\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Line\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix (?)\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"The code block (not the nodes; the entire block)\\nis tokenized using the pretrained BPE tokenizer from CodeBERT.\\nThese tokens are passed to the pre-embedding\\npart of the network.\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"User-defined names are normalised (e.g. METHOD1, VAR3)\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"directed\"\n    }\n  ],\n  \"vertex-features\": \"Node type is encoded on an ordinal scale,\\nwhere a type has a higher number if it occurs \\nmore frequently.\\nRarely occurring type are assigned the number 0.\\n\\nLexical content of nodes is encoded by taking \\nthe average of the word2vec values of the tokens in the node.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Stacked adjacency tensor.\\n\\nFor every graph, the adjacency matrix is determined.\\nThe four matrices are then combined into a third order tensor.\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Control Flow Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"User-defined names are normalised (e.g. METHOD1, VAR3)\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"Edge from statement to every statement that may be executed directly after it.\"\n    }\n  ],\n  \"vertex-features\": \"Node type is encoded on an ordinal scale,\\nwhere a type has a higher number if it occurs \\nmore frequently.\\nRarely occurring type are assigned the number 0.\\n\\nLexical content of nodes is encoded by taking \\nthe average of the word2vec values of the tokens in the node.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Stacked adjacency tensor.\\n\\nFor every graph, the adjacency matrix is determined.\\nThe four matrices are then combined into a third order tensor.\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Data Flow Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"User-defined names are normalised (e.g. METHOD1, VAR3)\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"Edge from assignment to every use of that variable. \\n\\nNote; due to the use of if-statements, some uses may have \\nmultiple _incoming_ edges\"\n    }\n  ],\n  \"vertex-features\": \"Node type is encoded on an ordinal scale,\\nwhere a type has a higher number if it occurs \\nmore frequently.\\nRarely occurring type are assigned the number 0.\\n\\nLexical content of nodes is encoded by taking \\nthe average of the word2vec values of the tokens in the node.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Stacked adjacency tensor.\\n\\nFor every graph, the adjacency matrix is determined.\\nThe four matrices are then combined into a third order tensor.\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Natural Code Sequence\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"User-defined names are normalised (e.g. METHOD1, VAR3)\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Code Sequence Edge\",\n      \"details\": \"Edge from one AST leaf node to the next\"\n    }\n  ],\n  \"vertex-features\": \"Node type is encoded on an ordinal scale,\\nwhere a type has a higher number if it occurs \\nmore frequently.\\nRarely occurring type are assigned the number 0.\\n\\nLexical content of nodes is encoded by taking \\nthe average of the word2vec values of the tokens in the node.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Stacked adjacency tensor.\\n\\nFor every graph, the adjacency matrix is determined.\\nThe four matrices are then combined into a third order tensor.\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"Bipartite graph relating users and repositories (temporal graph)\",\n  \"artefacts\": [\n    {\n      \"name\": \"Users\",\n      \"details\": \"from github\"\n    },\n    {\n      \"name\": \"Repositories\",\n      \"details\": \"from github\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"User\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Repository\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Vulnerability\",\n      \"details\": \"Denotes the introduction of a vulnerability in a repository by a user\\n\\nEvery interaction is annotated with a time (normalised to [0, 1]) at \\nwhich the interaction occurred.\"\n    }\n  ],\n  \"vertex-features\": \"Note: all features are time dependent! i.e. they change over time \\n\\nFor users;\\n  - Number of repositories owned\\n  - Number of repositories starred\\n  - Number of comments made by a user\\n  - Number of public repositories starred by a user\\n  - Number of vulnerabilities introduced _before this interaction_\\n  - Cumulative severity score of introduced vulnerabilities \\n\\nFor repositories;\\n  - Primary language used in the repository\\n  - Boolean indicating whether the repository has been forked \\n  - Number of open issues \\n  - Number of stars \\n  - Number of people watching \\n  - Number of forks \\n  - Number of pull requests \\n  - Size of the repository \\n  - Cumulative amount of vulnerability introduced _before this interaction_\\n  - Cumulative severity score of introduced vulnerabilities\",\n  \"edge-features\": \"Severity score, time t\",\n  \"connectivity-features\": \"Adjacency matrix (time dependent)\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Program Dependency Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement or Control Predicate\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Node features are trained using a modified node2vec,\\nwhich learns embeddings for the individual tokens in \\neach node.\\n\\nLater, these embeddings per node are combined to come \\nup with node embeddings.\",\n  \"edge-features\": \"Separate from the vertex features, another set of \\nnode features (not based on node payload) is \\ncomputed using node2vec.\\n\\nEdge features are computed by subtracting the \\nstart node embedding from the end node embedding,\\nfor every edge.\",\n  \"connectivity-features\": \"Not Specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"LFAST (Loop-Flow Abstract Syntax Tree)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Only a small selection of AST nodes from the original AST \\nis kept; only the \\\"loop oriented\\\" ones, which are either\\npart of a loop or within a k-hop neighbourhood of a node \\nwhich is part of a loop.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Node features are based on three basic features:\\n  1) Node payload (1 token) encoded using word2vec\\n  2) Node type is encoded using Label Encoding\\n  3) positional encoding: position of i-th token in code is encoded as a vector\\n    [sin(w_0 * i), cos(w_0 * i), sin(w_1 * i), cos(w_1 * i), ...]\\n\\n  Final node feature vector is given by CONCAT(type, payload + position)\",\n  \"edge-features\": \"Edge type: syntax, control, or data. Encoded using Label Encoding\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Control Flow Chart\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Local block\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Line\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"The code block (not the nodes; the entire block)\\nis tokenized using the pretrained BPE tokenizer from CodeBERT.\\nThese tokens are passed to the pre-embedding\\npart of the network.\"\n}",
    "{\n  \"name\": \"\\\\alpha AST (Annotated AST)\",\n  \"description\": \"AST representing a commit, i.e. a change from old to new code.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code (commit)\",\n      \"details\": null\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Nodes from both the AST of the old and the new code are present.\\n\\nNodes are annotated with \\\"unchanged\\\", \\\"added\\\", or \\\"deleted\\\"\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"Edges are annotated with \\\"unchanged\\\", \\\"added\\\", or \\\"deleted\\\"\"\n    }\n  ],\n  \"vertex-features\": \"Node content embedded using word2vec.\\nChange action (unchanged/added/deleted) is one hot encoded \\n\\ncontent and action embeddings are concatenated.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"directed\"\n    }\n  ],\n  \"vertex-features\": \"Node type and Node payload tokens are encoded using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Stacked adjacency tensor.\\n\\nFor every graph, the adjacency matrix is determined.\\nThe four matrices are then combined into a third order tensor.\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Control Flow Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"Edges representing control flow between basic blocks\"\n    }\n  ],\n  \"vertex-features\": \"Node type and Node payload tokens are encoded using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Stacked adjacency tensor.\\n\\nFor every graph, the adjacency matrix is determined.\\nThe four matrices are then combined into a third order tensor.\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Data Flow Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"Edges represent subsequent modification or access of the same variables\"\n    }\n  ],\n  \"vertex-features\": \"Node type and Node payload tokens are encoded using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Stacked adjacency tensor.\\n\\nFor every graph, the adjacency matrix is determined.\\nThe four matrices are then combined into a third order tensor.\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Natural Code Sequence\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Code Sequence Edge\",\n      \"details\": \"Edge from one AST leaf node to the next\"\n    }\n  ],\n  \"vertex-features\": \"Node type and Node payload tokens are encoded using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Stacked adjacency tensor.\\n\\nFor every graph, the adjacency matrix is determined.\\nThe four matrices are then combined into a third order tensor.\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Unified Code Property Graph (UCPG)\",\n  \"description\": \"Combination of code property graph, control flow, and NCS\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Function Call Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"NCS Edge\",\n      \"details\": \"Natural code sequence edge\"\n    }\n  ],\n  \"vertex-features\": \"Node content encoded using doc2vec\",\n  \"edge-features\": \"Unidirectional edges are converted to bidirectional edges/backedges are added.\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Code Property Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Node type is encoded as a scalar \\nTokens in a node are embedded using word2vec; vectors per token are averaged \\nnode type and payload embedding are concatenated\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix (?)\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Code Property Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Node type is encoded as a scalar \\nTokens in a node are embedded using word2vec; vectors per token are averaged \\nnode type and payload embedding are concatenated\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix (?)\",\n  \"graph-features\": \"Graph is rendered as an image.\\nEach node has sa different colour,\\nand has the line number of its corresponding statement as its content. \\nDifferent edge types have different colours and line types.\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"PDG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Line\",\n      \"details\": \"Comments are omitted \\nnormalise names (VAR0, FUN1)\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Lines of code encoded using sent2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "Arbitrary Graphs (?)",
    "{\n  \"name\": \"PatchCPG\",\n  \"description\": \"A variant of the code property graph for representing patches\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Constructed based on commits, but also uses full source code.\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"AST Nodes are obtained by taking files which were modified in the commit,\\nand excluding all unchanged functions (as a means to include global variables\\nin the resulting graphs).\\n\\nThe amount of nodes is further reduced through program slicing,\\nthough this is only done following data- and control edges.\\n\\nNodes are marked as \\\"added\\\", \\\"deleted\\\", or \\\"context\\\"\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"Edges are marked as \\\"added\\\", \\\"deleted\\\", or \\\"context\\\"\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"Edges are marked as \\\"added\\\", \\\"deleted\\\", or \\\"context\\\"\"\n    },\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"Edges are marked as \\\"added\\\", \\\"deleted\\\", or \\\"context\\\"\"\n    }\n  ],\n  \"vertex-features\": \"1) Number of characters in the node payload \\n2) version (added/deleted/context)\\n3) number of function calls \\n4) number of variables \\n5) number of number (constants)\\n6) number of strings\\n7) number of pointers \\n8) number of arrays\\n9) number of NULL identifiers \\n10) Boolean indicating if the node if a conditional\\n11) Boolean indicating if the node if a loop\\n12) Boolean indicating if the node if a jump statement \\n13) Number of arithmetic operators\\n14) Number of relational (comparison) operators\\n15) Number of logical operators\\n16) Number of bitwise operators\\n17) Boolean indicating if the node contains the API name of memory operations\\n18) Boolean indicating if the node contains the API name of string operations\\n19) Boolean indicating if the node contains the API name of lock operations\\n20) Boolean indicating if the node contains the API name of system operations\",\n  \"edge-features\": \"Edge type is one-hot encoded \\nversion info encoded according to \\\"added\\\" -> [0, 1], \\\"deleted\\\" -> [1, 0], \\\"context\\\" -> [1, 1]\\nThe two vectors are concatenated\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Co-occurrence Graph\",\n  \"description\": null,\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Source code is first sliced based data (parameters)\\npassed to \\\"dangerous\\\" functions.\\nNames are standardised.\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Token in snippet\",\n      \"details\": \"Every unique token gets a single node\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Edge\",\n      \"details\": \"Every token is connected to every other token that \\noccurs within 2 tokens of itself in the \\noriginal source code.\"\n    }\n  ],\n  \"vertex-features\": \"Tokens are embedded using a word embedding (not further specified)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Pointwise mutual information between different tokens is computed\\nto compute up with a weighted adjacency matrix.\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Tokens are embedded using a word embedding (not further specified),\\nin sequence as input for the GRU model\"\n}",
    "{\n  \"name\": \"SeqGraph\",\n  \"description\": \"Graph containing syntactic and control flow information\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST node with code abstraction\",\n      \"details\": \"AST nodes, but e.g. literals are replaces with a LITERAL marker.\\nThe nodes corresponding to the buggy line (directly connected by NextToken edges),\\nare enclosed by START_BUG and END_BUG markers.\"\n    }\n  ],\n  \"vertex-features\": \"Word2Vec is used to encode the tokens.\\nThen, those tokens are further encoded using a BiLSTM encoder.\",\n  \"edge-type\": [\n    {\n      \"name\": \"NextToken\",\n      \"details\": \"Connects two tokens that are next to each other in the document.\"\n    }\n  ],\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": null,\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Flow-augmented graph\",\n  \"description\": \"Graph containing syntactic and control flow information\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST node with code abstraction\",\n      \"details\": \"AST nodes, but e.g. literals are replaces with a LITERAL marker.\\nThe nodes corresponding to the buggy line (directly connected by NextToken edges),\\nare enclosed by START_BUG and END_BUG markers.\"\n    }\n  ],\n  \"vertex-features\": \"Word2Vec is used to encode the tokens.\\nThen, those tokens are further encoded using a BiLSTM encoder.\",\n  \"edge-type\": [\n    {\n      \"name\": true,\n      \"details\": \"Denotes that one jumps from one node to another if the condition of which the \\nfirst node is a part, is true.\"\n    },\n    {\n      \"name\": false,\n      \"details\": \"Denotes that one jumps from one node to another if the condition of which the \\nfirst node is a part, is false.\"\n    },\n    {\n      \"name\": \"UseBy\",\n      \"details\": \"Connects last assignment of a variable to all its subsequent uses\"\n    },\n    {\n      \"name\": \"DefineIn\",\n      \"details\": \"Connects the declaration of a variable to places where it is assigned to.\"\n    },\n    {\n      \"name\": \"NextToken\",\n      \"details\": \"Connects two tokens that are next to each other in the document.\"\n    },\n    {\n      \"name\": \"CallBy\",\n      \"details\": \"Connects a caller to the function it is calling\"\n    }\n  ],\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": null,\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Code Property Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"tag; node type/role -- one hot encoded op; encoding for some program operations (e.g. conditional, jump) -- one hot encoded func; reflects relationship with specific functions -- one hot encoded lite; describes involved parameters -- one hot encoded type; type parameter in C/C++ (16 fixed options) -- one hot encoded\\nNode tokens encoded using Word2vec\\nall features are concatenated\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix (?)\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"Program Dependency Graph with additional heterogeneous information\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"methods\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Method Node\",\n      \"details\": \"Represents the method. Only one such node exists in the graph\"\n    },\n    {\n      \"name\": \"Statement Node\",\n      \"details\": \"b/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"Connects successive statements\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"Connects statements where the execution of one is controlled by the other\"\n    },\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"Connects statements with variables to the statement where the variable is defined\"\n    },\n    {\n      \"name\": \"Include Edge\",\n      \"details\": \"Edge from Method Node to Statement Node\"\n    }\n  ],\n  \"vertex-features\": \"Method Node Features; 1) LOC -- Amount of statements in the method 2) CC -- McCabe's Cyclomatic Complexity of the method 3) PC -- Parameter count of the method 4) LCOM1 to LCOM4 -- Four type of cohesion metrics propoposed by Charalampidou\\nStatement Node Features; 1) ABCL --  Metric proposed by Fitzpatrick, representing the type of statement (assignment, branch, condition, loop) 2) FUC -- Amount of fields used in a statement 3) LMUC -- Total amount of local (same class) methods used in the statement 4) PUC -- Number of parameters used in the statement 5) NBD -- Nesting depth of the statement 6) VUC -- Amount of variables used in a statement 7) WC -- Word count of the statement\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"Code Property Graph with an additional edge type\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"dangerous function calls are identified and program slicing is performed based on their parameters.\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"CAD (Control And Data) Edge\",\n      \"details\": \"When in the PDG, there would be both control and data dependency edges between two nodes.\"\n    }\n  ],\n  \"vertex-features\": \"Node content is encoded using word2vec\",\n  \"edge-features\": \"Edge type is encoded using an ordinal encoding\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Static taint analysis (path of input data) of source code;\\nstatements encountered are put in sequence and embedded using word2vec.\"\n}",
    "{\n  \"name\": \"Compact Abstract Graph\",\n  \"description\": null,\n  \"artefacts\": [\n    {\n      \"name\": \"Source code method\",\n      \"details\": null\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node (Normal)\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"AST Node (Merged)\",\n      \"details\": \"Any \\\"linear\\\" sequence of nodes which form a direct chain\\nwithout other incoming edges, are merged into one.\\nThe root node cannot be part of a chain,\\nand leaf nodes cannot be part of a chain.\"\n    },\n    {\n      \"name\": \"AST Node (Aggregated)\",\n      \"details\": \"Any node aggregating _only_ a set of linear chains (length >= 1),\\nis turned into a single node combining all chains.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Next Token Edge\",\n      \"details\": \"Each token points to the next token\"\n    },\n    {\n      \"name\": \"Inverted AST Edge\",\n      \"details\": \"Inverted so all AST edges point \\\"upward\\\" towards the root node\"\n    },\n    {\n      \"name\": \"Root Edge\",\n      \"details\": \"Each leaf node has an edge pointing to the root node\"\n    }\n  ],\n  \"vertex-features\": \"Node content encoded using MPNet. Specifically;\\nNormal nodes; embedded as is \\nMerged nodes; average of all contained nodes \\nAggregated Nodes; \\\\frac{1}{k}\\\\sum_{i=1}^k\\\\left(\\\\frac{1}{n_i}\\\\sum_{j = 1}^{n_1} MPNet(T_{ij})\\\\right)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency List (directed)\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"Mix of AST and CFG\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Javascript\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Ast Edge\",\n      \"details\": \"Directed\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Node content is split up into \\\"words\\\", and embedded using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Taint analysis is applied to the program. \\nResulting sub-program text is split up into \\\"words\\\" and embedded using word2vec,\\nand put into a sequence of vectors\"\n}",
    "{\n  \"name\": \"PDG\",\n  \"description\": \"Check \\\"other-features\\\" for details;\\nThe paper does not really use graphs, but things derived \\nfrom full graphs.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": null\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Dependence Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependence Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"So-called value-flow paths are extracted from the PDG.\\n\\nA guarded value-flow path consists of a sequence of program\\nstatements representing a def-use chain between variables, with the\\nguard on each edge between two statements to indicate control-flow\\ntransfer conditions.\\n\\nPaths are put into a network which maps them to vectors.\\nA path is fed twice into the network, with different dropout masks.\\nA contrastive loss is used.\\n\\nThe network first encoded the statements based on AST subtrees.\\nEach node in the AST subtree corresponding to the statement\\nis initialised using Code2Vec.\\n\\nNext, each nodes embedding is updated according to its\\nown embedding and those of its children, using an\\nattention-weighted sum.\\nThe attention weights for node $i$ and its children $C_i$ are computed according to \\n\\n  a_{ij} = \\\\frac{\\\\exp(\\\\sigma(e_{ij}))}{\\\\sum_{k \\\\in C_i \\\\cup i} \\\\exp(\\\\sigma(e_{ik}))}\\n  e_{ij} = a^T_s[W^a v_{n_i} \\\\mid\\\\mid W^a v_{n_j}] \\\\cdot \\\\sigma((W^av_{n_1})^T(W^a v_{n_j}))\\n  Where a_s and W are a learnable matrix and learnable vector.\\n\\nFinally, all nodes are aggregated according to:\\n\\nv_{sm} = \\\\frac{1}{N}\\\\sum_{i = 1}^N v'_{n_i} \\\\mid\\\\mid \\\\max_{j = 1}^N v'_{n_j}\\n\\nNext, all statement embeddings are passed through a bidirectional GRU layer.\\n\\nThe hidden states of the GRU layer are summed using an attention-weighted sum.\\n\\nThe trained model is used to encode value-flow paths for later use.\\n\\nDeep learning model is used to select top-k paths. \\nInfeasible value flow paths (cannot occur based on if guards) are filtered out.\"\n}",
    "{\n  \"name\": \"SDG (Sub-dependence Graph)\",\n  \"description\": \"Program Dependence Graph with slicing applied;\\nonly those nodes _from which_ a dangerous function\\ncall is reachable, are kept.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"Names in the code are normalised\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Flow Dependency Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Statements are encoded using doc2vec (PV-DM)\",\n  \"edge-features\": null,\n  \"connectivity-features\": null,\n  \"graph-features\": null,\n  \"other-features\": null\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"A network with a learnable embedding layer and 5 FNN layers is used\\nto learn node embeddings. \\nGiven the parent node type and the top-4 immediate child node types,\\npredict the node type itself.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"PDG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Dependence Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow  Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Self Loop\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Statements are encoded using CodeBERT\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"The entire function is encoded using CodeBERT\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"Network of statements, where every statement has its AST subtree attached\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement Node\",\n      \"details\": \"All type names are fully expanded. Variable names are replaced with their fully expanded type.\"\n    },\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"Between statements\"\n    },\n    {\n      \"name\": \"PDG Edge\",\n      \"details\": \"Between statements\"\n    }\n  ],\n  \"vertex-features\": \"Node content is encoded using doc2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"PDG\",\n  \"description\": \"Using slicing, every PDG is split into multiple slice subgraphs\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"Comments removed, user defined names are normalised.\\nProgram slicing based on sensitive APIs, arrays,\\nintegers, and pointers is performed.\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Dependence Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependence Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Statement embedded using sent2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Using slicing, every PDG is split into multiple slice subgraphs\",\n  \"graph-features\": \"Using slicing, every PDG is split into multiple slice subgraphs.\\n\\nThe subgraph-model is used to filter subgraphs; \\nthe 25% of subgraphs with the lowest predicted probabilities \\nof containing a vulnerability are dropped.\\n\\nThe remaining subgraphs are passed to the \\\"full\\\" model.\",\n  \"other-features\": \"Using slicing, every PDG is split into multiple slice subgraphs\"\n}",
    "{\n  \"name\": \"Data Dependency Graph\",\n  \"description\": \"A cross method data dependency graph.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Methods\\n\\nSpecifically, for every method (core method),\\nwhich is either vulnerable or not vulnerable,\\na set of method _called by that method_\\n(directly or indirectly) are also\\ncollected in order to come up with the graph.\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Unclear\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"Data dependency edge as in PDG.\\n\\nThe graph is cross method, meaning calling relationships \\nare used to determine cross-method data dependencies.\"\n    }\n  ],\n  \"vertex-features\": \"Source code is normalised, and encoded using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code (path/commit)\",\n      \"details\": \"Patch is split up into pre- and post- change function. An AST is made for both.\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Paths from start to end nodes are constructed,\\nwhere the path must always pass through the root of \\nthe changed (added/deleted) subtree.\\n\\nTwo types of paths:\\n1) within change; start and end are both leaf nodes in the \\n    changed subtree\\n2) within context: start is a leaf node in the changed subtree,\\n    end is a leaf node in the unchanged remainder of the tree.\\n\\nBoth path types are randomly sampled in a 1:1 ratio.\"\n}",
    "{\n  \"name\": \"Dependency Parse Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Commit Message\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Token\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Dependency Edge\",\n      \"details\": \"Denotes the types of dependencies between tokens (words) (e.g. adjective modifies)\"\n    },\n    {\n      \"name\": \"Neigh Edge\",\n      \"details\": \"Connects the last token in a sentence to the first token in the next sentence\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Vulnerability Dependence Representation Graph (VDRG)\",\n  \"description\": \"Based on PDG\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Dependence Edge\",\n      \"details\": \"Regular Control Dependence Edge\"\n    },\n    {\n      \"name\": \"Vulnerability Control Dependence Edge\",\n      \"details\": \"Control Dependence Edge pointing to a statement \\nwhich was marked as syntactically being potentially vulnerable (SyVC).\\n\\nControl Dependence Edges are marked as Vulnerability Control Dependence Edges\\nif one of the following is true:\\n1) The edge points to a statement that is marked as syntactically potentially vulnerable.\\n2) The edge transitively points to a statement that is marked as syntactically potentially vulnerable.\"\n    },\n    {\n      \"name\": \"Data Dependence Edge\",\n      \"details\": \"Regular Data Dependence Edge\"\n    },\n    {\n      \"name\": \"Vulnerability Data Dependence Edge\",\n      \"details\": \"Data Dependence Edge pointing to a statement \\nwhich was marked as syntactically being potentially vulnerable (SyVC).\\n\\nData Dependence Edges are marked as Vulnerability Data Dependence Edges\\nif one of the following is true:\\n1) The edge points to a statement that is marked as syntactically potentially vulnerable.\\n2) The edge transitively points to a statement that is marked as syntactically potentially vulnerable.\"\n    }\n  ],\n  \"vertex-features\": \"Names are normalised.\\n\\nNode are encoded using word2vec.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"CFG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"PHP files\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Content of statement nodes is tokenized\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Original source code snippet is parsed into a sequence of tokens.\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"PDG enhanced with call information\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"Slicing (based on sys API calls and pointer variables) is performed to reduce the amount of nodes\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data flow (dependence) Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control flow (dependence) Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Call Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Return Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Statements in nodes encoded using doc2vec\",\n  \"edge-features\": \"Back-edges are added.\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Code Composite Graph (CCG)\",\n  \"description\": \"Mix of AST, CFG, and DFG\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Node token encoded using word2vec\\nNode type encoded using label encoding \\nBoth encodings are concatenated\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"CPG+\",\n  \"description\": \"Code property graph with NCS edges\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Natural Code Sequence Edge (NCS)\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Tokenize, normalize names, average word2vec vector of all tokens per node.\\nConcatenate that with node type encoded as integer.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Code Property Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Concatenate word2vec embeddings of tokens\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Nodes are sequenced in a way preserving \\ntoken order from original code;\\nCorresponding feature vectors now \\nform a sequence of feature vectors\"\n}",
    "{\n  \"name\": \"Unique Token Focussed Construction\",\n  \"description\": \"Each unique token has a node,\\nand two tokens are connected if they\\nco-occur in a sliding window of size v.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Token\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Co-occurrence Edge\",\n      \"details\": \"within a sliding window of size v\"\n    }\n  ],\n  \"vertex-features\": \"Tokens embedded using token embedding layer of CodeBERT\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified (adjacency matrix?)\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": null\n}",
    "{\n  \"name\": \"Unique Token Focussed Construction\",\n  \"description\": \"Each unique token has a node,\\nand two tokens are connected if they\\nco-occur in a sliding window of size v.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Token\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Co-occurrence Edge\",\n      \"details\": \"within a sliding window of size v\"\n    }\n  ],\n  \"vertex-features\": \"Tokens embedded using token embedding layer of GrapCodeBERT\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified (adjacency matrix?)\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": null\n}",
    "{\n  \"name\": \"Index-Focussed Construction\",\n  \"description\": \"All tokens are represented as a sequence,\\nand two nodes are connected if they occur within\\na sliding window of size v\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Token\",\n      \"details\": \"Not necessarily unique\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Co-occurrence Edge\",\n      \"details\": \"within a sliding window of size v\"\n    }\n  ],\n  \"vertex-features\": \"Tokens embedded using token embedding layer of CodeBERT\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified (adjacency matrix?)\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": null\n}",
    "{\n  \"name\": \"Index-Focussed Construction\",\n  \"description\": \"All tokens are represented as a sequence,\\nand two nodes are connected if they occur within\\na sliding window of size v\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Token\",\n      \"details\": \"Not necessarily unique\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Co-occurrence Edge\",\n      \"details\": \"within a sliding window of size v\"\n    }\n  ],\n  \"vertex-features\": \"Tokens embedded using token embedding layer of GrapCodeBERT\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified (adjacency matrix?)\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": null\n}",
    "{\n  \"name\": \"Abstract Semantic Graph\",\n  \"description\": \"Graph with Control and Data Flow Information\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Smart Contracts\"\n    }\n  ],\n  \"vertex-type\": \"statement\",\n  \"edge-type\": \"control flow/data flow\",\n  \"vertex-features\": \"not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"mix of AST, CFG, PDG\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"smart contract\"\n    }\n  ],\n  \"vertex-type\": \"AST Node (slicing applied)\",\n  \"edge-type\": \"ast/control flow/data dependence/control dependence\",\n  \"vertex-features\": \"tokens encoded using fasttext\",\n  \"edge-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"AST split into subtrees for statements (specific vulnerability related statement types)\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"powershell\"\n    }\n  ],\n  \"vertex-type\": \"AST node\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"word2vec of node content\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"javascript\"\n    }\n  ],\n  \"vertex-type\": \"ast node (trimmed)\",\n  \"edge-type\": \"ast edge\",\n  \"vertex-features\": \"node type one-hot\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified (presumably adjacency matrix)\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"CFG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"php\"\n    }\n  ],\n  \"vertex-type\": \"basic block\",\n  \"edge-type\": \"control flow\",\n  \"vertex-features\": \"vector of counts of occurrences of certain ast node types in the ast sub-tree of the basic block\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"ast + pdg (pruned)\",\n  \"description\": \"mix of ast and pdg (pruned)\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"javascript\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/control dependence/data dependence\",\n  \"vertex-features\": \"node type word2vec\",\n  \"edge-features\": \"edge type one-hot\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"CPG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/control flow/control dependence/data dependence\",\n  \"vertex-features\": \"node content doc2vec or tf/idf (two different approaches were experimented with)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"javascript\"\n    }\n  ],\n  \"vertex-type\": \"ast node\",\n  \"edge-type\": \"ast edge\",\n  \"vertex-features\": \"unclear (not specified)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast w/ subtokens\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"content CodeBERT\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"sdg (system dependence graph)\",\n  \"description\": \"derived from a set of pdgs\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"statement\",\n  \"edge-type\": \"control dependence (data dependence not used)\",\n  \"vertex-features\": \"for each statement, max-pool over embeddings of all nodes in corresponding ast subtree\",\n  \"edges\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"tokens (unique) w/ co-occurrence sliding window\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"unique code tokens\",\n  \"edge-type\": \"co-occurrence in sliding window\",\n  \"vertex-features\": \"token CodeBERT / GraphCodeBERT (two different methods proposed)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"ast with data flow\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/data flow/ncs\",\n  \"vertex-features\": \"not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"function -- python\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"node type one-hot\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"code structure graph (csg)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/data dependence/control dependence/control flow/ncs\",\n  \"vertex-features\": \"word2vec (unclear what)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"32 different meta-paths are used (expression, statement, symbol level)\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Change Impact Graph\",\n  \"description\": \"create full graphs (according to vertex/edge types) of old and new code; slice based on changed lines; two input graphs/commit\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"diff\"\n    }\n  ],\n  \"vertex-type\": \"variables/statements/method/classes/package (entities at different levels)\",\n  \"edge-type\": \"data dependence/control dependence/program relations (package member, overwrite, implement, inherit, initialize, data member, param in, param out, etc)\",\n  \"vertex-features\": \"node2vec + one hot node type\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"syntax change type (extracted using ChangeDistiller) is also given as input (encoding unclear)\"\n}",
    "{\n  \"name\": \"commit graph\",\n  \"description\": \"separate graphs are created for old and new code, which are then merged based on common nodes.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"commit\"\n    }\n  ],\n  \"vertex-type\": \"statements\",\n  \"edge-type\": \"control flow/data flow/name flow [data flow considering variable names]/sub-token co-occurrence\",\n  \"vertex-features\": \"node value BERT\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified, presumable adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"cfg\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"statement/basic block\",\n  \"edge-type\": \"control flow\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"class dependency network\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"project\"\n    }\n  ],\n  \"vertex-type\": \"classes\",\n  \"edge-type\": \"dependencies\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"class dependency network\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"project\"\n    }\n  ],\n  \"vertex-type\": \"classes\",\n  \"edge-type\": \"dependencies\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"\\\\delta-ndg\",\n  \"description\": \"start with two separate graphs, merge based on unchanged nodes\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"commit\"\n    }\n  ],\n  \"vertex-type\": \"statement\",\n  \"edge-type\": \"control dependence/data dependence/name flow\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"incomplete snippet (while live editing)\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Object Usage Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"action (API invocation; e.g java.lang.String.new) or control (eg. while)\",\n  \"edge-type\": \"(temporal) usage order/data dependency\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"fcg\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"function\",\n  \"edge-type\": \"function call\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Extended Component Dependency Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"project\"\n    }\n  ],\n  \"vertex-type\": \"component\",\n  \"edge-type\": \"logic dependency (composition, delegation etc)/co-evolution [all edges have back edges]\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"edges are weighted\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Weighted Directed Class Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"project\"\n    }\n  ],\n  \"vertex-type\": \"class\",\n  \"edge-type\": \"inheritance coupling/method coupling/data coupling\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"edges are weighted (e.g number of method called)\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"project\"\n    }\n  ],\n  \"vertex-type\": \"classes/interfaces\",\n  \"edge-type\": \"dependencies between classes/interfaces (implements, data access, etc.)\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"edges have weights (fine-tuned using simulated annealing)\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"ePDG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"source code is first compiled to LLVM IR\"\n    }\n  ],\n  \"vertex-type\": \"instruction (slicing performed based on vulnerability-correlated instruction types)\",\n  \"edge-type\": \"control flow/dependence and data flow/dependence\",\n  \"vertex-features\": \"operation type, basic function, is instruction part of if-clause (all one-hot)/classical graph metrics\",\n  \"edge-features\": \"edge type / data flow edges have the data type(s) of the dependency as attributes\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"CFG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"first compiled to bytecode\"\n    }\n  ],\n  \"vertex-type\": \"instruction\",\n  \"edge-type\": \"control flow (incl. function calls)\",\n  \"vertex-features\": \"things like instruction name and operands\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified / n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code (function/method)\",\n      \"details\": \"first compiled to LLVM IR\"\n    }\n  ],\n  \"vertex-type\": \"identifiers in the instructions (some trimmed)\",\n  \"edge-type\": \"control dependence/flow and data dependence/flow\",\n  \"vertex-features\": \"identifiers in the instructions (one hot)\",\n  \"edge-features\": \"edge type\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"code summary/query\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"first compiled to IR\"\n    }\n  ],\n  \"vertex-type\": \"operands/opcode/labels in IR\",\n  \"edge-type\": \"control dependency/data dependency/oop related links (e.g. link method to object instance)\",\n  \"vertex-features\": \"variables in ir instruction (one hot)\",\n  \"edge-features\": \"edge type\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"code summary/query\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"first compiled to IR\"\n    }\n  ],\n  \"vertex-type\": \"operands/opcode/labels in IR\",\n  \"edge-type\": \"control dependency (or flow; not clearly specified)/data dependency\",\n  \"vertex-features\": \"both exact feature and encoding unclear\",\n  \"edge-features\": \"edge have a weight\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"serialised using depth first traversal; sequence of node types and tokens, encoded using word2vec\"\n}",
    "{\n  \"name\": \"PDG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"statement (names normalised)\",\n  \"edge-type\": \"control dependence/data dependence\",\n  \"vertex-features\": \"statement, encoded using sent2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"for every node, compute degree centrality, closeness centrality, and second order centrality.\\nCreate an RGB image, where each color dimension is a centrality multiplied by the node vector \\n(e.g. red = degree centrality * node vector).\\n\\nAn image (RGB) is obtained by concatenating all node representations.\"\n}",
    "{\n  \"name\": \"PDG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": \"statement (w/ names normalised)\",\n  \"edge-type\": \"control dependence/data dependence\",\n  \"vertex-features\": \"statement, encoded using sent2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"for every node, compute degree centrality, katz centrality, and closeness centrality.\\nCreate an RGB image, where each color dimension is a centrality multiplied by the node vector \\n(e.g. red = degree centrality * node vector).\\n\\nAn image (RGB) is obtained by concatenating all node representations.\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"method\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"every statement in the tree as follows: e.g. MethodDeclaration(Modifier(protected))(sendMessage)...(body)\\nThis results in a sequence of such statements \\n\\nmethod name (split up into sequence) is used as feature \\n\\nsequence of APIs used in the method is used as feature\\n\\nbag of tokens used in the snippets is used as feature \\n\\ncode summary/query is used as feature\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"method\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"nodes put into sequence using breath first search\\n\\nmethod name (split up into sequence) is used as feature \\n\\nsequence of APIs used in the method is used as feature\\n\\nbag of tokens used in the snippets is used as feature \\n\\ncode summary/query is used as feature\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"smart contracts\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Depth first traversal to generate:\\n1) node type sequence \\n2) node value sequence\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"Graph relation names of program variables\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"program\"\n    }\n  ],\n  \"vertex-type\": \"constants, properties, methods, globals\",\n  \"edge-type\": \"Relations (e.g. L += R, L < R where L = left, R = right; anything relating two names, essentially)/alias relation/may call/may access\",\n  \"vertex-features\": \"Program Element Names\",\n  \"edge-features\": \"Relation Type\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"Graph relation names of program variables\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"program\"\n    }\n  ],\n  \"vertex-type\": \"expressions, constants\",\n  \"edge-type\": \"Relations (e.g. L += R, L < R where L = left, R = right; anything relating two names, essentially)/alias relation/may call/may access\",\n  \"vertex-features\": \"data types associated with nodes\",\n  \"edge-features\": \"Relation Type\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"ast with additional edges. The AST is the thing being generated by the model.\",\n  \"artefacts\": null,\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/sibling/parent/next-use/next token\",\n  \"vertex-features\": null,\n  \"edge-features\": null,\n  \"connectivity-features\": null,\n  \"graph-features\": null,\n  \"other-features\": \"Context code (which contains the hole to be filled in) is used as feature.\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"token in AST nodes w/ sub-token splitting (embedding not specified)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"pre-order traversal. At every statement (composite) node, tree is split into sub-trees.\\n\\nCode is used as a feature\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"heterogeneous graph with developers' github and stackoverflow activity\",\n  \"artefacts\": [\n    {\n      \"name\": \"github data\",\n      \"details\": \"projects, user data, topics (\\\"abilities\\\")\"\n    },\n    {\n      \"name\": \"stackoverflow data\",\n      \"details\": \"questions, answers, users, tags (\\\"abilities\\\")\"\n    }\n  ],\n  \"vertex-type\": \"developers/projects/questions/abilities\",\n  \"edge-type\": \"follows (developer -> developer) / answered (Q -> D) / ask (D -> Q) / commit/committed (D <-> P) / label/labelled (P <-> A, Q <-> A)\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"Edges are weighted (1 for most, except \\\\# committ(ed), \\\\# asked/answered)\",\n  \"connectivity-features\": \"transition probability matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": null\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"Complete old and new files are used in order to parse the changed method in full.\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"diff\"\n    },\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"Node types (internal nodes)\\n\\nLeaf nodes are split into sub-tokens\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"For both old and new code, paths between changed tokens are extracted from the \\nASTs obtained from the old/new files.\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"Not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"code tokens are used as feature\"\n}",
    "{\n  \"name\": \"Split AST\",\n  \"description\": \"First, the CFG is computed.\\nThen, the dominator tree of the CFG is computed.\\nFor every node with more than 2 outgoing edges, its outgoing edges are removed,\\nleading to groups of separate nodes. For every group of nodes, its AST \\nsubtree is computed. (alternative view: the AST is split up according to the graph described above)\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"Node type and value (concatenated)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Source code is used as feature\"\n}",
    "{\n  \"name\": \"API Dependency Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"API\",\n  \"edge-type\": \"Denotes that some output(s) of method A match (type-wise) some input(s) of method B\",\n  \"vertex-features\": \"one-hot encoded\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"code snippet is used as feature\"\n}",
    "{\n  \"name\": \"field focussed graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"class\"\n    }\n  ],\n  \"vertex-type\": \"methods/fields/constructors/semantic relations (calls, reads, writes, sync, modifier)\",\n  \"edge-type\": \"method/fields/constructors are connected with undirected edges, with a semantic node inbetween them\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"several subgraphs are isolated, by taking all subsets of <= 2 methods/fields/constructors,\\nand extracting the subgraphs reachable from those nodes.\",\n  \"other-features\": \"Every subgraph is encoded using the  Weisfeiler Lehman kernel. \\nThe resulting vectors are combined by first computing three vectors through min/max/mean pooling,\\nand then concatenating these.\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"ast w/ ncs; AST of the old source code\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"diff\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/ncs\",\n  \"vertex-features\": \"not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"difference between old and new ast\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"diff\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/added/removed/replaced/unchanged\",\n  \"vertex-features\": \"not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"AST linearised through pre-order traversal. (node types for internal, payload for leafs)\\n\\nTwo matrices are extracted:\\n  1) Shortest path distance matrix where M_{ij} denotes the signed length of the shortest path between node i and j, provided it is less than some threshold p ($\\\\infty$ otherwise)\\n  2) Sibling distance matrix where M_{ij} denotes the signed distance between siblings i and j. $\\\\infty$ if exceeding some threshold\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"repository\"\n    }\n  ],\n  \"vertex-type\": \"repository/token (frequently occurring source code tokens from malicious repositories)\",\n  \"edge-type\": \"source file in repository contains token\",\n  \"vertex-features\": \"node embeddings computed using deepwalk (random walk w/ skipgram)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"repository\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"user/repository/file\",\n  \"edge-type\": \"user interactions (comment, fork, star, contribute)/repository has file\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"Various (eight) meta paths are used\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"extract arbitrary paths (no specific end node types) from AST,\\nwith filtering based on path length and width (i.e. max distance between sibling nodes used in the same path)\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"javascript\"\n    }\n  ],\n  \"vertex-type\": \"ast (nonterminal nodes only)\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"continuous binary tree\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"CFG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"javascript\"\n    }\n  ],\n  \"vertex-type\": \"basic block\",\n  \"edge-type\": \"control flow\",\n  \"vertex-features\": \"random vectors\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"node content encoded using tf-idf / doc2vec (2 sets of experiments)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"cfg\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"statement\",\n  \"edge-type\": \"control flow\",\n  \"vertex-features\": \"node content encoded using tf-idf / doc2vec (2 sets of experiments)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"cdg (control dependence graph)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"statement\",\n  \"edge-type\": \"control dependence\",\n  \"vertex-features\": \"node content encoded using tf-idf / doc2vec (2 sets of experiments)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"ddg (data dependence graph)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"statement\",\n  \"edge-type\": \"data flow\",\n  \"vertex-features\": \"node content encoded using tf-idf / doc2vec (2 sets of experiments)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"CFG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"file\"\n    }\n  ],\n  \"vertex-type\": \"statement\",\n  \"edge-type\": \"control flow\",\n  \"vertex-features\": \"tokens in statement\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Bug report is also used as feature \"\n}",
    "{\n  \"name\": \"(partial) AST\",\n  \"description\": \"Partial AST, further generated during code generation\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"type and value, encoded (not specified, presumably embedding layer) and concatenated\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"depth first traversal of AST nodes; sequence of type (internal) or type/value combinations (leaf).\\n\\nCompute path from root node to node being predicted (i.e. node whose child will be predicted).\\nUse the path as sequence input\"\n}",
    "{\n  \"name\": \"Augmented AST\",\n  \"description\": \"AST w/ additional edges\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast/shared subtoken nodes (one for each unique subtoken) [vocab node]\",\n  \"edge-type\": \"ast/sibling/control flow/data flow\",\n  \"vertex-features\": \"token for vocab nodes, type for ast nodes\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"CFG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"basic block\",\n  \"edge-type\": \"control flow\",\n  \"vertex-features\": \"basic block encoded using doc2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"nodes encoded using continuous binary tree\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"type (based on image)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"In all instances, identifiers are split into sub-tokens \\n\\nsource code is used as feature.\\n\\nAST is linearised (using brackets to make process reversible; structure based traversal)\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"type and value (EMPTY value for internal nodes)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"AST linearised using depth first traversal.\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Sequence of nonterminal rule expansions used to \\nfrom free (depth first, left-to-right order), is used as feature\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"pairs of source code for training\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"node type one hot\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Multilayer Class Network\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"project\"\n    }\n  ],\n  \"vertex-type\": \"class\",\n  \"edge-type\": \"class/interface relationships\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Multilayer Package Network\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"project\"\n    }\n  ],\n  \"vertex-type\": \"package\",\n  \"edge-type\": \"class/interface relationships (based on the coupling between the classes in the packages)\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"Weights based on the amount of coupling (i.e. amount of involved classes)\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"bipartite network\",\n  \"artefacts\": [\n    {\n      \"name\": \"github repositories\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"github user data\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"repositories/users\",\n  \"edge-type\": \"contributes\",\n  \"vertex-features\": \"for users: potential passwords/keys, occurrences of string \\\"password\\\" in a file, sensitive filetypes.\\n\\nfor repos: vulnerability type(s) detected by scanner tool (secret leakage, classical vulnerabilities such as sql, etc.)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"The bipartite network is projected into two mono-partite networks (user network and repo network)\\n\\nGraphs are encoded using text associated deep walk\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"pairs of source code for training (diff)\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast (bidirectional) / siblings\",\n  \"vertex-features\": \"not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"sequence of edit actions to transform first AST into the other\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"Node content (Nonterminal, with payload for leave nodes)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"depth-first traversal of AST, while inserting brackets (<, >) to denote subtrees\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast (nonterminal nodes only)\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"node type\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"nodes are put into bread-first sequence; \\nfor every node, it is replaced by a list consisting of itself and its direct children\\npadding is applied\\nresult: matrix of size (max_subtrees x max_children)\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"file\"\n    }\n  ],\n  \"vertex-type\": \"ast (merge certain types, prune some stuff)\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"node type encoded using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"bug report encoded using word2vec \\nraw source code encoded using word2vec\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"project\"\n    }\n  ],\n  \"vertex-type\": \"class/property/method/parameter/variable\",\n  \"edge-type\": \"inheritance/has (class has property, class has method, method has parameter, method has variable)/instance_of/return_type/call\",\n  \"vertex-features\": \"see graph features\",\n  \"edge-features\": \"see graph features\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"knowledge graph is embedded using one of: TransE, TransH, TransR.\\nidea: every (source, edge, tail) triple should have encodings (h, r, t) such that h + r \\\\approx t\",\n  \"other-features\": \"bug report used as feature, encoded using word2vec \\n\\ncode text used as feature, encoded using word2vec\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"file\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"code tokens embedded using GloVe\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified, but presumably adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"bug report is used as feature \\n\\nsource code text is used as a feature\"\n}",
    "{\n  \"name\": \"PDG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"file\"\n    }\n  ],\n  \"vertex-type\": \"statement (?)\",\n  \"edge-type\": \"control dependence/data dependence\",\n  \"vertex-features\": \"method and field names are encoded using word2vec.\\n\\nnumber of api names \\n\\nnode type \\n\\nVarious network-derived metrics are used\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"title, description, comments of bug report are analysed using LDA;\\n\\\"multiple-hot\\\" vector of present topics is used as feature\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast (binarised)\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"node type and content, both using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Labelled pushdown system\",\n  \"description\": \"Inter-procedural control flow of a program modelled as a pushdown system,\\nwhere each rule has a label, which are concatenated as the machine makes \\nits transitions.\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"state\",\n  \"edge-type\": \"transition\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"labels (for instruction category, error code,struct type, functions)\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"Perform random walks over the graph, and collect the sequence of labels\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Extended API Usage Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"objects/values/method invocations/constructor calls/field access/conditional checks/inheritance\",\n  \"edge-type\": \"call/control flow/sequential execution/synchronization/throw/handle/param\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"The authors make use of a set of discriminative subgraphs; subgraphs indicative of a label.\\nEach graph has a binary vector, where each entry indicates whether some specific discriminative subgraph occurs in the graph.\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"based on AST, but with abstracted/less information\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"API call/control unit/variable declaration/assignment\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"not clearly specified, but seems to be node content (type for control unit; tokens for the others)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Generated statements _without variables_ are ranked based on classifier confidence,\\nand a score computed based on a (non ML) data flow analysis of the graph,\\nwhich intuitively measures whether the variables in the statements \\nmake sense, given the graph full training corpus, \\nis used to fill in the names of the variables.\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"Based on graphs in recommendation systems\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"multiple files/project\"\n    }\n  ],\n  \"vertex-type\": \"method declarations/APIs/structural (classes, packages, non-method stuff)\",\n  \"edge-type\": \"method <-> API calls/project structure  (e.g. belongs to)\",\n  \"vertex-features\": \"method/class/package name split up into words\\n\\nunique ID per node\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"AST graph (constructed from partial AST)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast (but identical nodes are merged)\",\n  \"edge-type\": \"ast (directed)/nodes adjacent in the depth-first traversal sequence of the AST are linked (undirected)\",\n  \"vertex-features\": \"node type and node value (EMPTY for internal nodes) (embedding method unclear); also positional information (distance to right-most node in sequence, which may be 0 if the right-most node is duplicated elsewhere, encoded as vector of repeated entries)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": null\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"text and type\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"ast (binarized)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"source code text is used as feature\"\n}",
    "{\n  \"name\": \"CFG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"statement\",\n  \"edge-type\": \"control flow\",\n  \"vertex-features\": \"encoded using doc2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified explicitly, presumably adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"source code text is used as feature\"\n}",
    "{\n  \"name\": \"AST (binarised)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"tokens (leaf nodes)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"source code text is used as feature\"\n}",
    "{\n  \"name\": \"ast (binarised)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"leaf node content encoded using word2vec.\\n\\nnode types weighted using tf/idf\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"source code text\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"code (token) payload according to a weighted sum of the one-hot encoding of its characters\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"collection of connected ASTs,\\ncollected based on method call chains\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"file (?)\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"word2vec for node content\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"average pooling over node features\",\n  \"other-features\": \"average pooling over the graph embedding of all ASTs\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"collection of connected CFGs,\\ncollected based on method call chains\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"file (?)\"\n    }\n  ],\n  \"vertex-type\": \"statement/entry/exit\",\n  \"edge-type\": \"control flow\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"graph2vec\",\n  \"other-features\": \"apply graph2vec on the graph of connected cfg\"\n}",
    "{\n  \"name\": \"AST (binarized)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"tokens word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"split into statement trees; subtrees containing a statement as root\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"word2vec for node type (non-leaf) or lexical payload (leaf)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"see description; split into statement trees; subtrees containing a statement as root \\nstatement trees are ordered in depth first fashion (from the perspective of the full ast)\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"node type\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"byte code sequence \\n\\nsequence of identifiers and constants from the code\\n\\npre-order sequence of ast node types\"\n}",
    "{\n  \"name\": \"cfg\",\n  \"description\": \"n/a\",\n  \"vertex-type\": \"statement\",\n  \"edge-type\": \"control flow\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"High-Order Proximity preserved Embedding (HOPE) for node embedding; then take average\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"PDG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"statement\",\n  \"edge-type\": \"control dependence/data dependence\",\n  \"vertex-features\": \"statements as sequences of tokens\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"description of the code is used as feature\"\n}",
    "{\n  \"name\": \"CFG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"method\"\n    }\n  ],\n  \"vertex-type\": \"basic block (statement)\",\n  \"edge-type\": \"control flow\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"A matrix of features is associated with every method.\\nThree types of entities are present in the graph:\\n1) variables -- features: type, modifiers, additional info (3x one-hot)\\n2) basic blocks (relationship between variable and basic block) -- state: statement type (one-hot)\\n3) variable relationships in blocks [data flow]: 43D vector \\n\\n\\\"pilar\\\" A_{ij} in the feature matrix (actually a tensor) records the \\nrelationships between {block,variable}-i and {block,variable}-j;\\nthe contents in the pilar is either (1), (2), or (3), depending on the\\ntypes of i and j.\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"node embeddings are learned by appying continuous skip-gram to the AST structure\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"dependency tree\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/def-use relations\",\n  \"vertex-features\": \"node type\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/data flow (different types, e.g. lastUse)\",\n  \"vertex-features\": \"node type\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"cpg\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/control dependence/control flow/data dependence\",\n  \"vertex-features\": \"node type ordinal, node content (encoding unclear)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/ncs\",\n  \"vertex-features\": \"node type one-hot\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"version history information\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"developer\",\n  \"edge-type\": \"two devs are connected if they made changes to the same file in the same release\",\n  \"vertex-features\": \"\\\"classical\\\" network metrics (connectivity, centrality, degree, betweenness, closeness)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"For every file in a project, the average, maximum, and sum of the developer metrics \\nof all developers who contributed to that file (overall, not per release; unweighted)\\nare computed. \\n\\nFiles have various other (more traditional) code changes metrics, such as \\ncode churn (# modified lines over history), # updates, # distinct developers\"\n}",
    "{\n  \"name\": \"Socio-Technical Network\",\n  \"description\": \"Directed graph\",\n  \"artefacts\": [\n    {\n      \"name\": \"version history information\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"source code\",\n      \"details\": \"project\"\n    }\n  ],\n  \"vertex-type\": \"developer/software component\",\n  \"edge-type\": \"contributed to (dev -> component)/contributed by (component -> dev)/depends on (component -> component)\",\n  \"vertex-features\": \"various local (node-level) network metrics (some of which use edge weights)\",\n  \"edge-features\": \"contributed to edge is weighted by the number of commits\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"various global network metrics\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Dependency Network\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"project\"\n    }\n  ],\n  \"vertex-type\": \"software component\",\n  \"edge-type\": \"contributed to (dev -> component)/contributed by (component -> dev)/depends on (component -> component)\",\n  \"vertex-features\": \"various local (node-level) network metrics (some of which use edge weights)\",\n  \"edge-features\": \"contributed to edge is weighted by the number of commits\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"various global network metrics\",\n  \"other-features\": \"n/a\",\n  \"edge type\": \"depends on\"\n}",
    "{\n  \"name\": \"Contribution Network\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"version history information\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"developer/software component\",\n  \"edge-type\": \"contributed to (dev -> component)/contributed by (component -> dev)/depends on (component -> component)\",\n  \"vertex-features\": \"various local (node-level) network metrics (some of which use edge weights)\",\n  \"edge-features\": \"contribution is weighted by the number of commits\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"various global network metrics\",\n  \"other-features\": \"n/a\",\n  \"edge type\": \"contribution\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"project\"\n    }\n  ],\n  \"vertex-type\": \"module\",\n  \"edge-type\": \"data dependency/call dependency\",\n  \"vertex-features\": \"node level network metrics\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"graph level network metrics\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Tri-Network\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"version history information\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"source code\",\n      \"details\": \"project\"\n    }\n  ],\n  \"vertex-type\": \"developer/module\",\n  \"edge-type\": \"contribution (developer -> module)/dependency (module -> module) -- both co-evolution and call, but a single edge type/collaboration (developer <-> developer) -- two devs modified the same module\",\n  \"vertex-features\": \"node level network metrics \\n\\nvarious software metrics per node (e.g. cyclomatic complexity, number of LOC, etc)\",\n  \"edge-features\": \"contribution edge is weighted by normalised number of commits \\n\\ndependency is weighted by sum of 1) normalised \\\\# of co-change commits, and 2) normalised number of calls \\n\\ncollaboration is weighted by normalised number of jointly changed modules\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"snippets\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Paths between terminal nodes are extracted from the AST.\\nFor the terminal nodes, tokens are features. \\nThe path itself (sequence of types, interlaced with up/down directions) are also features (i.e. a full path is a single feature)\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"commit / diff + full files (old / new versions)\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": null,\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"methods from diff are extracted. AST is computed for old and new versions.\\nterminal to terminal paths in the ASTs are computed. Paths present \\nin both old and new version are discarded. \\nFor the terminal nodes, tokens are features. \\nThe path itself (sequence of types, interlaced with up/down directions) are also features (i.e. a full path is a single feature)\"\n}",
    "{\n  \"name\": \"Contextual Flow Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"compiled to LLVM IR, which is used for graph construction\"\n    }\n  ],\n  \"vertex-type\": \"variables or label identifiers\",\n  \"edge-type\": \"data flow/data dependence/control flow\",\n  \"vertex-features\": \"values are replaced with their type, identifiers with a special marker\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Statement pairs <= N hops away are extracted from a set of graphs\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"some amount of edits must already have been applied\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"1) node type is a feature\\n2) terminals have tokens, split into subtokens \\n3) Each token has its index among its siblings as feature\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Each edit is represented as a path, e.g. \\n1) A MOVE is represented as a path from the root of the subtree being moved, to its new location (eg its left-most sibling)\\n2) UPDATE, INSERT, DELETE have similar path representations.\\n\\nSpecifically, two sets are created: 1) the set of applied edits, 2) the set of all possible edits.\\nBoth are separately encoded\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/data flow/ncs/function call/control flow\",\n  \"vertex-features\": \"not specified\",\n  \"edge-features\": \"edge type\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"data flow/ncs/function call/control flow\",\n  \"vertex-features\": \"not specified\",\n  \"edge-features\": \"edge type\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"The regular AST is taken, and all connections are \\\"moved down\\\" to the leaf nodes;\\nnon-leaf nodes are removed.\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"variable\",\n  \"edge-type\": \"data flow (values comes from; directed)\",\n  \"vertex-features\": \"variable name\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"comment (for function, e.g. javadoc) is used as feature\\n\\nfunction source is used as feature \\n\\ngraph is linearised and used as feature \\n\\nsequence starts with [CLS], the three parts are separated with [SEP]\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"node type for nonterminals, source code tokens for terminals\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"The set of paths from the root to each terminal node is used for the features. \\nFor each path, the nodes (type or tokens) are put into sequence. \\n\\nnode location information is used as feature\\n\\nThe original code snippet is tokenised\"\n}",
    "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"node type and tokens are used as features\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"certain sub-trees are extracted from the AST based on node type. Note that these are used as \\\"labels\\\"; the full AST is used as input.\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": null,\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Paths between two terminals (incl. directions) are used as features\\nFor the terminal nodes, tokens are features. \\nThe path itself (sequence of types, interlaced with up/down directions) are also features (i.e. a full path is a single feature)\"\n}",
    "{\n  \"name\": \"cfg\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"statement\",\n  \"edge-type\": \"control flow\",\n  \"vertex-features\": null,\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Paths from the method start to either a return statement\\nor earlier visited path (loop structure) are used as features\\n\\nExact details not specified, but based on code2vec we would have that the path (sequence of types) is the feature\"\n}",
    "{\n  \"name\": \"pdg\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"statement\",\n  \"edge-type\": \"control dependence/data dependence\",\n  \"vertex-features\": null,\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Paths of homogeneous edge type (either all control or all data dependence) (incl. directions)\\nare used as features.\\n\\nExact details not specified, but based on code2vec we would have that the path (sequence of types, incl. directions) is the feature\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"module\"\n    }\n  ],\n  \"vertex-type\": \"ast (only specific node types are kept)\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"node type\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"pre-order traversal sequence of ast nodes.\"\n}",
    "{\n  \"name\": \"Class Dependency Network\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"project\"\n    }\n  ],\n  \"vertex-type\": \"class\",\n  \"edge-type\": \"class or interface dependencies and relationships\",\n  \"vertex-features\": \"nodes are embedded using node2vec.\\n\\nnodes are also annotated with various static code metrics (e.g. # methods)\\n\\nNodes are also annotated with various network metrics.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not explicitly specified, but seems to be adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"pruned using Louvian community detection algorithm (only \\\"defect related communities\\\" of nodes are kept)\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"module\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"node type, exact encoding is unclear. Combined with the topic vector (see \\\"other features\\\"), which is identical for all nodes.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"For each defective module, LDA is used to extract a topic based on subtokens \\nin method names, variable names, class names etc., taking the top-k words.\\nThe topic is encoded using word2vec.\\nI think the topic vectors are then averaged\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"file (I think)\"\n    }\n  ],\n  \"vertex-type\": \"ast (only certain node types are kept)\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"not specified, though images imply type for nonterminals, and tokens for terminals\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"pre-order sequence of nodes, encoded using model-1, is used as input for model-2.\\n\\nHand-crafted detection-related features are used.\"\n}",
    "{\n  \"name\": \"Class network\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"project\"\n    }\n  ],\n  \"vertex-type\": \"class\",\n  \"edge-type\": \"class dependencies (calling relations)\",\n  \"vertex-features\": \"1) Internal node features (e.g. number of methods in class)\\n2) External node features (e.g. out degree, centrality; classical non-global network metrics)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"method\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"node type\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"pre-order depth first traversal to create a sequence of nodes.\\nFrom this sequence, n-grams are constructed. \\nBinary encoding of the present n-grams is used as feature.\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"file\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"AST is linearised (both types and tokens) using pre-order traversal,\\nwhere only certain node types are included in the sequence.\"\n}",
    "{\n  \"name\": \"Software network\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"project\"\n    }\n  ],\n  \"vertex-type\": \"file (in project)\",\n  \"edge-type\": \"dependency or association\",\n  \"vertex-features\": \"vertices encoded using node2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"file\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"node type, unclear if content (code tokens) are also used, but seems to be only node type\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"AST linearised. Tokens (node type; code tokens unclear if used) are encoded using Glove.\\n\\ntraditional code metrics are also used as features.\"\n}",
    "{\n  \"name\": \"Member Dependency Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"system\"\n    }\n  ],\n  \"vertex-type\": \"data item (eg shared variables) / function\",\n  \"edge-type\": \"call / return / data flow\",\n  \"vertex-features\": \"code level metrics\",\n  \"edge-features\": \"number of data items transferred in an edge\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Component Dependency Graph\",\n  \"description\": \"constructed from the member dependency graph; there exists an edge between two components if there exists an edge between two members from each component\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"system\"\n    }\n  ],\n  \"vertex-type\": \"component\",\n  \"edge-type\": \"dependency\",\n  \"vertex-features\": \"metrics describing the \\\"graph structure\\\" in a component (e.g. average internal data flow)\\n\\nsome code level metrics \\n\\nsome network metrics\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Class Dependency Network\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"project\"\n    }\n  ],\n  \"vertex-type\": \"class\",\n  \"edge-type\": \"class/interface relationships\",\n  \"vertex-features\": \"nodes are embedded using node2vec.\\n\\nTraditional software engineering metrics (e.g. CBO) are used as features.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"file\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"node type\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"AST is linearised, where only certain node types are kept.\\nNode types are replaced with their code token(s) if they represent identifiers.\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/control flow/control dependence/data dependence/dominator/post dominator\",\n  \"vertex-features\": \"node type (presumably one-hot), code associated with node encoded using word2vec\",\n  \"edge-features\": \"edge type one-hot encoded\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"the heterogeneous graph is split into multiple homogeneous graphs based on edge type\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Crucial Data Flow Graph\",\n  \"description\": \"subgraph of the data flow graph, which only contains vulnerability-related nodes\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"smart contracts\"\n    }\n  ],\n  \"vertex-type\": \"variable\",\n  \"edge-type\": \"data flow\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"mask matrix (?)\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Input for the model is: [CLS] <Token Sequence> [SEP] <Variable Sequence>\\nwhere the token sequence is the sequence of source code tokens \\n(and their corresponding positions), and the variable sequence is the sequence of variables\\nin the graph (and their corresponding positions).\"\n}",
    "{\n  \"name\": \"Code Property Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/control flow/control dependence/data dependence\",\n  \"vertex-features\": \"1) node type one hot \\n2) operator type one hot \\n3) used API functions, binary encoding \\n4) float and integer literals are included as their 32 bit representation \\n5) type of variables are included, one-hot encoded\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"Code Property Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": null\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/control flow/control dependence/data dependence\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Features are represented as a 3D tensor, where the first two dimensions \\nrepresent nodes, and the third dimension represents features describing\\nthe relation between the two nodes.\\n\\nThese features include data type/modifier information,\\noperators between the two nodes, the parent child relationship between the two nodes (i.e. is_parent(i, e), with a one-hot entry for the node type of the child),\\ncontrol flow node information.\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"ast (binarized)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": \"ast/null nodes (inserted to make a full binary tree out of the ast)\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"every node is represented as a 3-entry vector,\\nwhere the first entry is the ordinal encoding of the node types,\\nand the other two entries carry additional information about the node.\\n\\nnull nodes are encoded as (0, 0, 0)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Note is put into sequence using breadth first traversal\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"linearised using depth first traversal, \\nyielding a stream of node types and code tokens.\"\n}",
    "{\n  \"name\": \"AST Graph\",\n  \"description\": \"generated from the code to be repaired, with a faulty statement located through e.g. a fault localisation model\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"method\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/direct left sibling\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"The AST (sub-)structure is traversed (pre-order),\\nand two sequences are created:\\n  1) word2vec encoded sequence of nodes \\n  2) the corresponding tagging sequence, where each tag denotes whether the current statement\\n      belongs to the fault statement, the statement before the faulty statement,\\n      the statement after the faulty statement, or another statement.\"\n}",
    "{\n  \"name\": \"AST (partial)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"n/a\",\n      \"details\": \"generated by model\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": null,\n  \"edge-features\": null,\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Sequence of rules used to generate the AST, encoded as real vectors.\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"method (s) (possibly multiple at once)\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"Statement corresponding to node encoded using GloVe\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"Buggy sub-tree is summarised using TreeCaps.\\n\\nFor training, each buggy sub-tree is replaced \\nwith its fixed sub-tree. The pairs of trees \\nare used for the context learning model.\\n\\nFor the working phase, each buggy tree is replaced with its \\nsummarised vector.\\n\\nWe call this the context tree\\n\\nEach node in a buggy sub-tree is multiplied by its context vector;\\nfor the old versions, this is the output of TreeCaps. For new versions,\\nthis is output of TreeCaps (training), or the predicted node from the \\ncontext model (working)\",\n  \"other-features\": \"Bug detector is used to collect buggy statements \\nand suspiciousness scores; consecutive statements are grouped into hunks.\\nBERT is used to determine which hunks must be fixed together.\\nOverall goal: given a function/method with multiple faulty statements (subtrees),\\nfix them all\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/control flow (might well be dependence; not a good distinction is made)/data dependence\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"weighted sum of the three adjacency matrices for the different edge types\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"code tokens are used as input\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"method\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"code text is used as feature\\n\\nsummary thus far is used as feature\\n\\nast is converted to sequence, where brackets are used \\nto keep structure, node name is used primarily, and lexical\\nelements are added to the node name, like in \\\"SimpleName_String\\\"\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code method\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": null,\n  \"edge-features\": null,\n  \"connectivity-features\": null,\n  \"graph-features\": null,\n  \"other-features\": \"code is split into a sequence of tokens per statement. (identifiers into sub tokens)\\n\\nThe AST is linearised per statement (node type or tokens) (subtree per statement);\\ntokens are split into subtokens\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"method\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/control flow/data dependence\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"weighted sum of adjacency matrices (A)\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"source code is used as feature \\n\\nshortest path length matrix is used as feature (normalised) (M)\"\n}",
    "{\n  \"name\": \"Data Flow Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"variable\",\n  \"edge-type\": \"data flow\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"mask matrix (1 for connected nodes, $-\\\\infty$ otherwise)\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"code tokens are used as input\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast/sub-tokens\",\n  \"edge-type\": \"ast/control flow/ncs/sibling/data flow\",\n  \"vertex-features\": \"node type (nonterminal), token (terminal); encoding not specified\",\n  \"edge-features\": \"edge type (presumably); encoding not specified\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"the source code (raw) is used as feature, encoded using CodeBERT \\n\\nsummary thus far is used as feature\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/sibling\",\n  \"vertex-features\": \"type (nonterminal), code tokens (terminal)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"presumably adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"source code text is used as feature\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"source code text is used as feature \\n\\nTerminal to terminal (\\\"relative\\\") paths are extracted (only the nonterminals in the path are used)\\n\\nTerminal to root (\\\"absolute\\\") paths are extracted (only the nonterminals in the path are used)\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"methods\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"type and value of nodes, encoded using BERT\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"source code tokens used as feature\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"method\"\n    }\n  ],\n  \"vertex-type\": \"all identifiers (incl. node types) are split into subtokens.\\nFor lexical nodes, both the type and token(s) are put in a sequence;\\nfor syntax nodes only the type\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": null,\n  \"edge-features\": null,\n  \"connectivity-features\": null,\n  \"graph-features\": null,\n  \"other-features\": \"code (w/ identifiers split into sub-tokens) is used as feature\"\n}",
    "{\n  \"name\": \"ast (partial)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"n/a\",\n      \"details\": \"generated by model\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"each node represented by an embedding, unclear how it is computed\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Description of code to be generated is used as feature (embedding unclear).\\n\\nPreviously outputted grammar rules (sequence) are used as features.\\n\\npath from root to next node to expand is used as feature.\\n\\nMethod/function scope is used as feature (nearest enclosing scope)\"\n}",
    "{\n  \"name\": \"ast (partial)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"n/a\",\n      \"details\": \"generated by model\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"The AST is represented as a sequence or rule expansions.\",\n  \"other-features\": \"Natural language description of the code to be generated \\n\\nNode to be expanded represented as path from root to node, encoded with the node types\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"method\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"not clearly specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Dependency Files\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"library\",\n  \"edge-type\": \"dependency\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"adjacency matrix / general connectivity\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
    "{\n  \"name\": \"n/a\",\n  \"description\": \"Separate graphlets based on old/new and different snippets in commits. Take union. May not be a connected graph\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"commit\"\n    }\n  ],\n  \"vertex-type\": \"unique node per node type (srcML)\",\n  \"edge-type\": \"node has child node of type\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"graph-level network metrics\",\n  \"other-features\": \"software engineering metrics about diff\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"method\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"node type (syntax), node code tokens (internal)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"source code tokens and sub-tokens in method name\"\n}",
    "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"method\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"not clearly specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"source code tokens\"\n}"
  ],
  "refinements": [
    {
      "action": "refine",
      "old": "Arbitrary Graphs (?)",
      "new": "any graph"
    },
    {
      "action": "refine",
      "old": "[\n  {\n    \"name\": \"AST\",\n    \"description\": \"n/a\",\n    \"artefacts\": [\n      {\n        \"name\": \"Source code\",\n        \"details\": \"n/a\"\n      }\n    ],\n    \"vertex-type\": [\n      {\n        \"name\": \"AST Node\",\n        \"details\": \"n/a\"\n      }\n    ],\n    \"edge-type\": [\n      {\n        \"name\": \"AST Edge\",\n        \"details\": \"n/a\"\n      }\n    ],\n    \"vertex-features\": \"First of all, for each node, its type, content, and position (line nr, column),\\nare combined into a string and embedded using a document embedding (flair)\\n\\nPaths from the root to leaf nodes are extracted, and embedded in the same way.\\n\\nPath embeddings are added to node embeddings to augment them.\",\n    \"edge-features\": \"n/a\",\n    \"connectivity-features\": \"Adjacency Matrix\",\n    \"graph-features\": \"n/a\",\n    \"other-features\": \"n/a\"\n  }\n]",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"$\\\\sigma$-0 graph\",\n  \"description\": \"Mostly based on PDG, but with more variety in node types\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Entry Node\",\n      \"details\": \"Entrypoint of control flow into the graph\"\n    },\n    {\n      \"name\": \"Exit Node\",\n      \"details\": \"Exit point of control flow from the graph\"\n    },\n    {\n      \"name\": \"Data Node\",\n      \"details\": \"Represent data, e.g. constants, variables, literals\"\n    },\n    {\n      \"name\": \"Action Node\",\n      \"details\": \"Represent actions, e.g. function calls, operators, etc.\"\n    },\n    {\n      \"name\": \"Control Node\",\n      \"details\": \"Represent control points, e.g branches, looping\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Entry Node: \\\"ENTRY\\\"\\nExit Node: \\\"EXIT\\\" \\nVariable Node: name of the variable type \\nControl Node: Name of control structure (e.g. \\\"IF\\\")\\nAction node: not specified \\n\\nFeatures encoded using fast text, and average of tokens is used\",\n  \"edge-features\": \"Regular Control edge: Not specified \\nException control edge (catch): type of exception\\ndata edge: receiver, parameter, definition, condition, qualifier \\n\\nFeatures encoded using fast text, and average of tokens is used\",\n  \"connectivity-features\": \"Method not specified \\n\\nreverse edges are added\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "pdg w/ additional node types for some control flow constructs"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"$\\\\sigma$-1 graph\",\n  \"description\": \"Mostly based on $\\\\sigma$-0 graph, but with additional information\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Entry Node\",\n      \"details\": \"Entrypoint of control flow into the graph\"\n    },\n    {\n      \"name\": \"Exit Node\",\n      \"details\": \"Exit point of control flow from the graph\"\n    },\n    {\n      \"name\": \"Data Node\",\n      \"details\": \"Represent data, e.g. constants, variables, literals\"\n    },\n    {\n      \"name\": \"Action Node\",\n      \"details\": \"Represent actions, e.g. function calls, operators, etc.\"\n    },\n    {\n      \"name\": \"Control Node\",\n      \"details\": \"Represent control points, e.g branches, looping\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Edge\",\n      \"details\": null\n    },\n    {\n      \"name\": \"Data Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Variable Usage Edges\",\n      \"details\": \"Multiple types, but unclear. At least FirstUse and LastUse\"\n    },\n    {\n      \"name\": \"Node Aliasing\",\n      \"details\": \"Not explained\"\n    },\n    {\n      \"name\": \"Control Dependence Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Same as $\\\\sigma$-0, but Node types (according to AST) are also used as features\",\n  \"edge-features\": \"Regular Control edge: Not specified \\nException control edge (catch): type of exception\\ndata edge: receiver, parameter, definition, condition, qualifier \\n\\nFeatures encoded using fast text, and average of tokens is used\",\n  \"connectivity-features\": \"Method not specified \\n\\nreverse edges are added\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "pdg w/ additional node types for some control flow constructs"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"(partial) AST\",\n  \"description\": \"Partial AST, further generated during code generation\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"type and value, encoded (not specified, presumably embedding layer) and concatenated\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"depth first traversal of AST nodes; sequence of type (internal) or type/value combinations (leaf).\\n\\nCompute path from root node to node being predicted (i.e. node whose child will be predicted).\\nUse the path as sequence input\"\n}",
      "new": "partial ast (generated during code completion)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ADG (API Dependency Graph)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"API Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Dependency Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "api dependency graph"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"APDG (Advanced PDG)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": null\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Method Declaration\",\n      \"details\": null\n    },\n    {\n      \"name\": \"Parameter\",\n      \"details\": null\n    },\n    {\n      \"name\": \"Unary Expression\",\n      \"details\": null\n    },\n    {\n      \"name\": \"Variable Declaration Expression\",\n      \"details\": null\n    },\n    {\n      \"name\": \"Method Call Expression\",\n      \"details\": null\n    },\n    {\n      \"name\": \"Assign Expression\",\n      \"details\": null\n    },\n    {\n      \"name\": \"Construction Declaration\",\n      \"details\": null\n    },\n    {\n      \"name\": \"Try Statement\",\n      \"details\": null\n    },\n    {\n      \"name\": \"Class Or Interface Declaration\",\n      \"details\": null\n    },\n    {\n      \"name\": \"Condition\",\n      \"details\": null\n    },\n    {\n      \"name\": \"Return Statement\",\n      \"details\": null\n    },\n    {\n      \"name\": \"Assert Statement\",\n      \"details\": null\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Dependence Edge\",\n      \"details\": null\n    },\n    {\n      \"name\": \"Control Dependence -- Child\",\n      \"details\": \"Essentially an AST Edge\"\n    },\n    {\n      \"name\": \"Control Dependence -- Next Statement\",\n      \"details\": null\n    },\n    {\n      \"name\": \"Control Dependence -- Judge\",\n      \"details\": \"True/False branches of if; back to condition for loop; denote conditional flow control\"\n    }\n  ],\n  \"vertex-features\": \"Graph Node is a set of (unordered) tokens (obtained from camel case for every node)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Summary (Training) or query (working) is also used as feature\"\n}",
      "new": "pdg with more specific node and edge types"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"API Context Graph\",\n  \"description\": \"Describes (Java STD) API usages and their context\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code (method)\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"API method call\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"API field access\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Variable declaration\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Assignment\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Unit\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Hole\",\n      \"details\": \"Hole to be filled in with an API recommendation. Should be _1_ node in the graph.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"S\",\n      \"details\": \"There is an edge (u, v) of type S in one of two cases:\\n  1) v is the Hole node and u represents a statement directly preceding the hole.\\n  2) u is the Hole node and v represents a statement directly following the hole.\"\n    },\n    {\n      \"name\": \"CD\",\n      \"details\": \"There is a direct data flow and a direct control flow from the source to the target node\"\n    },\n    {\n      \"name\": \"C\",\n      \"details\": \"There is a control flow from the source to the target node, but no data flow\"\n    },\n    {\n      \"name\": \"D\",\n      \"details\": \"There is a data flow from the source to the target node, but no control flow\"\n    }\n  ],\n  \"vertex-features\": \"Node names are generated based upon a set or rules; \\n\\n1) Declaration -> [Full Class Name].Declaration (String str -> java.lang.String.Declaration)\\n2) Declaration w/ constant assignment -> [Full Class Name].Constant \\n3) Declaration w/ null assignment -> [Full Class Name].Null\\n4) Declaration w/ object creation -> [Full Class Name].new([parameter types])\\n5) API Method Call -> [Full Method Name]([parameter types])\\n6) API Field Access -> [Full Field Name]\\n7) Control unit -> [Name] (if -> if)\\n8) Nested API method call/field access (e.g. call inside call) -> list calls following above rules, inner to outer\\n9) cascading method calls/field access -> Keep cascading structure; only expand initial call\\n(note: cascading = chained)\",\n  \"edge-features\": \"Edge labels are not used as features\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Names as described for vertex features are tokenized by;\\n1) removing trailing numbers\\n2) splitting on underscores, numbers, dollar signs, camelCasing\\n3) duplicate and meaningless (single letter) tokens are discarded\\n4) remaining tokens are encoded using GloVe\"\n}",
      "new": "api usages w. control flow and data flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"API Dependency Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"API\",\n  \"edge-type\": \"Denotes that some output(s) of method A match (type-wise) some input(s) of method B\",\n  \"vertex-features\": \"one-hot encoded\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"code snippet is used as feature\"\n}",
      "new": "api dependency graph (api w. edges denoting that api x uses api y)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"API Enhanced AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"A new AST node _type_ is added for every API called;\\ni.e. every function call node gains a new child node whose\\ntype is equal to the API name\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Node type is encoded using Word2Vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w/ special node _types_ for every api call"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST (binarised)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"tokens (leaf nodes)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"source code text is used as feature\"\n}",
      "new": "ast (binarised)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST (binarized)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"tokens word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast (binarised)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST (partial)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"n/a\",\n      \"details\": \"generated by model\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": null,\n  \"edge-features\": null,\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Sequence of rules used to generate the AST, encoded as real vectors.\"\n}",
      "new": "partial ast (generated during code completion)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST Graph\",\n  \"description\": \"generated from the code to be repaired, with a faulty statement located through e.g. a fault localisation model\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"method\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/direct left sibling\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"The AST (sub-)structure is traversed (pre-order),\\nand two sequences are created:\\n  1) word2vec encoded sequence of nodes \\n  2) the corresponding tagging sequence, where each tag denotes whether the current statement\\n      belongs to the fault statement, the statement before the faulty statement,\\n      the statement after the faulty statement, or another statement.\"\n}",
      "new": "ast w ast/sibling"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST graph (constructed from partial AST)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast (but identical nodes are merged)\",\n  \"edge-type\": \"ast (directed)/nodes adjacent in the depth-first traversal sequence of the AST are linked (undirected)\",\n  \"vertex-features\": \"node type and node value (EMPTY for internal nodes) (embedding method unclear); also positional information (distance to right-most node in sequence, which may be 0 if the right-most node is duplicated elsewhere, encoded as vector of repeated entries)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": null\n}",
      "new": "partial ast (generated during code completion) w. ast/sibling"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"AST split into subtrees for statements (specific vulnerability related statement types)\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"powershell\"\n    }\n  ],\n  \"vertex-type\": \"AST node\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"word2vec of node content\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"AST with some simplifications;\\n1) only function are kept\\n2) all functions are aggregated under a single root node\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Encoded using Embedding Layer\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"AST\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code (method)\",\n      \"details\": \"adjustable\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"One-hot encoding of node type\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Edge Index List (Adjacency List)\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"Each AST is split into subtrees.\\nSpecifically, each composite structure (e.g. if, while)\\nis replaced with a placeholder node, and the \\ncorresponding subtree is isolated from its parent tree.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"unclear how nodes in tokens are initially embedded\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"Structure tree (tree representing how all subtrees fit together) \\nis also used as graph.\",\n  \"other-features\": \"Raw code snippets are used as features\\n\\nFor code search, a query is given in text form.\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"The AST of the old and of the new function are both extracted. \\nThree subtrees are extracted\\n  1) The old (buggy) subtree\\n  2) The new (fixed) subtree\\n  3) The common context\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"patch\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"The tokens of leaf nodes are extracted as features.\\nNames are split up\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"All paths from the AST connecting two leaf nodes are extracted.\\nIf multiple paths are possible, the shorted is used.\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"BERT for embedding nodes\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Sequence input is given. Per task this is:\\n  1) Comment and code for comment classification\\n  2) code and author for author attribution \\n  3) 2x code for duplicate function detection\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code (path/commit)\",\n      \"details\": \"Patch is split up into pre- and post- change function. An AST is made for both.\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Paths from start to end nodes are constructed,\\nwhere the path must always pass through the root of \\nthe changed (added/deleted) subtree.\\n\\nTwo types of paths:\\n1) within change; start and end are both leaf nodes in the \\n    changed subtree\\n2) within context: start is a leaf node in the changed subtree,\\n    end is a leaf node in the unchanged remainder of the tree.\\n\\nBoth path types are randomly sampled in a 1:1 ratio.\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"File\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Only method calls (incl. class creation), declarations, and control flow nodes are kept.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Content of tokens is put into a sequence\"\n}",
      "new": "ast (trimmed)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"File\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Only method calls (incl. class creation), declarations, and control flow nodes are kept.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Node types are put into a sequence\"\n}",
      "new": "ast (trimmed)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"In this setting, the source code is obtained from decompiled byte code.\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Generic and specific node type \\n(e.g. a variable of specific type \\\"Variable\\\" has generic type \\\"Expression\\\")\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Method\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"For terminal nodes:\\n  Node content (name, e.g. getMaxInt) and node type are both\\n  split up based on camel casing, resulting in two matrices.\\n\\nFor internal nodes, the mode typs is used as a feature (no splitting)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Short path (t, p, n): path p from terminal node t to internal node n with >= 2 children.\\nPath pair (t_s, p_s, t_e, p_e): Two short paths with same internal node \\nSpan of a path pair: Let c_k denote the k-th child of the shared internal node of the two\\n                      short paths. Suppose p_s leads through c_i and p_e leads through c_j.\\n                      Then the span of the path pair is defined as j - i\\nLength of a pair path: |p_s| + |p_e| + 1\\nNumber of shor paths is reduced by limiting length and span.\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Whole program\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"For terminal nodes:\\n  Node content (name, e.g. getMaxInt) and node type are both\\n  split up based on camel casing, resulting in two matrices.\\n\\nFor internal nodes, the mode typs is used as a feature (no splitting)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Short path (t, p, n): path p from terminal node t to internal node n with >= 2 children.\\nPath pair (t_s, p_s, t_e, p_e): Two short paths with same internal node \\nSpan of a path pair: Let c_k denote the k-th child of the shared internal node of the two\\n                      short paths. Suppose p_s leads through c_i and p_e leads through c_j.\\n                      Then the span of the path pair is defined as j - i\\nLength of a pair path: |p_s| + |p_e| + 1\\nNumber of shor paths is reduced by limiting length and span.\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"A network with a learnable embedding layer and 5 FNN layers is used\\nto learn node embeddings. \\nGiven the parent node type and the top-4 immediate child node types,\\npredict the node type itself.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"AST Nodes are sequenced using \\ndepth first traversal.\\n\\nFed into the following network:\\nEmbedding Layer \\nLSTM\\nLSTM \\nFNN w/ ReLU \\nFNN w/ Linear\\n\\nGoal is to predict the \\\"essential complexity\\\",\\na proxy task of predicting a metric associated \\nwith vulnerabilities. \\n\\nThe outputs of the last LSTM layer are used as \\ngraph representations.\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"AST is linearised using depth first traversal\\nto obtain sequence of tokens.\\n\\nTokens are encoded using word2vec\\n\\nSequence used as input for following network: \\nLSTM\\nGlobal Max Pooling\\nFNN Layer w/ tanh\\nFNN Layer w/ linear \\nFNN Layer w/ sigmoid\\n\\nafter training, the last two layers are removed \\nin order to obtain function level representations.\\n\\nThe network is trained on the vulnerability \\ndetection task. After training, it is used for embedding.\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"javascript\"\n    }\n  ],\n  \"vertex-type\": \"ast node (trimmed)\",\n  \"edge-type\": \"ast edge\",\n  \"vertex-features\": \"node type one-hot\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified (presumably adjacency matrix)\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast (trimmed)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"method\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Tokens are split into subtokens\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Child Edge\",\n      \"details\": \"Regular AST Edge\"\n    },\n    {\n      \"name\": \"Next Token Edge\",\n      \"details\": \"NCS\"\n    },\n    {\n      \"name\": \"Subtoken Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Last Lexical Use Edge\",\n      \"details\": \"Connect identifiers to their most recent use\"\n    }\n  ],\n  \"vertex-features\": \"Not specified how initial node features are computed\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast + sub-tokens w. ast/ncs/data dependence/sub-token"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"method\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Node content is encoded using Word2Vec\\n\\nNote that all nodes, even e.g. BlockStm, are considered \\nto contain a text payload (e.g. \\\"{}\\\")\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"For every graph, the minimum set of long paths covering \\nall nodes in the AST is computed.\\nHere, a long path is a path from one leaf node to another,\\nvia the root, possibly sharing one or multiple nodes along \\nthe path.\\n\\nDuring the generation of training data,\\nIf a long path contains a node which was present in a \\nbug/vulnerability fix, all embeddings in the path\\nare multiplied by a weight w.\\n\\nFor the GRU model, the nodes in a long path are seen \\nas a sequence of token.\\n\\nFor the CNN model, the nodes in a long path are combined \\ninto a matrix.\\n\\nJoint model, with two parallel paths:\\n  1) Attention-based GRU layer\\n  2) Attention-based CNN layer followed by FNN\\nBoth paths are combined w/ a multi-head attention layer. \\n\\nThis method is used to encode every path into a (local) vector.\\n\\nFor every long path, the nodes in the PDG and DFG (partially) \\ncovered by the long path are extracted, and formed into two matrices.\\nThese matrices (global) are multiplied with the local vector and \\nthen concatenated in order to obtain a vector \\nwith both local and global information for each path.\\n\\nThe vectors for each path are then concatenated in order to obtain a\\nmatrix representing the entire method, with additional global information.\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"methods\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Continuous Binary Tree\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"Obtained by taking the continuous binary tree \\nrepresentation of the AST (root), and passing\\nit to a VAE.\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Every node has three attributes:\\nx: Depth \\ny: left-to-right sequential position of its parent in the layer\\nz: left-to-right sequential position among its siblings (-1 for lexical nodeS)\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"(x, y, z), and the code token itself (type or token)\",\n  \"edge-features\": \"\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Tokenised code is used as a feature, where each token is enhanced with positional information\\n\\nThe comment generated thus far (in token form) is also used as an input.\\nEach token is enhanced with positional information describing its location in the sequence.\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Every node has three attributes:\\nx: Depth \\ny: left-to-right sequential position of its parent in the layer\\nz: left-to-right sequential position among its siblings\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"Each edge has the (x, y, z) attribute as its destination node as attributes\"\n    }\n  ],\n  \"vertex-features\": \"(x, y, z), and the token payload (type or token)\\nNote: vertices are used on their own, not as part of a graph\",\n  \"edge-features\": \"(x, y, z), and the pair of token payloads (type or token) of the nodes it is connecting \\nNote: edges are used on their own, not as part of a graph\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"The comment generated thus far (in token form) is also used as an input.\\nEach token is enhanced with positional information describing its location in the sequence.\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Some node types are discarded, others are kept\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"Seen as undirected\"\n    }\n  ],\n  \"vertex-features\": \"Node \\\"strings\\\" mapped to numerical vectors; unclear what this means exactly\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast (trimmed)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"The information in a node is divided into three \\\"perspectives\\\":\\nPerspective 0: node type    (e.g. \\\"MethodDeclaration\\\")  \\nPerspective 1: Node value   (e.g. Method name)\\nPerspective 2: Additional Information (e.g. Method visibility)\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Literals are generalised. \\nNames are split up based on camel case naming,\\nregardless of perspective.\\n\\nAn unsupervised training procedure is used to encode node types.\\nThe training is essentially equivalent to word2vec training \\n(with negative sampling), but the neighbourhood of tokens is \\ndetermine using certain structural patterns in the AST.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"First, node features are computed. \\nThen, all node embeddings are put into a linear sequence to obtain a matrix.\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Tokens are split into subtokens with separate nodes\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"undirected\"\n    }\n  ],\n  \"vertex-features\": null,\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Tokenised Code is also used as input.\\n\\nPrevious summary tokens are also given as input\"\n}",
      "new": "ast + sub-tokens"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"User-defined names are normalised (e.g. METHOD1, VAR3)\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"directed\"\n    }\n  ],\n  \"vertex-features\": \"Node type is encoded on an ordinal scale,\\nwhere a type has a higher number if it occurs \\nmore frequently.\\nRarely occurring type are assigned the number 0.\\n\\nLexical content of nodes is encoded by taking \\nthe average of the word2vec values of the tokens in the node.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Stacked adjacency tensor.\\n\\nFor every graph, the adjacency matrix is determined.\\nThe four matrices are then combined into a third order tensor.\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"directed\"\n    }\n  ],\n  \"vertex-features\": \"Node type and Node payload tokens are encoded using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Stacked adjacency tensor.\\n\\nFor every graph, the adjacency matrix is determined.\\nThe four matrices are then combined into a third order tensor.\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"directed\"\n    }\n  ],\n  \"vertex-features\": \"Node type and Node payload tokens are encoded using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Stacked adjacency tensor.\\n\\nFor every graph, the adjacency matrix is determined.\\nThe four matrices are then combined into a third order tensor.\\n\\nSelf connections are added to all graphs\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Computed using word embeddings\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"For terminal nodes, content (names) and type \\nare both split up.\\n\\nFor non-terminal nodes, the mode typs is used as a feature (no splitting)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Cross block paths are extracted, \\nwhere a cross block path is a path from one \\nterminal node to another terminal node,\\nwhere the top node of the path defines a block\\nstructure (e.g. if block), and both nodes \\nare nested under said top node,\\nOR\\nthe left and right paths belong to two\\ndifferent parallel block structures \\n(e.g. two consecutive blocks nested in a block).\\nCertain amount of paths is sampled.\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Node types are used as features (encoded using embedding layer)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Pre-order traversal sequence of node types\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"The string represented by each node is embedded using word embeddings,\\nto obtain a matrix per node.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"for GGNN model:\\n  Three separate mechanics:\\n  1) Ordinal encoding of node type\\n  2) Ordinal encoding of node type + Ordinal encoding of the tokens in the node \\n  3) Ordinal encoding of node type + average word2vec encoding of tokens in the node\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"For the LSTM model:\\n  1) tokenisation,\\n      abstraction of literaturs,\\n      removal of uncommon identifiers, \\n      splitting snake and camel case into separate words\\n  2) Converting into a stream of tokens\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Code tokens (in sequence) are also used as separate input.\\n\\nComment generated thus far (in tokens) is also given as input.\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"All paths from the root to a terminal node are extracted, where\\n  1) the root has a value (content), 2) the leaf has a value (content), 3) the other nodes only have types.\\n\\n  Types are one-hot encoded.\\n\\nPreviously generated tokens are also given as input.\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"The AST is traversed (depth first order), and the resulting sequence of \\nAST node is used as the AST representation (types for internal nodes,\\ntokens for leaf nodes)\\n\\nThe original sequence of code tokens is also used as a feature\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Traverse AST in BFS order.\\nFor every node, output the pair (parent payload, node payload).\\n\\nThe resulting text is then tokenized (four different ways; see paper for details).\\n\\nFor BOW models, the tokens are used to compute a BOW representation \\n(4 different ways; see paper for details).\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"one-hot encoding of node type\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Next Token Edge\",\n      \"details\": \"NCS\"\n    },\n    {\n      \"name\": \"Last Lexical Use Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Unclear how nodes are encoded\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w/ ast/ncs/data dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"undirected\"\n    }\n  ],\n  \"vertex-features\": \"Tokens encoded using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Source code comments\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Not specified (unclear how node embeddings are initialised)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"smart contract\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"AST is normalised (normalise identifiers), serialized (depth first order), and encoded using word2vec\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": null\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Token representation of the code is used as feature\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"commit / diff + full files (old / new versions)\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": null,\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"methods from diff are extracted. AST is computed for old and new versions.\\nterminal to terminal paths in the ASTs are computed. Paths present \\nin both old and new version are discarded. \\nFor the terminal nodes, tokens are features. \\nThe path itself (sequence of types, interlaced with up/down directions) are also features (i.e. a full path is a single feature)\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"function -- python\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"node type one-hot\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast (some node types are removed)\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"not content (embedded by model)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast (trimmed)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"Not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"code tokens are used as feature\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"javascript\"\n    }\n  ],\n  \"vertex-type\": \"ast (nonterminal nodes only)\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"continuous binary tree\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast (syntax nodes only)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"AST linearised through pre-order traversal. (node types for internal, payload for leafs)\\n\\nTwo matrices are extracted:\\n  1) Shortest path distance matrix where M_{ij} denotes the signed length of the shortest path between node i and j, provided it is less than some threshold p ($\\\\infty$ otherwise)\\n  2) Sibling distance matrix where M_{ij} denotes the signed distance between siblings i and j. $\\\\infty$ if exceeding some threshold\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"extract arbitrary paths (no specific end node types) from AST,\\nwith filtering based on path length and width (i.e. max distance between sibling nodes used in the same path)\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"node type and tokens are used as features\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"certain sub-trees are extracted from the AST based on node type. Note that these are used as \\\"labels\\\"; the full AST is used as input.\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"nodes encoded using continuous binary tree\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"text and type\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"token in AST nodes w/ sub-token splitting (embedding not specified)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"pre-order traversal. At every statement (composite) node, tree is split into sub-trees.\\n\\nCode is used as a feature\"\n}",
      "new": "ast + sub-token"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"type (based on image)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"In all instances, identifiers are split into sub-tokens \\n\\nsource code is used as feature.\\n\\nAST is linearised (using brackets to make process reversible; structure based traversal)\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"type and value (EMPTY value for internal nodes)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"AST linearised using depth first traversal.\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": null,\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Various matrices are derived from the AST:\\n  1) Shortest path length; M_{ij} denotes the shortest path length from node i to node j (assuming undirected nodes)\\n  2) Ancestor distance; D_{ij} denotes the signed distance between \\\"familial\\\" nodes i and node j in the ast\\n  3) Sibling Distance; D_{ij} denotes the signed distance between sibling nodes i and node j in the ast\\n  4) Personalised PageRank scores \\nAll matrices are \\\"encoded\\\" by applying sinusoidal encoding to them. \\n\\nEvery token in the input is associated with an AST node (for the positional encoding).\\nAST node type is added to the token.\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Sequence of nonterminal rule expansions used to \\nfrom free (depth first, left-to-right order), is used as feature\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"Based on bag of graphs (Silva et al.)\\n\\nFirst, authors define Nodes of Interest (NOIs).\\nThese NOIs are used to capture three types of GOIs:\\n\\n1) NOI w/ source code text \\n2) Trees with the NOI as their root\\n3) Shortest path from AST root to the NOI\\n\\nFor each GOI, concatenate all node payloads (text) and hash them. \\n\\nNext, for each NOI, generate a feature vector of all GOI corresponding\\nto the NOI by concatenating the hashes. \\n\\nSince number of NOI is variable, sample a fixed number through \\nrandom sampling with replacement. \\n\\nCluster vectors using K-means.\\n\\nGenerate graph features by creating a histogram of how many \\nNOI of each type (cluster) are present in the graph.\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"one-hot encoding of AST node type\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": null,\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"pairs of source code for training (diff)\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast (bidirectional) / siblings\",\n  \"vertex-features\": \"not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"sequence of edit actions to transform first AST into the other\"\n}",
      "new": "ast w. ast/sibling"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"pairs of source code for training\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"node type one hot\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"some amount of edits must already have been applied\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"1) node type is a feature\\n2) terminals have tokens, split into subtokens \\n3) Each token has its index among its siblings as feature\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Each edit is represented as a path, e.g. \\n1) A MOVE is represented as a path from the root of the subtree being moved, to its new location (eg its left-most sibling)\\n2) UPDATE, INSERT, DELETE have similar path representations.\\n\\nSpecifically, two sets are created: 1) the set of applied edits, 2) the set of all possible edits.\\nBoth are separately encoded\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Abstract Semantic Graph\",\n  \"description\": \"Graph with Control and Data Flow Information\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Smart Contracts\"\n    }\n  ],\n  \"vertex-type\": \"statement\",\n  \"edge-type\": \"control flow/data flow\",\n  \"vertex-features\": \"not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "statement w/ control flow/data flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Augmented AST\",\n  \"description\": \"AST augmented with additional edges\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"method\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"Undirected\"\n    },\n    {\n      \"name\": \"Computed From\",\n      \"details\": \"Undirected\"\n    },\n    {\n      \"name\": \"Last Use\",\n      \"details\": \"Undirected\"\n    },\n    {\n      \"name\": \"Returns To\",\n      \"details\": \"Undirected; Node in return statement points to the return type declaration in a method\"\n    },\n    {\n      \"name\": \"Next Token Edge\",\n      \"details\": \"Undirected; Connect nodes on the same level in sequential order (perhaps not named to aptly)\"\n    }\n  ],\n  \"vertex-features\": \"Not specified\",\n  \"edge-features\": \"When I say undirected, I mean back-edges are added\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Summary generated thus far (in tokens) is also given as input\"\n}",
      "new": "ast w/ ast/control dependence/data dependence/ncs"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Augmented AST\",\n  \"description\": \"AST w/ additional edges\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast/shared subtoken nodes (one for each unique subtoken) [vocab node]\",\n  \"edge-type\": \"ast/sibling/control flow/data flow\",\n  \"vertex-features\": \"token for vocab nodes, type for ast nodes\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w/ ast/sibling/control flow/data flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Augmented AST\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"Undirected\"\n    },\n    {\n      \"name\": \"Next Token Edge (NCS)\",\n      \"details\": \"Undirected\"\n    },\n    {\n      \"name\": \"Computed From\",\n      \"details\": \"Undirected\"\n    },\n    {\n      \"name\": \"Last Read\",\n      \"details\": \"Undirected; connect use of variable to all possible moments of last read\"\n    },\n    {\n      \"name\": \"Last Write\",\n      \"details\": \"Undirected; connect use of variable to all possible moments of last write\"\n    },\n    {\n      \"name\": \"Returns To\",\n      \"details\": \"Undirected; Node in return statement points to the return type declaration in a method\"\n    },\n    {\n      \"name\": \"Last Scope Use\",\n      \"details\": \"Undirected; point variable to previous use in the scope\"\n    },\n    {\n      \"name\": \"Last Field Lex\",\n      \"details\": \"Undirected; Connect field access to the last of use said field\"\n    },\n    {\n      \"name\": \"Field\",\n      \"details\": \"Undirected; point field access to the point the field was declared\"\n    }\n  ],\n  \"vertex-features\": \"node type is one-hot encoded\",\n  \"edge-features\": \"edge type is one-hot encoded\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"Global graph state is one-hot encoded (unclear what is)\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w/ ast/ncs/control flow/data dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Augmented Code Property Graph\",\n  \"description\": \"Code property graph, including call information\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"file\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Three main attributes; 1) node type, 2) node code, 3) node location \\n\\nNodes are pruned:\\n1) Nodes with syntactic elements which are characteristics of certain bugs are selected\\n2) All nodes making up the statements these nodes are part of are selected \\n3) all nodes making up statements with data and call relationships to these statements are selected.\\n4) For all selected nodes, a nearest neighbour set is computed \\n5) All selected nodes are kept \\n\\nThe result is multiple possible graphs per file.\\nFurthermore, each graph is associated with a certain defect type.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"Every edge has three main attributes; 1) source node, 2) destination node, 3) edge type\\nNote that the node type is actually one of 24 possible types (the four shown here is a simplification)\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"Every edge has three main attributes; 1) source node, 2) destination node, 3) edge type\\nNote that the node type is actually one of 24 possible types (the four shown here is a simplification)\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"Every edge has three main attributes; 1) source node, 2) destination node, 3) edge type\\nNote that the node type is actually one of 24 possible types (the four shown here is a simplification)\"\n    },\n    {\n      \"name\": \"Call Edge\",\n      \"details\": \"Every edge has three main attributes; 1) source node, 2) destination node, 3) edge type\\nNote that the node type is actually one of 24 possible types (the four shown here is a simplification)\"\n    }\n  ],\n  \"vertex-features\": \"The tokens in the node value are encoded using word2vec,\\nand combined using kernel PCA.\\n\\nnode type is embedded using integer,\\n\\nThe two embeddings are concatenated.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"(sparse) adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w/ ast/calls/control flow/data flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Augmented Socio-Technical Graph\",\n  \"description\": \"Graph spanning and combining multiple repositories\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Repository (including pull requests)\"\n    },\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"File\"\n    },\n    {\n      \"name\": \"User Data\",\n      \"details\": \"Comments\"\n    },\n    {\n      \"name\": \"Work Items\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Pull Request\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Work Item\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Author\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Reviewer\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"File\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Repository\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Token\",\n      \"details\": \"Tokens occurring in e.g. pull requests\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"creates\",\n      \"details\": \"author creates a pull request\"\n    },\n    {\n      \"name\": \"reviews\",\n      \"details\": \"created between reviewer and pull request\"\n    },\n    {\n      \"name\": \"contains\",\n      \"details\": \"repository contains pull request\"\n    },\n    {\n      \"name\": \"changes\",\n      \"details\": \"pull request changes file\"\n    },\n    {\n      \"name\": \"linked to\",\n      \"details\": \"pull request linked to work item\"\n    },\n    {\n      \"name\": \"comments on\",\n      \"details\": \"between pull request and reviewer\"\n    },\n    {\n      \"name\": \"parent of\",\n      \"details\": \"between work item nodes\"\n    },\n    {\n      \"name\": \"Token Edge\",\n      \"details\": \"Edge between e.g. a pull request and a token,\\nor between two tokens based on pointwise mutual information.\"\n    }\n  ],\n  \"vertex-features\": \"Information is one-hot encoded (?)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "pull requests/work items/author/reviewer/source  code file/repository/tokens in prs -- w. -- creates/reviews/contains/changes/li nked to/comments on/parent of /token edge"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"CAG (Code Aggregate Graph)\",\n  \"description\": \"Combination of AST, CFG, PDG (Program Dependence Graph), DT (Dominator Tree), and PDT (Post-dominator Tree)\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Seemingly method level\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge (Tree labels; true, false, empty)\",\n      \"details\": \"Edge from one statement ot other statements that may directly follow it\"\n    },\n    {\n      \"name\": \"Dominator Edge\",\n      \"details\": \"Edge from a node to every node that it dominates\"\n    },\n    {\n      \"name\": \"Post-dominator Edge\",\n      \"details\": \"Edge from a node to every node that is post-dominates\"\n    },\n    {\n      \"name\": \"Data Dependence Edge\",\n      \"details\": \"Edge from variable declaration to all its uses\"\n    }\n  ],\n  \"vertex-features\": \"Code statement and node type are encoded using FastText \\n\\nThis is concatenated with a one-hot encoding of the node type.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/control flow/data dependence/dominator/post dominator"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"CAG (Code Aggregate Graph)\",\n  \"description\": \"Combination of AST, CFG, PDG (Program Dependence Graph), DT (Dominator Tree), and PDT (Post-dominator Tree)\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Seemingly method level\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge (Tree labels; true, false, empty)\",\n      \"details\": \"Edge from one statement ot other statements that may directly follow it\"\n    },\n    {\n      \"name\": \"Dominator Edge\",\n      \"details\": \"Edge from a node to every node that it dominates\"\n    },\n    {\n      \"name\": \"Post-dominator Edge\",\n      \"details\": \"Edge from a node to every node that is post-dominates\"\n    },\n    {\n      \"name\": \"Data Dependence Edge\",\n      \"details\": \"Edge from variable declaration to all its uses\"\n    }\n  ],\n  \"vertex-features\": \"Code statement and node type are encoded using GloVe\\n\\nThis is concatenated with a one-hot encoding of the node type.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/control flow/data dependence/dominator/post dominator"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"CAG (Code Aggregate Graph)\",\n  \"description\": \"Combination of AST, CFG, PDG (Program Dependence Graph), DT (Dominator Tree), and PDT (Post-dominator Tree)\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Seemingly method level\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge (Tree labels; true, false, empty)\",\n      \"details\": \"Edge from one statement ot other statements that may directly follow it\"\n    },\n    {\n      \"name\": \"Dominator Edge\",\n      \"details\": \"Edge from a node to every node that it dominates\"\n    },\n    {\n      \"name\": \"Post-dominator Edge\",\n      \"details\": \"Edge from a node to every node that is post-dominates\"\n    },\n    {\n      \"name\": \"Data Dependence Edge\",\n      \"details\": \"Edge from variable declaration to all its uses\"\n    }\n  ],\n  \"vertex-features\": \"Code statement and node type are encoded using Word2Vec (CBOW)\\n\\nThis is concatenated with a one-hot encoding of the node type.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/control flow/data dependence/dominator/post dominator"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"CDFG (Control-Data Flow Graph)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"IR instructions and types\",\n      \"details\": \"Variable names are replaced with their type\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Sequential IR flow\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data flow\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control flow\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Vertex payload (instruction, token, node type) is encoded using Word2Vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"For every edge type, a separate adjacency matrix is created, where \\nback-edges are added for every edge (i.e. the adjacency matrix is symmetric).\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ir instructions + types w. control flow/data flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"CDFG + CALL + MEM\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"LLVM IR Instructions\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"MEM Edge\",\n      \"details\": \"Store/load dependencies\"\n    },\n    {\n      \"name\": \"CALL Edge\",\n      \"details\": \"Dependencies to return values of functions\"\n    }\n  ],\n  \"vertex-features\": \"n/a (used embedding layer)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "instructions w. control flow/call/data flow/data dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"CFG\",\n  \"description\": \"Control flow graph extracted from the bytecode of a smart contract\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"smart contract\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Entry Point\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"New Variable\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"If\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Expression\",\n      \"details\": \"assignment without declaration\"\n    },\n    {\n      \"name\": \"EndIf\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Return\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"True Branch Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"False Branch Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"TF/IDF weighted sum of the Word2Vec embeddings in the opcodes of a node\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "cfg"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"CFG\",\n  \"description\": \"To avoid confusion, remember that the artefacts in the \\n\\\"artefacts\\\" section are not related _beforehand_, but their\\nrelatedness must be predicted\",\n  \"artefacts\": [\n    {\n      \"name\": \"Bug report\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"Every function in a source file has its own PDG\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Statements in nodes are encoded using CodeBERT.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Source code text is also used as input.\\n\\nBug report text is cleaned up (e.g. formatting removal)\"\n}",
      "new": "cfg (statement)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"CFG\",\n  \"description\": \"To avoid confusion, remember that the artefacts in the \\n\\\"artefacts\\\" section are not related _beforehand_, but their\\nrelatedness must be predicted\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"files\"\n    },\n    {\n      \"name\": \"Bug Report\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Punctuation in statements is removed, names are broken up,\\ntokens are encoded using word2vec, and put into a matrix.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Bug reports are preprocessed (standard NLP steps),\\nand encoded as matrix of word vectors using word2vec\"\n}",
      "new": "cfg (statement)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"CFG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"PHP files\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Content of statement nodes is tokenized\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Original source code snippet is parsed into a sequence of tokens.\"\n}",
      "new": "cfg (statement)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"CFG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"basic block\",\n  \"edge-type\": \"control flow\",\n  \"vertex-features\": \"basic block encoded using doc2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "cfg (basic block)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"CFG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Basic Block\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"The instructions in basic clock are one-hot encoded\\nto obtain a matrix per node.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "cfg (basic block)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"CFG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Basic Block\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/ a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"The node centrality is computed for every node.\\nThis centrality is \\\"assigned\\\" to every token in the node.\\nThe centralitities of the same token in different blocks are summed.\\nThese tokens are encoded using word2vec; \\nThe word vectors are multiplied with the summed node centrality.\\nThis sequence is used as the model input.\"\n}",
      "new": "cfg (basic block)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"CFG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"Edges sometimes have labels, e.g. labelled \\\"true\\\" or \\\"false\\\" for conditionals\"\n    }\n  ],\n  \"vertex-features\": \"Tokens in node encoded using word2vec\",\n  \"edge-features\": \"Encoded using word2vec (0 padded if empty)\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "cfg (statement)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"CFG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"php\"\n    }\n  ],\n  \"vertex-type\": \"basic block\",\n  \"edge-type\": \"control flow\",\n  \"vertex-features\": \"vector of counts of occurrences of certain ast node types in the ast sub-tree of the basic block\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "cfg (basic block)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"CFG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"smart contract\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Basic Block  (statement)\",\n      \"details\": \"consecutive operations without jump\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Encode statements using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "cfg (statement)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"CFG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": null\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"See AST\"\n}",
      "new": "cfg (statement)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"CFG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"file\"\n    }\n  ],\n  \"vertex-type\": \"statement\",\n  \"edge-type\": \"control flow\",\n  \"vertex-features\": \"tokens in statement\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Bug report is also used as feature \"\n}",
      "new": "cfg (statement)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"CFG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"first compiled to bytecode\"\n    }\n  ],\n  \"vertex-type\": \"instruction\",\n  \"edge-type\": \"control flow (incl. function calls)\",\n  \"vertex-features\": \"things like instruction name and operands\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified / n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "cfg (instruction)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"CFG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"javascript\"\n    }\n  ],\n  \"vertex-type\": \"basic block\",\n  \"edge-type\": \"control flow\",\n  \"vertex-features\": \"random vectors\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "cfg (basic block)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"CFG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"method\"\n    }\n  ],\n  \"vertex-type\": \"basic block (statement)\",\n  \"edge-type\": \"control flow\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"A matrix of features is associated with every method.\\nThree types of entities are present in the graph:\\n1) variables -- features: type, modifiers, additional info (3x one-hot)\\n2) basic blocks (relationship between variable and basic block) -- state: statement type (one-hot)\\n3) variable relationships in blocks [data flow]: 43D vector \\n\\n\\\"pilar\\\" A_{ij} in the feature matrix (actually a tensor) records the \\nrelationships between {block,variable}-i and {block,variable}-j;\\nthe contents in the pilar is either (1), (2), or (3), depending on the\\ntypes of i and j.\"\n}",
      "new": "cfg (statement)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"CFG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"statement\",\n  \"edge-type\": \"control flow\",\n  \"vertex-features\": \"encoded using doc2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified explicitly, presumably adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"source code text is used as feature\"\n}",
      "new": "cfg (statement)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"CFG\",\n  \"description\": \"slightly altered compared to normal; different types of nodes\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Operation in Source code\",\n      \"details\": \"including standard operations, function calls, returns\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"PosNext\",\n      \"details\": \"Conditional Jumps in loops or branches.\"\n    },\n    {\n      \"name\": \"NegNext\",\n      \"details\": \"Conditional Jumps in loops or branches.\"\n    },\n    {\n      \"name\": \"IterJump\",\n      \"details\": \"Connect end of loop to begin\"\n    },\n    {\n      \"name\": \"CallNext\",\n      \"details\": \"From function call operation to first operation in called function\"\n    },\n    {\n      \"name\": \"ReturnNext\",\n      \"details\": \"From last operation in called function to operations right after function call\"\n    },\n    {\n      \"name\": \"Next\",\n      \"details\": \"Denote most common execution order\"\n    }\n  ],\n  \"vertex-features\": \"Operation/operand types are one-hot encoded\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "cfg (but nodes represent operations in the code, incl. function calls and return)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"CPG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/control flow/control dependence/data dependence\",\n  \"vertex-features\": \"node content doc2vec or tf/idf (two different approaches were experimented with)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/control flow/control dependence/data dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"CPG+\",\n  \"description\": \"Code property graph with NCS edges\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Natural Code Sequence Edge (NCS)\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Tokenize, normalize names, average word2vec vector of all tokens per node.\\nConcatenate that with node type encoded as integer.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/control flow/control dependence/data dependence/ncs"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Change Impact Graph\",\n  \"description\": \"create full graphs (according to vertex/edge types) of old and new code; slice based on changed lines; two input graphs/commit\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"diff\"\n    }\n  ],\n  \"vertex-type\": \"variables/statements/method/classes/package (entities at different levels)\",\n  \"edge-type\": \"data dependence/control dependence/program relations (package member, overwrite, implement, inherit, initialize, data member, param in, param out, etc)\",\n  \"vertex-features\": \"node2vec + one hot node type\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"syntax change type (extracted using ChangeDistiller) is also given as input (encoding unclear)\"\n}",
      "new": "program elements at different levels (variables, statements, methods, classes, packages) w. control dependence/data dependence/program relations (e.g. inherit)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Class Dependency Network (CDN)\",\n  \"description\": \"Serves as the \\\"larger\\\" context (``external features'') for the file.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Files/project\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Class\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Dependency\",\n      \"details\": \"Inheritance/implementation, fields (A has field of type B), method invocation (A calls method of B)\"\n    }\n  ],\n  \"vertex-features\": \"Various static code analysis metrics (e.. LOC, afferent coupling, CBO)\\nNetwork metrics generated using node2vec.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "class/interface dependency network"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Class Dependency Network (CDN)\",\n  \"description\": \"Serves as the \\\"larger\\\" context for the file.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Files/project\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Class\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Dependency\",\n      \"details\": null\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"Graph encoded using node2vec\",\n  \"other-features\": \"n/a\"\n}",
      "new": "class/interface dependency network"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Class Dependency Network\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"project\"\n    }\n  ],\n  \"vertex-type\": \"class\",\n  \"edge-type\": \"class or interface dependencies and relationships\",\n  \"vertex-features\": \"nodes are embedded using node2vec.\\n\\nnodes are also annotated with various static code metrics (e.g. # methods)\\n\\nNodes are also annotated with various network metrics.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not explicitly specified, but seems to be adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "class/interface dependency network"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Class Dependency Network\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"project\"\n    }\n  ],\n  \"vertex-type\": \"class\",\n  \"edge-type\": \"class/interface relationships\",\n  \"vertex-features\": \"nodes are embedded using node2vec.\\n\\nTraditional software engineering metrics (e.g. CBO) are used as features.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "class/interface dependency network"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Class network\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"project\"\n    }\n  ],\n  \"vertex-type\": \"class\",\n  \"edge-type\": \"class dependencies (calling relations)\",\n  \"vertex-features\": \"1) Internal node features (e.g. number of methods in class)\\n2) External node features (e.g. out degree, centrality; classical non-global network metrics)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "class/interface dependency network"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Co-occurrence Graph\",\n  \"description\": null,\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Source code is first sliced based data (parameters)\\npassed to \\\"dangerous\\\" functions.\\nNames are standardised.\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Token in snippet\",\n      \"details\": \"Every unique token gets a single node\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Edge\",\n      \"details\": \"Every token is connected to every other token that \\noccurs within 2 tokens of itself in the \\noriginal source code.\"\n    }\n  ],\n  \"vertex-features\": \"Tokens are embedded using a word embedding (not further specified)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Pointwise mutual information between different tokens is computed\\nto compute up with a weighted adjacency matrix.\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Tokens are embedded using a word embedding (not further specified),\\nin sequence as input for the GRU model\"\n}",
      "new": "token w. token sliding window"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Code Change Genealogy\",\n  \"description\": \"Graph representing the dependencies between code changes. \\nRoughly speaking, a code change is related to the previously \\nmost recent related code change, for some definition \\nof relatedness. For instance, when a call to a method is added,\\nthe change may be related to the last change modifying \\n(the signature of) said method.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code Changes\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Code Change\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Change Dependency Edge\",\n      \"details\": \"According to the rules of Herzig et al.\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Random walks over the graph are used.\\nA random walk produces a sequence of nodes,\\nwhich can be seen as a sentence. \\nA collection of random walks thus makes for a corpus of \\\"sentences\\\",\\nsimilar to what word2vec was trained on.\\n\\nFor the semantic-model task, the changed tokens (as a sequence)\\nper change are also included as features.\"\n}",
      "new": "code change genealogy (code change w/ change dependency)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Code Composite Graph (CCG)\",\n  \"description\": \"Mix of AST, CFG, and DFG\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Node token encoded using word2vec\\nNode type encoded using label encoding \\nBoth encodings are concatenated\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/control flow/data flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Code Property Graph\",\n  \"description\": \"AST augmented with control and data flow information.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code (arbitrary snippets)\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"Points from one statement node to every other statement node which can immediately follow it.\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"Declaration node points to all statement nodes using the declared variable.\"\n    }\n  ],\n  \"vertex-features\": \"1) Collect node types and tokens (snippets from leaf nodes) by traversing the network\\n2) Train Word2Vec on the corpus of node types and tokens, and project all to d-dimensional space\\n3) Concatenate the embeddings for the node type and lexical tokens. For nodes without lexical tokens, use the zero vector.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/control flow/data flow (cpg)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Code Property Graph\",\n  \"description\": \"Slicing is applied based on vulnerable functions and vulnerable data\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"smart contracts\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Tokens encoded using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"9 handcrafted expert features are used\"\n}",
      "new": "ast w. ast/control flow/control dependence/data dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Code Property Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Some AST nodes, specifically those without \\nchild nodes and only contain AST edges,\\nare pruned.\\n\\nContent of AST nodes is simplified. \\nIn particular, user defined names are \\nreplaced with standardised placeholders.\\nExamples: F<i> for functions, V<i> for variables.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Payload of node encoded using Word2Vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/control flow/control dependence/data dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Code Property Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Concatenate word2vec embeddings of tokens\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Nodes are sequenced in a way preserving \\ntoken order from original code;\\nCorresponding feature vectors now \\nform a sequence of feature vectors\"\n}",
      "new": "ast w. ast/control flow/control dependence/data dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Code Property Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Node content is used as feature\",\n  \"edge-features\": \"Edge type is used as feature\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"For a given code sample c, the most similar _known_\\n(code, summary) sample (c', s') is used as features,\\nwhere c' is also represented using a graph.\"\n}",
      "new": "ast w. ast/control flow/control dependence/data dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Code Property Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Node type is encoded as a scalar \\nTokens in a node are embedded using word2vec; vectors per token are averaged \\nnode type and payload embedding are concatenated\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix (?)\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/control flow/control dependence/data dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Code Property Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Node type is one-hot encoded \\nSource code is encoded by summing word2vec vectors of all tokens in the fragment \\nThe two encodings are concatenated\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix (?)\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/control flow/control dependence/data dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Code Property Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Node type one-hot encoded\\nStatement fragments/tokens encoded using word2vec \\none-hot and word2vec embeddings are concatenated\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/control flow/control dependence/data dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Code Property Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"tag; node type/role -- one hot encoded op; encoding for some program operations (e.g. conditional, jump) -- one hot encoded func; reflects relationship with specific functions -- one hot encoded lite; describes involved parameters -- one hot encoded type; type parameter in C/C++ (16 fixed options) -- one hot encoded\\nNode tokens encoded using Word2vec\\nall features are concatenated\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix (?)\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/control flow/control dependence/data dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Code Property Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Node type is encoded as a scalar \\nTokens in a node are embedded using word2vec; vectors per token are averaged \\nnode type and payload embedding are concatenated\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix (?)\",\n  \"graph-features\": \"Graph is rendered as an image.\\nEach node has sa different colour,\\nand has the line number of its corresponding statement as its content. \\nDifferent edge types have different colours and line types.\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/control flow/control dependence/data dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Code Property Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/control flow/control dependence/data dependence\",\n  \"vertex-features\": \"1) node type one hot \\n2) operator type one hot \\n3) used API functions, binary encoding \\n4) float and integer literals are included as their 32 bit representation \\n5) type of variables are included, one-hot encoded\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/control flow/control dependence/data dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Code Property Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": null\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/control flow/control dependence/data dependence\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Features are represented as a 3D tensor, where the first two dimensions \\nrepresent nodes, and the third dimension represents features describing\\nthe relation between the two nodes.\\n\\nThese features include data type/modifier information,\\noperators between the two nodes, the parent child relationship between the two nodes (i.e. is_parent(i, e), with a one-hot entry for the node type of the child),\\ncontrol flow node information.\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/control flow/control dependence/data dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Code Relationship Graph (CRG)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"Method\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Tokens are decomposed into sub-tokens\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Child\",\n      \"details\": \"AST Edge\"\n    },\n    {\n      \"name\": \"Next Token\",\n      \"details\": \"NCS\"\n    },\n    {\n      \"name\": \"Last Use\",\n      \"details\": \"Connect variable to all possible last uses\"\n    },\n    {\n      \"name\": \"Computed From\",\n      \"details\": \"Connect expression node to all variables occurring in it\"\n    },\n    {\n      \"name\": \"Return To\",\n      \"details\": \"Connect return tokens to method declaration\"\n    },\n    {\n      \"name\": \"Subtoken Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Not explicitly specified what is encoded/used as features, but \\nfigures suggest node type for internal node, and content (tokens) for other nodes.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Token sequence is used as input.\"\n}",
      "new": "ast + ssub-tokens w. ast/ncs/data dependence/control flow/sub token"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Code Semantic Representation Graph (CSRG)\",\n  \"description\": \"AST with data flow information\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code with docstring\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"Directed edges are added between leaf nodes \\\"to determine branch statements in the AST\\\" (NOT NCS)\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Node representations computed using DeepWalk\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Code and summary/query are tokenised and put into a sequence,\\nand tokenised using FastText\"\n}",
      "new": "ast w. ast/data flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Code-NoN (network of networks)\",\n  \"description\": \"Control Flow Graph in which each node is an AST.\\n\\nTo avoid confusion, remember that the artefacts in the \\n\\\"artefacts\\\" section are not related _beforehand_, but their\\nrelatedness must be predicted\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Bug Report\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST\",\n      \"details\": \"A full blown AST corresponding to the basic block in the original CFG,\\nconsisting of AST nodes and AST edges. \\nThe AST nodes are referred to as token nodes,\\nwhile the CFG nodes are referred to as block nodes.\\n\\nIn token nodes, compound names are split up.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"From a bug report (summary + description),\\nso-called \\\"bug clues\\\" are extracted,\\nwhich are encoded using word2vec\"\n}",
      "new": "cfg with ast-subtree per node"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Combination of DFG, CFG and RWG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Temporary Operand\",\n      \"details\": \"temporary \\\"variables\\\" that only exists in program execution\"\n    },\n    {\n      \"name\": \"Non-temporary Operand\",\n      \"details\": \"Variable/constant that explicitly exists in code\"\n    },\n    {\n      \"name\": \"Operation in Source code\",\n      \"details\": \"including standard operations, function calls, returns\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Operation Edge\",\n      \"details\": \"Data flow for operators\"\n    },\n    {\n      \"name\": \"Function Edge\",\n      \"details\": \"data flow for arguments and return  values\"\n    },\n    {\n      \"name\": \"PosNext\",\n      \"details\": \"Conditional Jumps in loops or branches.\"\n    },\n    {\n      \"name\": \"NegNext\",\n      \"details\": \"Conditional Jumps in loops or branches.\"\n    },\n    {\n      \"name\": \"IterJump\",\n      \"details\": \"Connect end of loop to begin\"\n    },\n    {\n      \"name\": \"CallNext\",\n      \"details\": \"From function call operation to first operation in called function\"\n    },\n    {\n      \"name\": \"ReturnNext\",\n      \"details\": \"From last operation in called function to operations right after function call\"\n    },\n    {\n      \"name\": \"Next\",\n      \"details\": \"Denote most common execution order\"\n    },\n    {\n      \"name\": \"Read\",\n      \"details\": \"From operand to operations; operations required to compute the operand\"\n    },\n    {\n      \"name\": \"Write\",\n      \"details\": \"From operations to operand; variables receiving the operation result\"\n    }\n  ],\n  \"vertex-features\": \"Operation/operand types are one-hot encoded\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "operations/operands w. call/control flow/data dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Compact Abstract Graph\",\n  \"description\": null,\n  \"artefacts\": [\n    {\n      \"name\": \"Source code method\",\n      \"details\": null\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node (Normal)\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"AST Node (Merged)\",\n      \"details\": \"Any \\\"linear\\\" sequence of nodes which form a direct chain\\nwithout other incoming edges, are merged into one.\\nThe root node cannot be part of a chain,\\nand leaf nodes cannot be part of a chain.\"\n    },\n    {\n      \"name\": \"AST Node (Aggregated)\",\n      \"details\": \"Any node aggregating _only_ a set of linear chains (length >= 1),\\nis turned into a single node combining all chains.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Next Token Edge\",\n      \"details\": \"Each token points to the next token\"\n    },\n    {\n      \"name\": \"Inverted AST Edge\",\n      \"details\": \"Inverted so all AST edges point \\\"upward\\\" towards the root node\"\n    },\n    {\n      \"name\": \"Root Edge\",\n      \"details\": \"Each leaf node has an edge pointing to the root node\"\n    }\n  ],\n  \"vertex-features\": \"Node content encoded using MPNet. Specifically;\\nNormal nodes; embedded as is \\nMerged nodes; average of all contained nodes \\nAggregated Nodes; \\\\frac{1}{k}\\\\sum_{i=1}^k\\\\left(\\\\frac{1}{n_i}\\\\sum_{j = 1}^{n_1} MPNet(T_{ij})\\\\right)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency List (directed)\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast (merged nodes) w. ast/ncs/leaf to root"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Component Dependency Graph\",\n  \"description\": \"constructed from the member dependency graph; there exists an edge between two components if there exists an edge between two members from each component\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"system\"\n    }\n  ],\n  \"vertex-type\": \"component\",\n  \"edge-type\": \"dependency\",\n  \"vertex-features\": \"metrics describing the \\\"graph structure\\\" in a component (e.g. average internal data flow)\\n\\nsome code level metrics \\n\\nsome network metrics\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "class/interface dependency network"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Contextual Flow Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"compiled to LLVM IR, which is used for graph construction\"\n    }\n  ],\n  \"vertex-type\": \"variables or label identifiers\",\n  \"edge-type\": \"data flow/data dependence/control flow\",\n  \"vertex-features\": \"values are replaced with their type, identifiers with a special marker\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Statement pairs <= N hops away are extracted from a set of graphs\"\n}",
      "new": "variables/labels in IR w. data flow/data dependence/control flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Contribution Network\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"version history information\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"developer/software component\",\n  \"edge-type\": \"contributed to (dev -> component)/contributed by (component -> dev)/depends on (component -> component)\",\n  \"vertex-features\": \"various local (node-level) network metrics (some of which use edge weights)\",\n  \"edge-features\": \"contribution is weighted by the number of commits\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"various global network metrics\",\n  \"other-features\": \"n/a\",\n  \"edge type\": \"contribution\"\n}",
      "new": "developer/software component w. contribution (dev <-> component)/dependencies (component <-> component)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Control Flow Chart\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Local block\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Line\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix (?)\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"The code block (not the nodes; the entire block)\\nis tokenized using the pretrained BPE tokenizer from CodeBERT.\\nThese tokens are passed to the pre-embedding\\npart of the network.\"\n}",
      "new": "cfg (line)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Control Flow Chart\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Local block\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Line\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"The code block (not the nodes; the entire block)\\nis tokenized using the pretrained BPE tokenizer from CodeBERT.\\nThese tokens are passed to the pre-embedding\\npart of the network.\"\n}",
      "new": "cfg (line)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Control Flow Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Statements in nodes are tokenized\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "cfg (statement)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Control Flow Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"User-defined names are normalised (e.g. METHOD1, VAR3)\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"Edge from statement to every statement that may be executed directly after it.\"\n    }\n  ],\n  \"vertex-features\": \"Node type is encoded on an ordinal scale,\\nwhere a type has a higher number if it occurs \\nmore frequently.\\nRarely occurring type are assigned the number 0.\\n\\nLexical content of nodes is encoded by taking \\nthe average of the word2vec values of the tokens in the node.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Stacked adjacency tensor.\\n\\nFor every graph, the adjacency matrix is determined.\\nThe four matrices are then combined into a third order tensor.\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. control flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Control Flow Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"Edges representing control flow between basic blocks\"\n    }\n  ],\n  \"vertex-features\": \"Node type and Node payload tokens are encoded using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Stacked adjacency tensor.\\n\\nFor every graph, the adjacency matrix is determined.\\nThe four matrices are then combined into a third order tensor.\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. control flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Control Flow Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"Edges representing control flow between basic blocks\"\n    }\n  ],\n  \"vertex-features\": \"Node type and Node payload tokens are encoded using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Stacked adjacency tensor.\\n\\nFor every graph, the adjacency matrix is determined.\\nThe four matrices are then combined into a third order tensor.\\n\\nSelf connections are added to all graphs\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. control flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Control Flow Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Natural Sequence Edge\",\n      \"details\": \"natural control flow\"\n    },\n    {\n      \"name\": \"True Edge\",\n      \"details\": \"True branch of conditional\"\n    },\n    {\n      \"name\": \"False Edge\",\n      \"details\": \"False branch of conditional\"\n    }\n  ],\n  \"vertex-features\": \"Tokens in nodes are embedded using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Identifier names in tokens are split up; punctuation is removed \\nTokens from the code are encoded using word2vec.\\n\\nAlready generated words are encoded using word2vec.\"\n}",
      "new": "cfg (statement)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Crucial Data Flow Graph\",\n  \"description\": \"subgraph of the data flow graph, which only contains vulnerability-related nodes\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"smart contracts\"\n    }\n  ],\n  \"vertex-type\": \"variable\",\n  \"edge-type\": \"data flow\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"mask matrix (?)\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Input for the model is: [CLS] <Token Sequence> [SEP] <Variable Sequence>\\nwhere the token sequence is the sequence of source code tokens \\n(and their corresponding positions), and the variable sequence is the sequence of variables\\nin the graph (and their corresponding positions).\"\n}",
      "new": "variables ('vulnerability related') w. data flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"DFG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Temporary Operand\",\n      \"details\": \"temporary \\\"variables\\\" that only exists in program execution\"\n    },\n    {\n      \"name\": \"Non-temporary Operand\",\n      \"details\": \"Variable/constant that explicitly exists in code\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Operation Edge\",\n      \"details\": \"Data flow for operators\"\n    },\n    {\n      \"name\": \"Function Edge\",\n      \"details\": \"data flow for arguments and return  values\"\n    }\n  ],\n  \"vertex-features\": \"Operation/operand types are one-hot encoded\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "operands w/ data flow/call"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Data Dependency Graph\",\n  \"description\": \"A cross method data dependency graph.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Methods\\n\\nSpecifically, for every method (core method),\\nwhich is either vulnerable or not vulnerable,\\na set of method _called by that method_\\n(directly or indirectly) are also\\ncollected in order to come up with the graph.\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Unclear\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"Data dependency edge as in PDG.\\n\\nThe graph is cross method, meaning calling relationships \\nare used to determine cross-method data dependencies.\"\n    }\n  ],\n  \"vertex-features\": \"Source code is normalised, and encoded using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "cross method data dependency graph (vertex unclear, edge is data dependence)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Data Flow Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Multiple methods\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Vertices encoded using node2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "statement w. data flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Data Flow Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"User-defined names are normalised (e.g. METHOD1, VAR3)\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"Edge from assignment to every use of that variable. \\n\\nNote; due to the use of if-statements, some uses may have \\nmultiple _incoming_ edges\"\n    }\n  ],\n  \"vertex-features\": \"Node type is encoded on an ordinal scale,\\nwhere a type has a higher number if it occurs \\nmore frequently.\\nRarely occurring type are assigned the number 0.\\n\\nLexical content of nodes is encoded by taking \\nthe average of the word2vec values of the tokens in the node.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Stacked adjacency tensor.\\n\\nFor every graph, the adjacency matrix is determined.\\nThe four matrices are then combined into a third order tensor.\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. data flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Data Flow Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"Edges represent subsequent modification or access of the same variables\"\n    }\n  ],\n  \"vertex-features\": \"Node type and Node payload tokens are encoded using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Stacked adjacency tensor.\\n\\nFor every graph, the adjacency matrix is determined.\\nThe four matrices are then combined into a third order tensor.\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. data flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Data Flow Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"Edges represent subsequent modification or access of the same variables\"\n    }\n  ],\n  \"vertex-features\": \"Node type and Node payload tokens are encoded using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Stacked adjacency tensor.\\n\\nFor every graph, the adjacency matrix is determined.\\nThe four matrices are then combined into a third order tensor.\\n\\nSelf connections are added to all graphs\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. data flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Data Flow Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"variable\",\n  \"edge-type\": \"data flow\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"mask matrix (1 for connected nodes, $-\\\\infty$ otherwise)\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"code tokens are used as input\"\n}",
      "new": "variable w. data flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Dataflow Enriched AST (AST+DF)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Nodes of types ImplicitCastExpr and DeclRefExpr are merged\\nwith their AST edge successor to reduce graph diameter.\\n\\nNodes are two-tuples (type, property), where\\nthe property is \\n1) data type (Function, FunctionArg, DeclStmt)\\n2) operator (Operator)\\n3) function name (CallExpr)\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"Edge from every usage of a variable to its definition\"\n    }\n  ],\n  \"vertex-features\": \"n/a (used embedding layer)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/data flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Dependency Graph\",\n  \"description\": null,\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"project\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Module\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Dependency\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"For every pair of nodes, compute the following features:\\n  1) topological features (common neighbours, Salton, Sorensen, Adamic-Adar, Katz, SimRank, Russel-Rao, Resource Allocation)\\n  2) content-based features:\\n      i) For every class in a module, compute the BoW representation of\\n          field attributes, method names, names of invoked methods, parameter names, comments, and JavaDoc documentation\\n      ii) Recursively take the union of class-based BoW representations to obtain the module-level BoW representation\\n      iii) Compute similarity between the two module-level BoW representations using cosine similarity\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "module w. dependency"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Dependency Network\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"project\"\n    }\n  ],\n  \"vertex-type\": \"software component\",\n  \"edge-type\": \"contributed to (dev -> component)/contributed by (component -> dev)/depends on (component -> component)\",\n  \"vertex-features\": \"various local (node-level) network metrics (some of which use edge weights)\",\n  \"edge-features\": \"contributed to edge is weighted by the number of commits\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"various global network metrics\",\n  \"other-features\": \"n/a\",\n  \"edge type\": \"depends on\"\n}",
      "new": "component w. depedencies"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Dependency Parse Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Commit Message\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Token\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Dependency Edge\",\n      \"details\": \"Denotes the types of dependencies between tokens (words) (e.g. adjective modifies)\"\n    },\n    {\n      \"name\": \"Neigh Edge\",\n      \"details\": \"Connects the last token in a sentence to the first token in the next sentence\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "dependency parse graph (token w. ncs and dependencies)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Dependency Parse Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Summary of code (training), query for search (testing)\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Token\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Dependency Edge\",\n      \"details\": \"One of 49 different types\"\n    },\n    {\n      \"name\": \"Next Token Edge\",\n      \"details\": \"NCS\"\n    },\n    {\n      \"name\": \"Subtoken Edge\",\n      \"details\": \"Sub token\"\n    }\n  ],\n  \"vertex-features\": \"Unclear how tokens are embedded\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "dependency parse graph (token + sub-token w. dependency/ncs/sub token)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Execution Data Flow Graph\",\n  \"description\": \"Based on AST\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Nodes representing variables are replaced with the types of those variables\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Route Edge\",\n      \"details\": \"Denotes execution flow between nodes (incl. branching)\"\n    },\n    {\n      \"name\": \"Value Edge\",\n      \"details\": \"Connects nodes representing variables to nodes providing the values for those variables\"\n    }\n  ],\n  \"vertex-features\": \"Encode tokens (either actual tokens or node type) using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. control flow/data dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Extended API Usage Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"objects/values/method invocations/constructor calls/field access/conditional checks/inheritance\",\n  \"edge-type\": \"call/control flow/sequential execution/synchronization/throw/handle/param\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"The authors make use of a set of discriminative subgraphs; subgraphs indicative of a label.\\nEach graph has a binary vector, where each entry indicates whether some specific discriminative subgraph occurs in the graph.\",\n  \"other-features\": \"n/a\"\n}",
      "new": "objects/values/operations in source code/field access etc. w. call flow/control flow (specific edge types)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Extended Component Dependency Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"project\"\n    }\n  ],\n  \"vertex-type\": \"component\",\n  \"edge-type\": \"logic dependency (composition, delegation etc)/co-evolution [all edges have back edges]\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"edges are weighted\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "component w. dependency/co-evolution"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"FA-AST (Flow-Augmented AST)\",\n  \"description\": null,\n  \"artefacts\": [\n    {\n      \"name\": \"Source code (file)\",\n      \"details\": null\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Purely syntactic nodes (e.g. \\\"{\\\") removed\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST child\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"AST parent\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"FA Next Token\",\n      \"details\": \"Connects one terminal leaf node to next terminal leaf node\"\n    },\n    {\n      \"name\": \"FA Next Sibling\",\n      \"details\": \"Connects each node to its next sibling\"\n    },\n    {\n      \"name\": \"FA Next Use\",\n      \"details\": \"Connects a node representing a variable to the next use of said variable\"\n    },\n    {\n      \"name\": \"FA If Flow\",\n      \"details\": \"Connects condition of if statement with code block that is executed if the condition is true\"\n    },\n    {\n      \"name\": \"FA Else Flow\",\n      \"details\": \"Connects condition of if statement with code block that is executed if the condition is false\"\n    },\n    {\n      \"name\": \"FA While Flow\",\n      \"details\": \"Connects condition of while statement with code block that is executed while the condition is true.\\n\\nThe block also has a FA Next Use back to the condition\"\n    },\n    {\n      \"name\": \"FA For Flow\",\n      \"details\": \"Connects condition of for statement with code block that is executed while the condition is true.\\n\\nThe block also has a FA Next Use back to the condition\"\n    },\n    {\n      \"name\": \"FA Next Statement Flow\",\n      \"details\": \"Edge to the directly following statement\"\n    }\n  ],\n  \"vertex-features\": \"na / Not specified (unclear how embeddings are initialised)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/ncs/sibling/data flow/control flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"FA-AST (Flow-augmented AST)\",\n  \"description\": \"AST with additional edges (all edges undirected)\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Child Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"AST Parent Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Next Sibling Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Next Token Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Next Use Edge\",\n      \"details\": \"Connect variable to its next use\"\n    },\n    {\n      \"name\": \"If Edge\",\n      \"details\": \"Connect if statement to its condition, ThenStatement, and ElseStatement\"\n    },\n    {\n      \"name\": \"While Edge\",\n      \"details\": \"Connect while statement to its condition and body\"\n    },\n    {\n      \"name\": \"For Edge\",\n      \"details\": \"Connect for statement to its control, and body\"\n    },\n    {\n      \"name\": \"Sequential Execution Edge\",\n      \"details\": \"Sequential execution between statements _in a code block_\"\n    }\n  ],\n  \"vertex-features\": \"Unclear what exactly is used. Seems to be at least the actual token payload for leaf nodes.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/sibling/ncs/data flow/control flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"FAST (Flow of Abstract Syntax Tree)\",\n  \"description\": \"Hybrid of control flow graph, call graph, and abstract syntax tree\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Basic Block\",\n      \"details\": \"Extracted from the AST. \\n\\nEach block represents a control flow transfer.\\nSlightly more course-grained than the control flow graph,\\nbecause e.g. assignment statements do not have dedicated nodes.\"\n    },\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Intra-procedural Edge\",\n      \"details\": \"Represents control flow between basic block.\\n\\nA Basis block points to every basic block that may follow it.\"\n    },\n    {\n      \"name\": \"Inter-procedural Edge\",\n      \"details\": \"Comes in two types: Call Edge and Return Edge.\\n\\nCall Edge: Edge from a basic block calling a function, to the \\n            first block (\\\"start block\\\") of the called function.\\n\\nReturn Edge: Edge from a basic block returning from a function, \\n        to the basic block in that called the function.\"\n    },\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Block/AST Edge\",\n      \"details\": \"Edge connecting a basic block to an AST node. \\nUnclear whether this is actually considered as a different \\ntype of edge by the authors. \\nAnyway, connects a basic block to the sub-tree of the AST \\n\\\"contained\\\" in said block.\"\n    }\n  ],\n  \"vertex-features\": \"AST nodes are embedded using Word2Vec\\n\\nSpecifically, for non-leave nodes, the type is encoded (no payload);\\nLeave nodes have no type but have a payload (token) that is encoded.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Per block, a log message is assumed to be given. \\nEvery word in the message is embedded using Word2Vec.\\nA final feature vector is obtained through averaging all these embeddings.\"\n}",
      "new": "cfg (basic block; interprocedural) with ast subtrees per node"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"FDA\",\n  \"description\": \"Mixture of AST, FCG, and DFG\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge - LastUse\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge - Compute\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge - Formal\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge - Return\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge - Operand\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Function Call Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Unclear what node features are used\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/data flow/call"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Flow-Enriched AST\",\n  \"description\": \"AST with control and data flow\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": null\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"undirected\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"undirected\"\n    },\n    {\n      \"name\": \"Data Flow Edge -- LastRead\",\n      \"details\": \"undirected\"\n    },\n    {\n      \"name\": \"Data Flow Edge -- LastWrite\",\n      \"details\": \"undirected\"\n    },\n    {\n      \"name\": \"Data Flow Edge -- ComputeFrom\",\n      \"details\": \"undirected\"\n    }\n  ],\n  \"vertex-features\": \"One-hot encoded node type\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/control flow/data flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Flow-augmented graph\",\n  \"description\": \"Graph containing syntactic and control flow information\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST node with code abstraction\",\n      \"details\": \"AST nodes, but e.g. literals are replaces with a LITERAL marker.\\nThe nodes corresponding to the buggy line (directly connected by NextToken edges),\\nare enclosed by START_BUG and END_BUG markers.\"\n    }\n  ],\n  \"vertex-features\": \"Word2Vec is used to encode the tokens.\\nThen, those tokens are further encoded using a BiLSTM encoder.\",\n  \"edge-type\": [\n    {\n      \"name\": true,\n      \"details\": \"Denotes that one jumps from one node to another if the condition of which the \\nfirst node is a part, is true.\"\n    },\n    {\n      \"name\": false,\n      \"details\": \"Denotes that one jumps from one node to another if the condition of which the \\nfirst node is a part, is false.\"\n    },\n    {\n      \"name\": \"UseBy\",\n      \"details\": \"Connects last assignment of a variable to all its subsequent uses\"\n    },\n    {\n      \"name\": \"DefineIn\",\n      \"details\": \"Connects the declaration of a variable to places where it is assigned to.\"\n    },\n    {\n      \"name\": \"NextToken\",\n      \"details\": \"Connects two tokens that are next to each other in the document.\"\n    },\n    {\n      \"name\": \"CallBy\",\n      \"details\": \"Connects a caller to the function it is calling\"\n    }\n  ],\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": null,\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w.  control flow/data flow/call/ncs"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Function Call Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Function\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Call Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Function Name, encoded using Word2Vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "fcg"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Function Call Graph\",\n  \"description\": null,\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Function\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Call Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"Edge weights calculated using Ricci curvature\",\n  \"connectivity-features\": \"Not  specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "fcg"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Fused Clone PDG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Code Clone Source Code\",\n      \"details\": \"For a given pair of code clones, where one has been modified,\\nthree artefacts are used:\\n1) Original code of the changed clone \\n2) Modified code of the changed clone\\n3) Code of the other clone\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"Every node has a triple-vector (Existence Vector), \\nindicating whether that node is present in the PDG \\nof every included code snippet.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Dependence Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependence Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Execution Edge\",\n      \"details\": \"Represent order of node execution\"\n    },\n    {\n      \"name\": \"Mapping Edge\",\n      \"details\": \"Edge connecting two \\\"corresponding\\\" nodes originating from the PDGs of two code snippets,\\nbut which do not contain the exact same statement\"\n    }\n  ],\n  \"vertex-features\": \"Code encoded using CodeBERT; vector concatenated with the existence vector\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "two pdgs (old/new version) with mapping edges and control flow edges"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Heterogeneous Contract Graph\",\n  \"description\": \"Combination of heterogeneous control flow and heterogeneous call graphs at multiple levels of granularity.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Source code of smart contracts\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Different node types for different control flow (e.g ENTRY_POINT, NEW_VARIABLE, RETURN, IF, END_IF, FUNCTION_START)\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"FALLBACK_NODE\",\n      \"details\": \"Node to represent the call to a fallback function\"\n    },\n    {\n      \"name\": \"FUNCTION_NAME\",\n      \"details\": \"Node to represent the name of a function;\\nused combined with INTERNAL_CALL/EXTERNAL_CALL to represent FCG information,\\nand is connected to the ENTRY_POINT of a function (and thus forms the merging points for call and control flow graphs)\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Different types for control flow (e.g. TRUE, FALSE, NEXT)\",\n      \"details\": null\n    },\n    {\n      \"name\": \"INTERNAL_CALL\",\n      \"details\": \"Call to function within the same smart contract\"\n    },\n    {\n      \"name\": \"EXTERNAL_CALL\",\n      \"details\": \"Call to function in another smart contract\"\n    }\n  ],\n  \"vertex-features\": \"One-hot encoded node types, _but_ that is not used for most evaluations\",\n  \"edge-features\": \"All length 2 meta-paths for all pairs of node types are extracted. Not used for all evaluations. \\n(Note -- length 2 meta path is like A -> B -> C)\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "control flow statements w. control flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Heterogeneous Contract Graph\",\n  \"description\": \"Combination of heterogeneous control flow and heterogeneous call graphs at multiple levels of granularity.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Source code of smart contracts\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"ROOT (cfg node)\",\n      \"details\": \"Entry point of the control flow graph of a function\"\n    },\n    {\n      \"name\": \"BASIC (cfg node)\",\n      \"details\": \"Basic block\"\n    },\n    {\n      \"name\": \"DISPATCHER (cfg node)\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"LEAF (cfg node)\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"EXIT (cfg node)\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"FALLBACK NODE (cfg node)\",\n      \"details\": \"Node to represent the call to a fallback function\"\n    },\n    {\n      \"name\": \"FUNCTION_NAME\",\n      \"details\": \"Node to represent the name of a function;\\nused combined with INTERNAL_CALL/EXTERNAL_CALL to represent FCG information,\\nand is connected to the ENTRY_POINT of a function (and thus forms the merging points for call and control flow graphs)\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Different types for control flow (e.g. TRUE, FALSE, NEXT)\",\n      \"details\": null\n    },\n    {\n      \"name\": \"INTERNAL_CALL\",\n      \"details\": \"Call to function within the same smart contract\"\n    },\n    {\n      \"name\": \"EXTERNAL_CALL\",\n      \"details\": \"Call to function in another smart contract\"\n    }\n  ],\n  \"vertex-features\": \"Four different schemes of generating node features, used separately:\\n  1) One-hot encoded node types\\n  2) metapath2vec (random walk + skipgram)\\n  3) LINE \\n  4) node2vec\",\n  \"edge-features\": \"All length 2 meta-paths for all pairs of node types are extracted. (Note -- length 2 meta path is like A -> B -> C)\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "basic block w. control flow/call"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Heterogeneous Program Graph (HPG)\",\n  \"description\": \"Based on AST\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Every node has a type and a value.\\nThe type is the composite or primitive type of the node (e.g. statement),\\nthe value is either the Constructor (e.g. FunctionDef, for a statement in the\\nAbstract Syntax Description Language (ASDL), or the token payload \\nof the node (leaf nodes)\"\n    },\n    {\n      \"name\": \"Subtoken\",\n      \"details\": \"Two variants:\\nshared subtokens (one node for every _unique_ subtoken),\\nor separate subtoken node per occurrence\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Child\",\n      \"details\": null\n    },\n    {\n      \"name\": \"Next Sibling Edge\",\n      \"details\": null\n    },\n    {\n      \"name\": \"Next Token Edge\",\n      \"details\": null\n    },\n    {\n      \"name\": \"AST Parent\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Previous Sibling Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Previous Token Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Subtoken of\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Subtoken of reversed\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"type and value\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast + sub-token w. ast/sibling/ncs/sub token"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Heterogeneous Syntax Graph\",\n  \"description\": \"AST with explicitly heterogeneous edges\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Some nodes (e.g. \\\"Block\\\") are removed to reduce tree size\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Child Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"AST Parent Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"AST Left Sibling Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"AST Right Sibling Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Next Data Flow Node Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Previous Data Flow Node Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Previous Leaf Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Next Leaf Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Identifiers in nodes are split up\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"The goal of the model is to predict the next token in the summary.\\nAs such, the summary generated thus far is also an input.\"\n}",
      "new": "ast w. ast/sibling/data flow/ncs"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Heterogeneous Syntax Graph\",\n  \"description\": \"AST with explicitly heterogeneous edges\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Child Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"AST Parent Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"AST Left Sibling Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"AST Right Sibling Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Next Data Flow Node Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Previous Data Flow Node Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Not clearly specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Each token is enhanced with its line number and position (in terms of tokens) in the line it came from.\\n\\nThe goal of the model is to predict the next token in the summary.\\nAs such, the summary generated thus far is also an input.\"\n}",
      "new": "ast w. ast/sibling/data flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Index-Focussed Construction\",\n  \"description\": \"All tokens are represented as a sequence,\\nand two nodes are connected if they occur within\\na sliding window of size v\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Token\",\n      \"details\": \"Not necessarily unique\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Co-occurrence Edge\",\n      \"details\": \"within a sliding window of size v\"\n    }\n  ],\n  \"vertex-features\": \"Tokens embedded using token embedding layer of CodeBERT\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified (adjacency matrix?)\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": null\n}",
      "new": "token w. sliding window co-occurence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Index-Focussed Construction\",\n  \"description\": \"All tokens are represented as a sequence,\\nand two nodes are connected if they occur within\\na sliding window of size v\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Token\",\n      \"details\": \"Not necessarily unique\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Co-occurrence Edge\",\n      \"details\": \"within a sliding window of size v\"\n    }\n  ],\n  \"vertex-features\": \"Tokens embedded using token embedding layer of GrapCodeBERT\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified (adjacency matrix?)\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": null\n}",
      "new": "token w. sliding window co-occurence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Inter-procedural Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Dependence Edge\",\n      \"details\": \"From PDG\"\n    },\n    {\n      \"name\": \"Data Dependence Edge\",\n      \"details\": \"From PDG\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Function Call Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Nodes represent statements, which consists of tokens.\\nNodes are embedding by summing the embeddings of the tokens, \\nwhere tokens are embedded using a learnable embedding.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"Sample subgraphs using vulnerability-specific program slicing;\\nIdentify start and end of possible vulnerability, and select \\nthe graph of all paths between the two.\\n\\nExtract six subgraphs for: \\n  1) buffer overflow\\n  2) memory leak\\n  3) null pointer dereference\\n  4) integer overflow\\n  5) use after free \\n  6) double free\",\n  \"other-features\": \"n/a\"\n}",
      "new": "statement w. control dependence/data dependence/data flow/call"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"LFAST (Loop-Flow Abstract Syntax Tree)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Only a small selection of AST nodes from the original AST \\nis kept; only the \\\"loop oriented\\\" ones, which are either\\npart of a loop or within a k-hop neighbourhood of a node \\nwhich is part of a loop.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Node features are based on three basic features:\\n  1) Node payload (1 token) encoded using word2vec\\n  2) Node type is encoded using Label Encoding\\n  3) positional encoding: position of i-th token in code is encoded as a vector\\n    [sin(w_0 * i), cos(w_0 * i), sin(w_1 * i), cos(w_1 * i), ...]\\n\\n  Final node feature vector is given by CONCAT(type, payload + position)\",\n  \"edge-features\": \"Edge type: syntax, control, or data. Encoded using Label Encoding\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast (trimmed) w. ast/control flow/data flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"LR-FA-AST (Less Redundancy Flow Augmented AST)\",\n  \"description\": \"Flow-augmented AST with pruning applied.\\nSpecifically, only \\\"important\\\" nodes and their edges \\nare kept, where important nodes are nodes dealing \\nwith variable/method declarations, and control structures (e.g. if, loops)\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Certain node types are pruned (see description)\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Block Edge\",\n      \"details\": \"Edges between the child node of block structures\"\n    },\n    {\n      \"name\": \"Conditional Edge\",\n      \"details\": \"Edges between child nodes of control structures (e.g. while, if)\"\n    },\n    {\n      \"name\": \"Leaf Edge\",\n      \"details\": \"Edges between (successive) leaf nodes\"\n    },\n    {\n      \"name\": \"Control Edge\",\n      \"details\": \"Edges for function calls(?)\"\n    }\n  ],\n  \"vertex-features\": \"Unclear; presumably node type based on images in the paper\",\n  \"edge-features\": \"Edges have weights; unclear how they are computed. It seems to be the edge type\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/block/control flow/ncs"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Labelled pushdown system\",\n  \"description\": \"Inter-procedural control flow of a program modelled as a pushdown system,\\nwhere each rule has a label, which are concatenated as the machine makes \\nits transitions.\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"state\",\n  \"edge-type\": \"transition\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"labels (for instruction category, error code,struct type, functions)\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"Perform random walks over the graph, and collect the sequence of labels\",\n  \"other-features\": \"n/a\"\n}",
      "new": "labelled pushdown system (states w. transitions)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Line Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"Smart Contracts\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Line\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Function Edge\",\n      \"details\": \"Connect first and last lines of function declaration\"\n    },\n    {\n      \"name\": \"Control Edge\",\n      \"details\": \"end to end connections between control blocks (if/for/while)\"\n    },\n    {\n      \"name\": \"Sequential Edge\",\n      \"details\": \"Connect lines in top to bottom order\"\n    },\n    {\n      \"name\": \"Variable Edge\",\n      \"details\": \"Connect nodes containing the same variables\"\n    },\n    {\n      \"name\": \"Modifier Edge\",\n      \"details\": \"connect definitions of modifiers to their corresponding uses\"\n    },\n    {\n      \"name\": \"Reentrancy Edge\",\n      \"details\": \"Connect nodes contain \\\"call.value\\\" to all other nodes belonging to the same function\"\n    }\n  ],\n  \"vertex-features\": \"Text content of every line is used as feature (after preprocessing; normalisation of identifiers etc)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not explicitly specified, but seems to be 6 adjacency matrices\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "line w. control flow/data flow/re-entrancy (call.value)/first <-> last line"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Member Dependency Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"system\"\n    }\n  ],\n  \"vertex-type\": \"data item (eg shared variables) / function\",\n  \"edge-type\": \"call / return / data flow\",\n  \"vertex-features\": \"code level metrics\",\n  \"edge-features\": \"number of data items transferred in an edge\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "data item (shared variable, function) w. call/return/data flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Multilayer Class Network\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"project\"\n    }\n  ],\n  \"vertex-type\": \"class\",\n  \"edge-type\": \"class/interface relationships\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "class/interface dependency network"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Multilayer Package Network\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"project\"\n    }\n  ],\n  \"vertex-type\": \"package\",\n  \"edge-type\": \"class/interface relationships (based on the coupling between the classes in the packages)\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"Weights based on the amount of coupling (i.e. amount of involved classes)\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "package w. class/interface dependencies of classes/interfaces in packages"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Natural Code Sequence\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"User-defined names are normalised (e.g. METHOD1, VAR3)\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Code Sequence Edge\",\n      \"details\": \"Edge from one AST leaf node to the next\"\n    }\n  ],\n  \"vertex-features\": \"Node type is encoded on an ordinal scale,\\nwhere a type has a higher number if it occurs \\nmore frequently.\\nRarely occurring type are assigned the number 0.\\n\\nLexical content of nodes is encoded by taking \\nthe average of the word2vec values of the tokens in the node.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Stacked adjacency tensor.\\n\\nFor every graph, the adjacency matrix is determined.\\nThe four matrices are then combined into a third order tensor.\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ncs"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Natural Code Sequence\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Code Sequence Edge\",\n      \"details\": \"Edge from one AST leaf node to the next\"\n    }\n  ],\n  \"vertex-features\": \"Node type and Node payload tokens are encoded using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Stacked adjacency tensor.\\n\\nFor every graph, the adjacency matrix is determined.\\nThe four matrices are then combined into a third order tensor.\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ncs"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Natural Code Sequence\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Code Sequence Edge\",\n      \"details\": \"Edge from one AST leaf node to the next\"\n    }\n  ],\n  \"vertex-features\": \"Node type and Node payload tokens are encoded using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Stacked adjacency tensor.\\n\\nFor every graph, the adjacency matrix is determined.\\nThe four matrices are then combined into a third order tensor.\\n\\nSelf connections are added to all graphs\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ncs"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Object Usage Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"action (API invocation; e.g java.lang.String.new) or control (eg. while)\",\n  \"edge-type\": \"(temporal) usage order/data dependency\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "api invocation/control statement w. usage order/data dependency"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"PDG (Program Dependence Graph)\",\n  \"description\": \"Based on Jimple IR\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Multiple files\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Instruction\",\n      \"details\": \"Based on the Jimple instructions\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data flow edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control flow edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Method call edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Embedding instructions (as learned by the Lexical Embedding Model)\",\n  \"edge-features\": \"n/a (edge type)\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Each Jimple instruction is split into subwords.\\nA Word2Vec model is trained on the subwords.\"\n}",
      "new": "pdg (instruction) w. call edges"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"PDG\",\n  \"description\": \"All source files in a project are processed.\\nFurthermore, every function in a source file is \\nrepresented using its own graph.\\n\\nGiven a bug report, the model must pinpoint the file \\nwith the defect;\\n\\nTo avoid confusion, remember that the artefacts in the \\n\\\"artefacts\\\" section are not related _beforehand_, but their\\nrelatedness must be predicted\",\n  \"artefacts\": [\n    {\n      \"name\": \"Bug report\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"Every function in a source file has its own PDG\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Dependence Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Dependence Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"Graphs Represented using Graph2Vec.\\n\\nAll graph representations are aggregated into a single vector \\nthrough k-medoids with Hausdorff distance\",\n  \"other-features\": \"Summary and description of bug reports are encoded using word2vec.\\n\\nContent of source code files is encoded using word2vec,\\nafter removal of keywords and splitting up identifiers.\"\n}",
      "new": "pdg (statement)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"PDG\",\n  \"description\": \"Check \\\"other-features\\\" for details;\\nThe paper does not really use graphs, but things derived \\nfrom full graphs.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": null\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Dependence Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependence Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"So-called value-flow paths are extracted from the PDG.\\n\\nA guarded value-flow path consists of a sequence of program\\nstatements representing a def-use chain between variables, with the\\nguard on each edge between two statements to indicate control-flow\\ntransfer conditions.\\n\\nPaths are put into a network which maps them to vectors.\\nA path is fed twice into the network, with different dropout masks.\\nA contrastive loss is used.\\n\\nThe network first encoded the statements based on AST subtrees.\\nEach node in the AST subtree corresponding to the statement\\nis initialised using Code2Vec.\\n\\nNext, each nodes embedding is updated according to its\\nown embedding and those of its children, using an\\nattention-weighted sum.\\nThe attention weights for node $i$ and its children $C_i$ are computed according to \\n\\n  a_{ij} = \\\\frac{\\\\exp(\\\\sigma(e_{ij}))}{\\\\sum_{k \\\\in C_i \\\\cup i} \\\\exp(\\\\sigma(e_{ik}))}\\n  e_{ij} = a^T_s[W^a v_{n_i} \\\\mid\\\\mid W^a v_{n_j}] \\\\cdot \\\\sigma((W^av_{n_1})^T(W^a v_{n_j}))\\n  Where a_s and W are a learnable matrix and learnable vector.\\n\\nFinally, all nodes are aggregated according to:\\n\\nv_{sm} = \\\\frac{1}{N}\\\\sum_{i = 1}^N v'_{n_i} \\\\mid\\\\mid \\\\max_{j = 1}^N v'_{n_j}\\n\\nNext, all statement embeddings are passed through a bidirectional GRU layer.\\n\\nThe hidden states of the GRU layer are summed using an attention-weighted sum.\\n\\nThe trained model is used to encode value-flow paths for later use.\\n\\nDeep learning model is used to select top-k paths. \\nInfeasible value flow paths (cannot occur based on if guards) are filtered out.\"\n}",
      "new": "pdg (statement)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"PDG\",\n  \"description\": \"Using slicing, every PDG is split into multiple slice subgraphs\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"Comments removed, user defined names are normalised.\\nProgram slicing based on sensitive APIs, arrays,\\nintegers, and pointers is performed.\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Dependence Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependence Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Statement embedded using sent2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Using slicing, every PDG is split into multiple slice subgraphs\",\n  \"graph-features\": \"Using slicing, every PDG is split into multiple slice subgraphs.\\n\\nThe subgraph-model is used to filter subgraphs; \\nthe 25% of subgraphs with the lowest predicted probabilities \\nof containing a vulnerability are dropped.\\n\\nThe remaining subgraphs are passed to the \\\"full\\\" model.\",\n  \"other-features\": \"Using slicing, every PDG is split into multiple slice subgraphs\"\n}",
      "new": "pdg (statement)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"PDG\",\n  \"description\": \"b/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Dependence Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependence Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"One-hot encoding of statement type\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "pdg (statement)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"PDG\",\n  \"description\": \"based on Java compiled to (Jimple) IR\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Method\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"Jimple; Intermediate Representation\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Dependence Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Dependence Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Random walk is used to generate a bag of paths from the PDG.\\nEach path n_1 e_1 n_2 e_2 ... is seen as a sentence. \\nNode are replaced by their statements, edges with their type (data or control).\\nNLP preprocessing (tokenization, name splitting, remove non-alphabet characters,\\nremove locals, transform to lower case).\\n\\nThe IR is represented as a sequence and enhanced with type information.\\nSpecifically, the type of the instruction, and every token in the IR \\nstatement is prefixed with its nonterminal type according to the Jimple grammar. \\n\\nFirst comment of JavaDoc comment describing the method is also included as input.\\n\\nAll \\\"sentences\\\" obtained this way are combined into a single set of |N| + |P| + 1 sentences.\"\n}",
      "new": "pdg (instruction)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"PDG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Method\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"Has as attribute the variable involved in the dependency\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Special traversal algorithm is used to sequence the graph.\\nThe process is reversible (i.e. retains some form of the structural information);\\nthe content of every node is then placed in its place in the sequence. \\n\\nThe method name is tokenised; the sequence is used as a feature \\n\\nTokens in the method body are used as a feature\\n\\nCode summary/query is tokenised and used as a feature\"\n}",
      "new": "pdg (statement)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"PDG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Line\",\n      \"details\": \"Comments are omitted \\nnormalise names (VAR0, FUN1)\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Lines of code encoded using sent2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "pdg (line)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"PDG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Dependence Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow  Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Self Loop\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Statements are encoded using CodeBERT\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"The entire function is encoded using CodeBERT\",\n  \"other-features\": \"n/a\"\n}",
      "new": "pdg (statement)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"PDG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"PDG Node\",\n      \"details\": \"Forward and backward slicing is performed to only keep relevant nodes\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"for GGNN model:\\n  Three separate mechanics:\\n  1) Ordinal encoding of node type\\n  2) Ordinal encoding of node type + encoded variant of some additional info (e.g. functions mentioned by node)\\n  3) Ordinal encoding of node type + average word2vec encoding of tokens in the node\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"For the LSTM model:\\n  1) tokenisation,\\n      abstraction of literaturs,\\n      removal of uncommon identifiers, \\n      splitting snake and camel case into separate words\\n      remove certain uninformative node types\\n  2) Converting into a stream of tokens\"\n}",
      "new": "pdg"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"PDG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"Annotated with variable name\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"sometimes have labels, e.g. labelled \\\"true\\\" or \\\"false\\\" for conditionals\"\n    }\n  ],\n  \"vertex-features\": \"Tokens in node encoded using word2vec\",\n  \"edge-features\": \"Encoded using word2vec (0 padded if empty)\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "pdg (statement)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"PDG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"file\"\n    }\n  ],\n  \"vertex-type\": \"statement (?)\",\n  \"edge-type\": \"control dependence/data dependence\",\n  \"vertex-features\": \"method and field names are encoded using word2vec.\\n\\nnumber of api names \\n\\nnode type \\n\\nVarious network-derived metrics are used\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"title, description, comments of bug report are analysed using LDA;\\n\\\"multiple-hot\\\" vector of present topics is used as feature\"\n}",
      "new": "pdg (statement)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"PDG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": \"statement (w/ names normalised)\",\n  \"edge-type\": \"control dependence/data dependence\",\n  \"vertex-features\": \"statement, encoded using sent2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"for every node, compute degree centrality, katz centrality, and closeness centrality.\\nCreate an RGB image, where each color dimension is a centrality multiplied by the node vector \\n(e.g. red = degree centrality * node vector).\\n\\nAn image (RGB) is obtained by concatenating all node representations.\"\n}",
      "new": "pdg (statement)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"PDG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"statement (names normalised)\",\n  \"edge-type\": \"control dependence/data dependence\",\n  \"vertex-features\": \"statement, encoded using sent2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"for every node, compute degree centrality, closeness centrality, and second order centrality.\\nCreate an RGB image, where each color dimension is a centrality multiplied by the node vector \\n(e.g. red = degree centrality * node vector).\\n\\nAn image (RGB) is obtained by concatenating all node representations.\"\n}",
      "new": "pdg (statement)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"PDG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"statement\",\n  \"edge-type\": \"control dependence/data dependence\",\n  \"vertex-features\": \"statements as sequences of tokens\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"description of the code is used as feature\"\n}",
      "new": "pdg (statement)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Parse Tree\",\n  \"description\": \"Text is first transformed using T5 transformer\",\n  \"artefacts\": [\n    {\n      \"name\": \"Summary of the source code (training) or query (working)\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Token\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Constituency Symbol\",\n      \"details\": \"e.g. \\\"VB\\\" (verb)\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Constituency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Word Ordering Edge\",\n      \"details\": \"Undirected\"\n    }\n  ],\n  \"vertex-features\": \"Unclear how nodes are encoded\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "parse tree (token/constituency symbol (eg. VERB) w. constituency edge/word ordering)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Parse Tree\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Summary of the source code (training) or query (working)\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Token\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Constituency Symbol\",\n      \"details\": \"e.g. \\\"VB\\\" (verb)\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Constituency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Word Ordering Edge\",\n      \"details\": \"Undirected\"\n    }\n  ],\n  \"vertex-features\": \"Unclear how nodes are encoded\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "parse tree (token/constituency symbol (eg. VERB) w. constituency edge/word ordering)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"PatchCPG\",\n  \"description\": \"A variant of the code property graph for representing patches\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Constructed based on commits, but also uses full source code.\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"AST Nodes are obtained by taking files which were modified in the commit,\\nand excluding all unchanged functions (as a means to include global variables\\nin the resulting graphs).\\n\\nThe amount of nodes is further reduced through program slicing,\\nthough this is only done following data- and control edges.\\n\\nNodes are marked as \\\"added\\\", \\\"deleted\\\", or \\\"context\\\"\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"Edges are marked as \\\"added\\\", \\\"deleted\\\", or \\\"context\\\"\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"Edges are marked as \\\"added\\\", \\\"deleted\\\", or \\\"context\\\"\"\n    },\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"Edges are marked as \\\"added\\\", \\\"deleted\\\", or \\\"context\\\"\"\n    }\n  ],\n  \"vertex-features\": \"1) Number of characters in the node payload \\n2) version (added/deleted/context)\\n3) number of function calls \\n4) number of variables \\n5) number of number (constants)\\n6) number of strings\\n7) number of pointers \\n8) number of arrays\\n9) number of NULL identifiers \\n10) Boolean indicating if the node if a conditional\\n11) Boolean indicating if the node if a loop\\n12) Boolean indicating if the node if a jump statement \\n13) Number of arithmetic operators\\n14) Number of relational (comparison) operators\\n15) Number of logical operators\\n16) Number of bitwise operators\\n17) Boolean indicating if the node contains the API name of memory operations\\n18) Boolean indicating if the node contains the API name of string operations\\n19) Boolean indicating if the node contains the API name of lock operations\\n20) Boolean indicating if the node contains the API name of system operations\",\n  \"edge-features\": \"Edge type is one-hot encoded \\nversion info encoded according to \\\"added\\\" -> [0, 1], \\\"deleted\\\" -> [1, 0], \\\"context\\\" -> [1, 1]\\nThe two vectors are concatenated\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/control dependence/data dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Program Dependence Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Multiple methods\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"PDG Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Vertices encoded using node2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "pdg (statement)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Program Dependency Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement or Control Predicate\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Node features are trained using a modified node2vec,\\nwhich learns embeddings for the individual tokens in \\neach node.\\n\\nLater, these embeddings per node are combined to come \\nup with node embeddings.\",\n  \"edge-features\": \"Separate from the vertex features, another set of \\nnode features (not based on node payload) is \\ncomputed using node2vec.\\n\\nEdge features are computed by subtracting the \\nstart node embedding from the end node embedding,\\nfor every edge.\",\n  \"connectivity-features\": \"Not Specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "pdg (statement)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Program Dependency Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"PDG Node\",\n      \"details\": \"Nodes are created for AST nodes containing \\n1) method calls\\n2) assignment\\n3) control statements \\n4) declarations \\n5) API field access \\n\\nFurthermore, every node involving a type has the type name fully expanded (e.g. java.lang.String)\"\n    },\n    {\n      \"name\": \"Hole\",\n      \"details\": \"Node in the graph for which a type must be predicted.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"PDG Edge\",\n      \"details\": \"Both data and control flow edges\"\n    },\n    {\n      \"name\": \"Prediction Flow Dependency Edge\",\n      \"details\": \"Edge from a node in the PDF to the hole\"\n    }\n  ],\n  \"vertex-features\": \"n/a (embedding layer)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Textual elements are extracted. Specifically:\\n1) The name of the method in which a prediction is made. Compound name (e.g. getFileLine) are split into individual words.\\n2) All (full) names of all API classes used in the method\\n3) Variable Names\"\n}",
      "new": "pdg (statement)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Program Feedback Graph\",\n  \"description\": null,\n  \"artefacts\": [\n    {\n      \"name\": \"Compiler Feedback\",\n      \"details\": \"Line number i_err and error message m_err\"\n    },\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Token\",\n      \"details\": \"Token in the compiler error message. Specifically, the tokens \\nfound between quotation marks. (e.g. object \\\"a\\\" of type \\\"x\\\" has no attribute \\\"y\\\")\"\n    },\n    {\n      \"name\": \"Token\",\n      \"details\": \"Token from code. Specifically, variable names and occurrences of tokens\\nextracted from the error message.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Token Edge\",\n      \"details\": \"Undirected edge between identical tokens\"\n    }\n  ],\n  \"vertex-features\": \"Lines in the source code are tokenized\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Compiler message is tokenized \\nCompiler line number is used as feature\"\n}",
      "new": "token w. edges between identical tokens"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Propagation Chain\",\n  \"description\": \"Denotes relationships between different variables.\\n\\nThe graph described below is further trimmed based on \\ncertain \\\"key information\\\". The information nor the process \\nis described in detail.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Smart contracts\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Variable at token\",\n      \"details\": \"Each node represents the occurrence of variable, identified with its index in the sequence of program tokens\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Value Comes From\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Value Computed From\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified (Mask Matrix)\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"The token sequence of the source code (CT)\\nThe positions of the tokens in the source code \\nThe sequence of variables in the source code (V)\\nThe positions of the variables.\\nCT and V are concatenated to obtain I_1; the position sets are concatenated to obtain I_2.\\n\\nFor every variable\"\n}",
      "new": "variable w. data dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Read-write Graph (RWG)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Operand\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Operation\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Read\",\n      \"details\": \"From operand to operations; operations required to compute the operand\"\n    },\n    {\n      \"name\": \"Write\",\n      \"details\": \"From operations to operand; variables receiving the operation result\"\n    }\n  ],\n  \"vertex-features\": \"Operation/operand types are one-hot encoded\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "operations/operands w. data dependence/data flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Rep-HG\",\n  \"description\": \"Heterogeneous graph structure connecting repositories,\\nusers, and topics (tags) on Github.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code (repository)\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Metadata (repository)\",\n      \"details\": \"Non-source code artefacts in a repository (e.g. README file)\"\n    },\n    {\n      \"name\": \"User Profile Data\",\n      \"details\": \"Bio information. E.g. name, description, contact information\"\n    },\n    {\n      \"name\": \"Topic\",\n      \"details\": \"Topic on Github\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Repository\",\n      \"details\": \"Comprises two types of artefacts\"\n    },\n    {\n      \"name\": \"User\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Topic\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"R1; repository-belongto-user\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"R2; repository-contain-topic\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"R3; repository-forkby-user\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"R4; repository-starby-user\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"For repository nodes, all metadata and source code is combined into a single feature vector using BERT.\\nFor users, the user profile data as well as the _metadata_ of repositories belonging to the user are combined into a single feature vector using BERT.\\nThe topic is encoded as a single feature vector using BERT.\\nUsing the above features as-is will be referred to as the regular HG-graph, or node view.\\nThree meta-paths are also used. There are i) Repo --forkby--> User --forky^-1--> Repo i) Repo --starby--> User --starby^-1--> Repo i) Repo --contain--> Topic --contain^-1--> Repo\\nEach meta path is used separately in combination with random walk with restart in order to sample a subgraph defined by the meta-path.\",\n  \"edge-features\": null,\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "repository/user/topic w. belongs to/contains topic/forked by/starred by"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"S-AST\",\n  \"description\": \"AST with control flow information and subtokens\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"Method level\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST non-leave node\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"AST leave node\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"API Invocation node\",\n      \"details\": \"e.g. \\\"Method Invocation\\\" node in the AST.\"\n    },\n    {\n      \"name\": \"Subtoken Node\",\n      \"details\": \"Every identifier in a node (e.g \\\"getLarger\\\") is split into subtokens (\\\"get\\\", \\\"L\\\", \\\"arger\\\").\\nFirst first one (\\\"get\\\") is kept as the parent node in place of the identifier; \\nthe other subtokens are kept as child nodes.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Leaf Edge\",\n      \"details\": \"Edge to the next leaf node (which may be of type \\\"Subtoken\\\" in case of a subtoken parent node)\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"Edge to next usage of a variable, starting from declaration\"\n    },\n    {\n      \"name\": \"Subtoken Edge\",\n      \"details\": \"Edge between subtoken child and parent node\"\n    }\n  ],\n  \"vertex-features\": \"Not specified/unclear how initial embedding are intialised\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"1) Leaf Edges and edges linking variables are removed \\n2) Graph is partitioned into subtrees, where each subtree represents a statement\\n3) Subtrees are grouped (left-to-right) into subgraphs based on their size using a threshold lamda\\n4) Leaf Edges and variable linking edges are re-instated per subgraph\",\n  \"other-features\": \"The raw code of the method is converted to AST. The token types (or payloads for leaves)\\nare linearised through pre-order traversal. The API description is aded to this text.\"\n}",
      "new": "ast + sub-token + api invocation nodes w. ast/ncs/data flow/sub token"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"SDG (Sub-dependence Graph)\",\n  \"description\": \"Program Dependence Graph with slicing applied;\\nonly those nodes _from which_ a dangerous function\\ncall is reachable, are kept.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"Names in the code are normalised\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Flow Dependency Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Statements are encoded using doc2vec (PV-DM)\",\n  \"edge-features\": null,\n  \"connectivity-features\": null,\n  \"graph-features\": null,\n  \"other-features\": null\n}",
      "new": "pdg (statement)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Semantic Flow Graph (SFG)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Changesets (for bug localisation)\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Variable Node\",\n      \"details\": \"One for every _occurrence_ of a variable in the source code.\"\n    },\n    {\n      \"name\": \"Control Instruction Node\",\n      \"details\": \"For control structures such as if (if would have IfCondition, IfThen, IfElse, IfConverge)\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Sequential Computation Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Mask matrix for attention\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"1) Comment Input Sequence\\n    A (doc) comment associated with the source code, as tokens, beginning with the classification token [CLS]\\n2) Source Code Input Sequence\\n    [C] Cleaned source code tokens [SEP]\\n3) Node List \\n    [N] List of nodes \\n4) Type List \\n    [T] Type information of nodes -- out of list of 55 possible types \\n5) Role List \\n  [R] Role information of nodes -- out of list of 43 possible roles [SEP]\\n\\nFor bug localisation, the bug report is also given as feature\"\n}",
      "new": "variable (every occurrence)/control statement w. data flow/control flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"SeqGraph\",\n  \"description\": \"Graph containing syntactic and control flow information\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST node with code abstraction\",\n      \"details\": \"AST nodes, but e.g. literals are replaces with a LITERAL marker.\\nThe nodes corresponding to the buggy line (directly connected by NextToken edges),\\nare enclosed by START_BUG and END_BUG markers.\"\n    }\n  ],\n  \"vertex-features\": \"Word2Vec is used to encode the tokens.\\nThen, those tokens are further encoded using a BiLSTM encoder.\",\n  \"edge-type\": [\n    {\n      \"name\": \"NextToken\",\n      \"details\": \"Connects two tokens that are next to each other in the document.\"\n    }\n  ],\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": null,\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ncs"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Slice Property Graph\",\n  \"description\": \"Similar to code property graph, but with program slicing.\\n\\nFirst, AST is used to detect SyVC's. \\nThese are used as a basis for slicing in the PDG.\\nNext, a graph with data, control, and function call dependence edges is created.\\n\\nNote: one function may have multiple slices.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Also function focussed, but not exclusively\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Dependence Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependence Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Function Call Dependence Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Statements in nodes are tokenized, encoded using word2vec,\\nand enhanced with positional labels. \\n\\nNode types are one-hot encoded.\",\n  \"edge-features\": \"Edges are labelled according to type (d \\\\in D)\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"Three subgraphs are created by considering different edge types\",\n  \"other-features\": \"n/a\"\n}",
      "new": "pdg (statement) w. call dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Socio-Technical Network\",\n  \"description\": \"Directed graph\",\n  \"artefacts\": [\n    {\n      \"name\": \"version history information\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"source code\",\n      \"details\": \"project\"\n    }\n  ],\n  \"vertex-type\": \"developer/software component\",\n  \"edge-type\": \"contributed to (dev -> component)/contributed by (component -> dev)/depends on (component -> component)\",\n  \"vertex-features\": \"various local (node-level) network metrics (some of which use edge weights)\",\n  \"edge-features\": \"contributed to edge is weighted by the number of commits\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"various global network metrics\",\n  \"other-features\": \"n/a\"\n}",
      "new": "developer/component w. contribution/dependencies"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Software network\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"project\"\n    }\n  ],\n  \"vertex-type\": \"file (in project)\",\n  \"edge-type\": \"dependency or association\",\n  \"vertex-features\": \"vertices encoded using node2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "file w. dependency/association"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Split AST\",\n  \"description\": \"First, the CFG is computed.\\nThen, the dominator tree of the CFG is computed.\\nFor every node with more than 2 outgoing edges, its outgoing edges are removed,\\nleading to groups of separate nodes. For every group of nodes, its AST \\nsubtree is computed. (alternative view: the AST is split up according to the graph described above)\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"Node type and value (concatenated)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Source code is used as feature\"\n}",
      "new": "ast (split up)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Statement-centered AST\",\n  \"description\": null,\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": null\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Statement Node\",\n      \"details\": \"Statement node (one of the following must be met):\\n1) Node is expression statement, declaration statement, or branching statement (break, continue, return)\\n  --> This definition makes sure a statement contains no statement in its subtree (because if/for/while excluded)\\n2) A node represents an expression in a program and its parent node is a decision or loop statement.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge (directed, augmented)\",\n      \"details\": \"Use normal AST edges (directed), _but_ when a statement \\nnode is detected, reverse the direction of all edges in \\nthe subtree(s) of the statement node, so that they point\\nto the statement node.\"\n    }\n  ],\n  \"vertex-features\": \"Not specified\",\n  \"edge-features\": \"Edge type (up or down); encoding not specified\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast (with some edges reversed to point to statements in particular)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Structure Graph (SG)\",\n  \"description\": \"Essentially an AST\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Nodes representing variables are replaced with the types of those variables\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Child Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"AST Parent Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Encode tokens (either actual tokens or node type) using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Tree Graph\",\n  \"description\": \"Simplified version of AST\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node Type Node\",\n      \"details\": \"Every node type in the AST has _one_ node in the tree graph\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Edge\",\n      \"details\": \"There is an edge between two node types in the tree graph \\nif and only if there exists an edge between two nodes of \\nthose types in the original AST.\"\n    }\n  ],\n  \"vertex-features\": \"1) Degree Centrality\\n2) Katz Centrality \\n3) Betweenness Centrality\\n4) Eigenvector Centrality\\n5) Closeness Centrality\\n6) Harmonic Centrality\\n7) Mean Centrality: average of the six above\\n8) Concatenate Centrality: concatenation of the first six\\n\\nEach centrality measure is tested _individually_.\\nThe feature vectors (obtained by concatenating the measures \\nfor all [72] node types) for two code samples asre concatenated \\nand passed to a classifier.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast node type node (node per ast node type) -- edge between two nodes exists iff an edge exists between two nodes of those types in the original ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Tri-Network\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"version history information\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"source code\",\n      \"details\": \"project\"\n    }\n  ],\n  \"vertex-type\": \"developer/module\",\n  \"edge-type\": \"contribution (developer -> module)/dependency (module -> module) -- both co-evolution and call, but a single edge type/collaboration (developer <-> developer) -- two devs modified the same module\",\n  \"vertex-features\": \"node level network metrics \\n\\nvarious software metrics per node (e.g. cyclomatic complexity, number of LOC, etc)\",\n  \"edge-features\": \"contribution edge is weighted by normalised number of commits \\n\\ndependency is weighted by sum of 1) normalised \\\\# of co-change commits, and 2) normalised number of calls \\n\\ncollaboration is weighted by normalised number of jointly changed modules\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "developer/module w. contribution/dependency (co-evolution, call)/collaboration"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Type Dependency Graph\",\n  \"description\": \"Hypergraph representing relationships between types.\\n\\nIn this hypergraph, each edge may connect an arbitrary number of vertices.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Type\",\n      \"details\": \"Some types are intermediary/placeholder types, e.g. introduced for untyped var declarations.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Bool(a)\",\n      \"details\": \"True if a is used as a Boolean\"\n    },\n    {\n      \"name\": \"Subtype(a, b)\",\n      \"details\": \"a is a subtype of b\"\n    },\n    {\n      \"name\": \"Assign(a, b)\",\n      \"details\": \"b is assigned to a\"\n    },\n    {\n      \"name\": \"Function(a, b_1, b_2, ..., b_k, b*)\",\n      \"details\": \"a is a function taking b_1, b_2, ..., b_k as arguments, and returning b*\"\n    },\n    {\n      \"name\": \"Call(a, b*, b_1, b_2,, ..., b_k)\",\n      \"details\": \"The result of calling function of type b* with arguments b_1, b_2, ..., b_k is assigned to a\"\n    },\n    {\n      \"name\": \"Object_{l_1, \\\\hdots, l_k}(a, b_1, ..., b_k)\",\n      \"details\": \"a is an object {l_1 -> b_1,  \\\\hdots, l_k -> b_k}\"\n    },\n    {\n      \"name\": \"Access_l(a, b)\",\n      \"details\": \"a = b.l\"\n    },\n    {\n      \"name\": \"Name_l(a)\",\n      \"details\": \"a has name l\"\n    },\n    {\n      \"name\": \"NameSimilar(a, b)\",\n      \"details\": \"a and b have similar names\\n\\nThe names of a and b are considered similar if their sets of tokens have nonempty intersection.\\nTokenization occurs by splitting on underscores, camelcase, and numbers, and then converting\\nto lowercase.\"\n    },\n    {\n      \"name\": \"Usage_l((a*, b*), (a_1, b_1), ..., (a_k, b_k))\",\n      \"details\": \"Usages involving name l\"\n    }\n  ],\n  \"vertex-features\": \"Nodes corresponding to constants (with known type) are set to a vector which is never updated further.\\n\\nOther nodes are all initialised with the same generic vector.\",\n  \"edge-features\": \"Edge features are based on identifier names (i.e. l_k).\\nEach name is tokenized (as explained above). \\nEach token occurring > 1 times is kept as-is.\\nOther tokens are mapped randomly to one of the <Unknown-i> tokens,\\nwhere 0 <= i <= 50\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "hypergraph connecting types. Edges include subtype, function arguments, call parameters, a=b.l, ,similar names, usage"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Unified Code Property Graph (UCPG)\",\n  \"description\": \"Combination of code property graph, control flow, and NCS\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Function Call Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"NCS Edge\",\n      \"details\": \"Natural code sequence edge\"\n    }\n  ],\n  \"vertex-features\": \"Node content encoded using doc2vec\",\n  \"edge-features\": \"Unidirectional edges are converted to bidirectional edges/backedges are added.\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/control flow/control dependence/data dependence/function call/ncs"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Unique Token Focussed Construction\",\n  \"description\": \"Each unique token has a node,\\nand two tokens are connected if they\\nco-occur in a sliding window of size v.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Token\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Co-occurrence Edge\",\n      \"details\": \"within a sliding window of size v\"\n    }\n  ],\n  \"vertex-features\": \"Tokens embedded using token embedding layer of CodeBERT\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified (adjacency matrix?)\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": null\n}",
      "new": "token w. sliding window co-occurrence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Unique Token Focussed Construction\",\n  \"description\": \"Each unique token has a node,\\nand two tokens are connected if they\\nco-occur in a sliding window of size v.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Token\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Co-occurrence Edge\",\n      \"details\": \"within a sliding window of size v\"\n    }\n  ],\n  \"vertex-features\": \"Tokens embedded using token embedding layer of GrapCodeBERT\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified (adjacency matrix?)\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": null\n}",
      "new": "token w. sliding window co-occurrence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"User-file interaction graph\",\n  \"description\": \"Models interactions between users and files in open source systems.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Contributor Data\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Source Code File\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"User\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Contributed to\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Vertex features are initialised with user embeddings for users,\\nand the structure-enhanced file representations for source files.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"The source code of files is partitioned into N_C code segments,\\nwhich are encoded using CodeBERT.\\n\\nA number N_Q of historical users are sampled and encoded.\\n\\nFor every file, the code segments (C) and users (U) are used \\nto compute (and learn) attention weights h, which are used \\nto compute the _file attention representation_ h = a^T C\"\n}",
      "new": "file/user w. contribution"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"User-project interaction graph\",\n  \"description\": \"Models interactions between users and projects in open source systems.\\n\\nNote that multiple such graphs may exists based on multiple \\ninteraction types (\\\"behaviours\\\").\",\n  \"artefacts\": [\n    {\n      \"name\": \"Repository\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Contributor Data\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Repository\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"User\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Contributed to\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Vertex features are initialised with user embeddings for users,\\nand the structure-enhanced repository representations for projects.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "user/repository w. contribution"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Vulnerability Dependence Representation Graph (VDRG)\",\n  \"description\": \"Based on PDG\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Dependence Edge\",\n      \"details\": \"Regular Control Dependence Edge\"\n    },\n    {\n      \"name\": \"Vulnerability Control Dependence Edge\",\n      \"details\": \"Control Dependence Edge pointing to a statement \\nwhich was marked as syntactically being potentially vulnerable (SyVC).\\n\\nControl Dependence Edges are marked as Vulnerability Control Dependence Edges\\nif one of the following is true:\\n1) The edge points to a statement that is marked as syntactically potentially vulnerable.\\n2) The edge transitively points to a statement that is marked as syntactically potentially vulnerable.\"\n    },\n    {\n      \"name\": \"Data Dependence Edge\",\n      \"details\": \"Regular Data Dependence Edge\"\n    },\n    {\n      \"name\": \"Vulnerability Data Dependence Edge\",\n      \"details\": \"Data Dependence Edge pointing to a statement \\nwhich was marked as syntactically being potentially vulnerable (SyVC).\\n\\nData Dependence Edges are marked as Vulnerability Data Dependence Edges\\nif one of the following is true:\\n1) The edge points to a statement that is marked as syntactically potentially vulnerable.\\n2) The edge transitively points to a statement that is marked as syntactically potentially vulnerable.\"\n    }\n  ],\n  \"vertex-features\": \"Names are normalised.\\n\\nNode are encoded using word2vec.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "pdg (w/ specific edge types for control/data dependencies of particular interest to vulnerability, determined using SyVC -- syntactic vulnerability candidate)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Vulnerability Property Graph\",\n  \"description\": \"Code property graph enhanced for vulnerability detection\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Token Edge\",\n      \"details\": \"Edge from one token (leaf node) to the next\"\n    }\n  ],\n  \"vertex-features\": \"Features based on AST payload; identifiers, keywords, names, types etc. (yes, the paper says etcetera).\\n\\nEncoded using Word2Vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/control flow/data flow/ncs"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Weighted Directed Class Coupling Network (WDCCN)\",\n  \"description\": \"Graph representing different types of coupling between classes,\\nwith different weights depending on the type of coupling.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code (project)\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Class\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"LVA\",\n      \"details\": \"Local Variable; For edge (u, v), class u contains a local variable of type v in a method.\"\n    },\n    {\n      \"name\": \"GVA\",\n      \"details\": \"Global Variable; For edge (u, v), class u contains a field of type v.\"\n    },\n    {\n      \"name\": \"INH\",\n      \"details\": \"Inheritance;  For edge (u, v), class u inherits from class v.\"\n    },\n    {\n      \"name\": \"IMP\",\n      \"details\": \"Implementation; For edge (u, v), class u implements interface v.\"\n    },\n    {\n      \"name\": \"PAR\",\n      \"details\": \"Parameter; For edge (u, v), class u contains method with a parameter of type v.\"\n    },\n    {\n      \"name\": \"RET\",\n      \"details\": \"Return; For edge (u, v), class u contains method with a return type of type v.\"\n    },\n    {\n      \"name\": \"INS\",\n      \"details\": \"Instantiates; For edge (u, v), class u instantiates class v.\"\n    },\n    {\n      \"name\": \"ACC\",\n      \"details\": \"Access; For edge (u, v), class u accesses a field of class v\"\n    },\n    {\n      \"name\": \"MEC\",\n      \"details\": \"Method Call; For edge (u, v), class u calls a method of class v.\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"Edge features based on distribution with which coupling occurs in a project.\\n\\nLet N denote the intra-package coupling of some type, and M the inter-package coupling.\\nThen, the weight is defined as:\\n\\n10 if N > 0 and M = 0\\n1 if N = M = 0\\nround(0.5 + 10 * N / (N + M)) otherwise\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "class w. dependencies (weighted)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Weighted Directed Class Coupling Network (WDCCN)\",\n  \"description\": \"Graph representing different types of coupling between classes,\\nwith different weights depending on the type of coupling.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code (project)\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Class\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"LVA\",\n      \"details\": \"Local Variable; For edge (u, v), class u contains a local variable of type v in a method.\"\n    },\n    {\n      \"name\": \"GVA\",\n      \"details\": \"Global Variable; For edge (u, v), class u contains a field of type v.\"\n    },\n    {\n      \"name\": \"INH\",\n      \"details\": \"Inheritance;  For edge (u, v), class u inherits from class v.\"\n    },\n    {\n      \"name\": \"IMP\",\n      \"details\": \"Implementation; For edge (u, v), class u implements interface v.\"\n    },\n    {\n      \"name\": \"PAR\",\n      \"details\": \"Parameter; For edge (u, v), class u contains method with a parameter of type v.\"\n    },\n    {\n      \"name\": \"RET\",\n      \"details\": \"Return; For edge (u, v), class u contains method with a return type of type v.\"\n    },\n    {\n      \"name\": \"INS\",\n      \"details\": \"Instantiates; For edge (u, v), class u instantiates class v.\"\n    },\n    {\n      \"name\": \"ACC\",\n      \"details\": \"Access; For edge (u, v), class u accesses a field of class v\"\n    },\n    {\n      \"name\": \"MEC\",\n      \"details\": \"Method Call; For edge (u, v), class u calls a method of class v.\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"Edge weights based on existing ordinal rankings in literature,\\nre-mapped to correspond to the proposed edge types.\\n  \\nWeights:\\nLVA: 1\\nGVA: 5.5\\nINH: 9\\nIMP: 10\\nPAR: 1\\nRET: 1\\nINS: ignored \\nACC: ignored \\nMEC: 1\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "class w. dependencies (weighted)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Weighted Directed Class Coupling Network (WDCCN)\",\n  \"description\": \"Graph representing different types of coupling between classes,\\nwith different weights depending on the type of coupling.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code (project)\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Class\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"LVA\",\n      \"details\": \"Local Variable; For edge (u, v), class u contains a local variable of type v in a method.\"\n    },\n    {\n      \"name\": \"GVA\",\n      \"details\": \"Global Variable; For edge (u, v), class u contains a field of type v.\"\n    },\n    {\n      \"name\": \"INH\",\n      \"details\": \"Inheritance;  For edge (u, v), class u inherits from class v.\"\n    },\n    {\n      \"name\": \"IMP\",\n      \"details\": \"Implementation; For edge (u, v), class u implements interface v.\"\n    },\n    {\n      \"name\": \"PAR\",\n      \"details\": \"Parameter; For edge (u, v), class u contains method with a parameter of type v.\"\n    },\n    {\n      \"name\": \"RET\",\n      \"details\": \"Return; For edge (u, v), class u contains method with a return type of type v.\"\n    },\n    {\n      \"name\": \"INS\",\n      \"details\": \"Instantiates; For edge (u, v), class u instantiates class v.\"\n    },\n    {\n      \"name\": \"ACC\",\n      \"details\": \"Access; For edge (u, v), class u accesses a field of class v\"\n    },\n    {\n      \"name\": \"MEC\",\n      \"details\": \"Method Call; For edge (u, v), class u calls a method of class v.\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"Weights fine-tuned based on performance in architecture reconstruction.\\n  \\nWeights:\\nLVA: 1\\nGVA: 3\\nINH: 3\\nIMP: 4\\nPAR: 3\\nRET: 3\\nINS: 2 \\nACC: 2 \\nMEC: 2\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "class w. dependencies (weighted)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"Weighted Directed Class Graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"project\"\n    }\n  ],\n  \"vertex-type\": \"class\",\n  \"edge-type\": \"inheritance coupling/method coupling/data coupling\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"edges are weighted (e.g number of method called)\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "class w. dependencies (weighted)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"\\\\alpha AST (Annotated AST)\",\n  \"description\": \"AST representing a commit, i.e. a change from old to new code.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code (commit)\",\n      \"details\": null\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Nodes from both the AST of the old and the new code are present.\\n\\nNodes are annotated with \\\"unchanged\\\", \\\"added\\\", or \\\"deleted\\\"\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"Edges are annotated with \\\"unchanged\\\", \\\"added\\\", or \\\"deleted\\\"\"\n    }\n  ],\n  \"vertex-features\": \"Node content embedded using word2vec.\\nChange action (unchanged/added/deleted) is one hot encoded \\n\\ncontent and action embeddings are concatenated.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast (annotated according to changes in old vs new version)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"\\\\delta-ndg\",\n  \"description\": \"start with two separate graphs, merge based on unchanged nodes\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"commit\"\n    }\n  ],\n  \"vertex-type\": \"statement\",\n  \"edge-type\": \"control dependence/data dependence/name flow\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "statement w. control dependence/data dependence/name flow (two graphs old/new, merged based on unchanged nodes)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast (binarised)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"leaf node content encoded using word2vec.\\n\\nnode types weighted using tf/idf\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"source code text\"\n}",
      "new": "ast (binarised)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast (binarized)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": \"ast/null nodes (inserted to make a full binary tree out of the ast)\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"every node is represented as a 3-entry vector,\\nwhere the first entry is the ordinal encoding of the node types,\\nand the other two entries carry additional information about the node.\\n\\nnull nodes are encoded as (0, 0, 0)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Note is put into sequence using breadth first traversal\"\n}",
      "new": "ast (binarised)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast (binarized)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"source code text is used as feature\"\n}",
      "new": "ast (binarised)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast (partial)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"n/a\",\n      \"details\": \"generated by model\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"each node represented by an embedding, unclear how it is computed\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Description of code to be generated is used as feature (embedding unclear).\\n\\nPreviously outputted grammar rules (sequence) are used as features.\\n\\npath from root to next node to expand is used as feature.\\n\\nMethod/function scope is used as feature (nearest enclosing scope)\"\n}",
      "new": "ast (partial; generated by model)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast (partial)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"n/a\",\n      \"details\": \"generated by model\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"The AST is represented as a sequence or rule expansions.\",\n  \"other-features\": \"Natural language description of the code to be generated \\n\\nNode to be expanded represented as path from root to node, encoded with the node types\"\n}",
      "new": "ast (partial; generated by model)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast + pdg (pruned)\",\n  \"description\": \"mix of ast and pdg (pruned)\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"javascript\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/control dependence/data dependence\",\n  \"vertex-features\": \"node type word2vec\",\n  \"edge-features\": \"edge type one-hot\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/control dependence/data dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"methods\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"type and value of nodes, encoded using BERT\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"source code tokens used as feature\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code method\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": null,\n  \"edge-features\": null,\n  \"connectivity-features\": null,\n  \"graph-features\": null,\n  \"other-features\": \"code is split into a sequence of tokens per statement. (identifiers into sub tokens)\\n\\nThe AST is linearised per statement (node type or tokens) (subtree per statement);\\ntokens are split into subtokens\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"file (I think)\"\n    }\n  ],\n  \"vertex-type\": \"ast (only certain node types are kept)\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"not specified, though images imply type for nonterminals, and tokens for terminals\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"pre-order sequence of nodes, encoded using model-1, is used as input for model-2.\\n\\nHand-crafted detection-related features are used.\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"file\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"code tokens embedded using GloVe\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified, but presumably adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"bug report is used as feature \\n\\nsource code text is used as a feature\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"file\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"AST is linearised (both types and tokens) using pre-order traversal,\\nwhere only certain node types are included in the sequence.\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"file\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"node type\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"AST is linearised, where only certain node types are kept.\\nNode types are replaced with their code token(s) if they represent identifiers.\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"file\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"node type, unclear if content (code tokens) are also used, but seems to be only node type\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"AST linearised. Tokens (node type; code tokens unclear if used) are encoded using Glove.\\n\\ntraditional code metrics are also used as features.\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"source code text is used as feature \\n\\nTerminal to terminal (\\\"relative\\\") paths are extracted (only the nonterminals in the path are used)\\n\\nTerminal to root (\\\"absolute\\\") paths are extracted (only the nonterminals in the path are used)\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"incomplete snippet (while live editing)\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"javascript\"\n    }\n  ],\n  \"vertex-type\": \"ast node\",\n  \"edge-type\": \"ast edge\",\n  \"vertex-features\": \"unclear (not specified)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"method (s) (possibly multiple at once)\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"Statement corresponding to node encoded using GloVe\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"Buggy sub-tree is summarised using TreeCaps.\\n\\nFor training, each buggy sub-tree is replaced \\nwith its fixed sub-tree. The pairs of trees \\nare used for the context learning model.\\n\\nFor the working phase, each buggy tree is replaced with its \\nsummarised vector.\\n\\nWe call this the context tree\\n\\nEach node in a buggy sub-tree is multiplied by its context vector;\\nfor the old versions, this is the output of TreeCaps. For new versions,\\nthis is output of TreeCaps (training), or the predicted node from the \\ncontext model (working)\",\n  \"other-features\": \"Bug detector is used to collect buggy statements \\nand suspiciousness scores; consecutive statements are grouped into hunks.\\nBERT is used to determine which hunks must be fixed together.\\nOverall goal: given a function/method with multiple faulty statements (subtrees),\\nfix them all\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"method\"\n    }\n  ],\n  \"vertex-type\": \"all identifiers (incl. node types) are split into subtokens.\\nFor lexical nodes, both the type and token(s) are put in a sequence;\\nfor syntax nodes only the type\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": null,\n  \"edge-features\": null,\n  \"connectivity-features\": null,\n  \"graph-features\": null,\n  \"other-features\": \"code (w/ identifiers split into sub-tokens) is used as feature\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"method\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"code text is used as feature\\n\\nsummary thus far is used as feature\\n\\nast is converted to sequence, where brackets are used \\nto keep structure, node name is used primarily, and lexical\\nelements are added to the node name, like in \\\"SimpleName_String\\\"\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"method\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"every statement in the tree as follows: e.g. MethodDeclaration(Modifier(protected))(sendMessage)...(body)\\nThis results in a sequence of such statements \\n\\nmethod name (split up into sequence) is used as feature \\n\\nsequence of APIs used in the method is used as feature\\n\\nbag of tokens used in the snippets is used as feature \\n\\ncode summary/query is used as feature\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"method\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"nodes put into sequence using breath first search\\n\\nmethod name (split up into sequence) is used as feature \\n\\nsequence of APIs used in the method is used as feature\\n\\nbag of tokens used in the snippets is used as feature \\n\\ncode summary/query is used as feature\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"method\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"node type\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"pre-order depth first traversal to create a sequence of nodes.\\nFrom this sequence, n-grams are constructed. \\nBinary encoding of the present n-grams is used as feature.\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"method\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"not clearly specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"module\"\n    }\n  ],\n  \"vertex-type\": \"ast (only specific node types are kept)\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"node type\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"pre-order traversal sequence of ast nodes.\"\n}",
      "new": "ast (trimmed)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast (binarised)\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"node type and content, both using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast (binarised)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast (nonterminal nodes only)\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"node type\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"nodes are put into bread-first sequence; \\nfor every node, it is replaced by a list consisting of itself and its direct children\\npadding is applied\\nresult: matrix of size (max_subtrees x max_children)\"\n}",
      "new": "ast (syntax nodes)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast w/ subtokens\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"content CodeBERT\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast + subtokens"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"Node content (Nonterminal, with payload for leave nodes)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"depth-first traversal of AST, while inserting brackets (<, >) to denote subtrees\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"code (token) payload according to a weighted sum of the one-hot encoding of its characters\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"linearised using depth first traversal, \\nyielding a stream of node types and code tokens.\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"serialised using depth first traversal; sequence of node types and tokens, encoded using word2vec\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"node content encoded using tf-idf / doc2vec (2 sets of experiments)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"node embeddings are learned by appying continuous skip-gram to the AST structure\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"node type for nonterminals, source code tokens for terminals\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"The set of paths from the root to each terminal node is used for the features. \\nFor each path, the nodes (type or tokens) are put into sequence. \\n\\nnode location information is used as feature\\n\\nThe original code snippet is tokenised\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"node type\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"byte code sequence \\n\\nsequence of identifiers and constants from the code\\n\\npre-order sequence of ast node types\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": null,\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Paths between two terminals (incl. directions) are used as features\\nFor the terminal nodes, tokens are features. \\nThe path itself (sequence of types, interlaced with up/down directions) are also features (i.e. a full path is a single feature)\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"smart contracts\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Depth first traversal to generate:\\n1) node type sequence \\n2) node value sequence\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"snippets\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Paths between terminal nodes are extracted from the AST.\\nFor the terminal nodes, tokens are features. \\nThe path itself (sequence of types, interlaced with up/down directions) are also features (i.e. a full path is a single feature)\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"pruned using Louvian community detection algorithm (only \\\"defect related communities\\\" of nodes are kept)\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"module\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"node type, exact encoding is unclear. Combined with the topic vector (see \\\"other features\\\"), which is identical for all nodes.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"For each defective module, LDA is used to extract a topic based on subtokens \\nin method names, variable names, class names etc., taking the top-k words.\\nThe topic is encoded using word2vec.\\nI think the topic vectors are then averaged\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ast\",\n  \"description\": \"split into statement trees; subtrees containing a statement as root\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"word2vec for node type (non-leaf) or lexical payload (leaf)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"see description; split into statement trees; subtrees containing a statement as root \\nstatement trees are ordered in depth first fashion (from the perspective of the full ast)\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"cdg (control dependence graph)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"statement\",\n  \"edge-type\": \"control dependence\",\n  \"vertex-features\": \"node content encoded using tf-idf / doc2vec (2 sets of experiments)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "statement w. control dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"cfg\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"statement\",\n  \"edge-type\": \"control flow\",\n  \"vertex-features\": \"node content encoded using tf-idf / doc2vec (2 sets of experiments)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "cfg (statement)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"cfg\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"statement\",\n  \"edge-type\": \"control flow\",\n  \"vertex-features\": null,\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Paths from the method start to either a return statement\\nor earlier visited path (loop structure) are used as features\\n\\nExact details not specified, but based on code2vec we would have that the path (sequence of types) is the feature\"\n}",
      "new": "cfg (statement)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"cfg\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"statement/basic block\",\n  \"edge-type\": \"control flow\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "cfg (statement)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"cfg\",\n  \"description\": \"n/a\",\n  \"vertex-type\": \"statement\",\n  \"edge-type\": \"control flow\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"High-Order Proximity preserved Embedding (HOPE) for node embedding; then take average\",\n  \"other-features\": \"n/a\"\n}",
      "new": "cfg (statement)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"class dependency network\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"project\"\n    }\n  ],\n  \"vertex-type\": \"classes\",\n  \"edge-type\": \"dependencies\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "class/interface dependency network"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"code structure graph (csg)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/data dependence/control dependence/control flow/ncs\",\n  \"vertex-features\": \"word2vec (unclear what)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"32 different meta-paths are used (expression, statement, symbol level)\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/control flow/control dependence/data dependence/ncs"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"commit graph\",\n  \"description\": \"separate graphs are created for old and new code, which are then merged based on common nodes.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"commit\"\n    }\n  ],\n  \"vertex-type\": \"statements\",\n  \"edge-type\": \"control flow/data flow/name flow [data flow considering variable names]/sub-token co-occurrence\",\n  \"vertex-features\": \"node value BERT\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified, presumable adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "statement w. contrlol flow/data flow/name flow/sub-token co-occurence (two graphs old/new merged on unchanged nodes)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"cpg\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/control dependence/control flow/data dependence\",\n  \"vertex-features\": \"node type ordinal, node content (encoding unclear)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/control dependence/control flow/data dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ddg (data dependence graph)\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"statement\",\n  \"edge-type\": \"data flow\",\n  \"vertex-features\": \"node content encoded using tf-idf / doc2vec (2 sets of experiments)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "statement w. data dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"dependency tree\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/def-use relations\",\n  \"vertex-features\": \"node type\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/def-use relations"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"ePDG\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"source code is first compiled to LLVM IR\"\n    }\n  ],\n  \"vertex-type\": \"instruction (slicing performed based on vulnerability-correlated instruction types)\",\n  \"edge-type\": \"control flow/dependence and data flow/dependence\",\n  \"vertex-features\": \"operation type, basic function, is instruction part of if-clause (all one-hot)/classical graph metrics\",\n  \"edge-features\": \"edge type / data flow edges have the data type(s) of the dependency as attributes\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "instruction w. data flow/control flow/data dependence/control dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"fcg\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"function\",\n  \"edge-type\": \"function call\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "fcg"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"field focussed graph\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"class\"\n    }\n  ],\n  \"vertex-type\": \"methods/fields/constructors/semantic relations (calls, reads, writes, sync, modifier)\",\n  \"edge-type\": \"method/fields/constructors are connected with undirected edges, with a semantic node inbetween them\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"several subgraphs are isolated, by taking all subsets of <= 2 methods/fields/constructors,\\nand extracting the subgraphs reachable from those nodes.\",\n  \"other-features\": \"Every subgraph is encoded using the  Weisfeiler Lehman kernel. \\nThe resulting vectors are combined by first computing three vectors through min/max/mean pooling,\\nand then concatenating these.\"\n}",
      "new": "methods/fields/constructors/semantic relation nodes (callls, reads, writes, sync, modifier); the former node types are connected through untyped edges with a semntic relation node in between"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"AST augmented with additional information\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Variable Node\",\n      \"details\": \"One node for each variable.\\nAll occurrences of a variable are attached to the unique note for that variable\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Child Edge\",\n      \"details\": \"Regular AST Edge\"\n    },\n    {\n      \"name\": \"Sibling Edge\",\n      \"details\": \"Connect child node to its sibling successor (represent order or \\\"arguments\\\" for an AST Node)\"\n    },\n    {\n      \"name\": \"Read Edge\",\n      \"details\": \"Used to connect a variable occurrence to the unique node for that variable\"\n    },\n    {\n      \"name\": \"Write Edge\",\n      \"details\": \"Used to connect a variable occurrence to the unique node for that variable\"\n    },\n    {\n      \"name\": \"Chronological Edge\",\n      \"details\": \"Establish order between nodes referencing the same variable name\"\n    }\n  ],\n  \"vertex-features\": \"Not specified what is used for node features\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast + unique variable node w. ast/sibling/data dependence/ordering of nodes accessing the same variable/all occurrences of a variable connected to the unique variable node"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"AST augmented with information from markdown\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"snippets from Jupyter notebooks\"\n    },\n    {\n      \"name\": \"Markdown Text\",\n      \"details\": \"Natural language from Markdown from the Jupyter notebooks\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Virtual / classification token ([CLS])\",\n      \"details\": \"Always at the start of the token sequence\"\n    },\n    {\n      \"name\": \"Markdown token node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Classification ([CLS]) Edge\",\n      \"details\": \"Every node is connected to the [CLS] node\"\n    },\n    {\n      \"name\": \"Markdown Edge\",\n      \"details\": \"For a given snippet, each AST node in its AST is connected \\nto a node for every token the most recent markdown block \\n(occurring within 3 blocks)\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"The entire graph is sequenced using depth-first traversal,\\nbeginning with [CLS]\"\n}",
      "new": "ast/markdown token/CLS w. ast/ast-markdown edge/every node connected to CLS"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"AST with added control and data flow edges\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code (methods)\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"Edges between different uses of the same variable.\\n\\nType 1: Starting from the declaration, each usage of the \\nvariable points to the next usage.\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"Edges between Statement node. \\nEvery statement node points to all statements node which can \\nimmediately follow it in execution. \\nExample: fallible operations pointing to the next statement,\\nbut also the encapsulating catch block.\"\n    }\n  ],\n  \"vertex-features\": \"Node type is one-hot encoded.\\n\\nThe source code snippets corresponding to every node \\n(including comments) is represented as a sequence of \\ntokens, where every token is encoded using CodeBERT.\\n\\nThe average vector of all encoded tokens is computed,\\nand concatenated to the one-hot encoded node type.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/data flow/control flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"AST with added control and data flow edges\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code (methods)\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"Edges between different uses of the same variable.\\n\\nType 2: The declaration of a variable points to every usage of that variable.\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"Edges between Statement node. \\nEvery statement node points to all statements node which can \\nimmediately follow it in execution. \\nExample: fallible operations pointing to the next statement,\\nbut also the encapsulating catch block.\"\n    }\n  ],\n  \"vertex-features\": \"Node type is one-hot encoded.\\n\\nThe source code snippets corresponding to every node \\n(including comments) is represented as a sequence of \\ntokens, where every token is encoded using CodeBERT.\\n\\nThe average vector of all encoded tokens is computed,\\nand concatenated to the one-hot encoded node type.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/data flow/control flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"AST with added control and data flow edges\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code (methods)\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"Edges between different uses of the same variable.\\n\\nType 3: The declaration of a variable points to every usage of that variable.\\nAdditionally, starting from the declaration, each usage of the \\nvariable points to the next usage. (combined type 1 and type 2)\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"Edges between Statement node. \\nEvery statement node points to all statements node which can \\nimmediately follow it in execution. \\nExample: fallible operations pointing to the next statement,\\nbut also the encapsulating catch block.\"\n    }\n  ],\n  \"vertex-features\": \"Node type is one-hot encoded.\\n\\nThe source code snippets corresponding to every node \\n(including comments) is represented as a sequence of \\ntokens, where every token is encoded using CodeBERT.\\n\\nThe average vector of all encoded tokens is computed,\\nand concatenated to the one-hot encoded node type.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/data flow/control flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"AST with additional control and data flow edges. Note that all edges are undirected\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Next token\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Computed From\",\n      \"details\": \"e.g. assigment target to expression\"\n    },\n    {\n      \"name\": \"Guarded By\",\n      \"details\": \"Edge from each variable in an if-block to the condition of the if-block\"\n    },\n    {\n      \"name\": \"Jump\",\n      \"details\": \"Edge between variables with control dependencies\"\n    },\n    {\n      \"name\": \"Last Use\",\n      \"details\": \"Edge between uses of the same variable\"\n    },\n    {\n      \"name\": \"Last Lexical Use\",\n      \"details\": \"Edge between uses of variable with the same name in different branches of a conditional\"\n    }\n  ],\n  \"vertex-features\": \"Vertex payload (instruction, token, node type) is encoded using Word2Vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"For every edge type, a separate adjacency matrix is created, where \\nback-edges are added for every edge (i.e. the adjacency matrix is symmetric).\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/data flow/data dependence/control flow/ncs"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"AST with additional data- and control flow edges\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"smart contract\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Next Node\",\n      \"details\": \"Added if two nodes are adjacent in the depth first traversal of the AST\"\n    },\n    {\n      \"name\": \"Next Token\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Condition True\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Condition False\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"While Exec\",\n      \"details\": \"Connect root of condition subtree to root of body subtree\"\n    },\n    {\n      \"name\": \"For Exec\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Last Read\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Last Write\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Next Use\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Unclear what exactly is used as feature. \\nSeems to be token for leaf nodes, nonterminal for non-leaf nodes.\\nPaper does not mention specific features.\\n\\nUnclear how feature are encoded.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/ncs/control flow/data dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"AST with additional edges\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Next Subtree Edge\",\n      \"details\": \"Connects node on the same level\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Not specified\",\n  \"edge-features\": \"Edge type\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Source code is used as input\\n\\nCode summary generated thus far is used as input.\"\n}",
      "new": "ast w. ast/next subtree (connect nodes on same level)/data flow/control flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"AST with additional edges\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Next Token Edge\",\n      \"details\": \"NCS\"\n    },\n    {\n      \"name\": \"Hub Edge (My name; does not have a name in the paper)\",\n      \"details\": \"Connects node with types which generally have \\nmany child nodes (e.g. ClassDeclaration, MethodDeclaration)\"\n    }\n  ],\n  \"vertex-features\": \"Word vectors are used to encode node (unclear what exactly is encoded; could be node type for internal nodes, token for leafs)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency List\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/ncs/hub (connect nodes which generally have many child nodes)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"AST with additional edges\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Child\",\n      \"details\": \"Regular AST Edge\"\n    },\n    {\n      \"name\": \"Subtoken\",\n      \"details\": \"From a token (AST leaf node) to its subtokens (after splitting)\"\n    },\n    {\n      \"name\": \"Next Token\",\n      \"details\": \"NCS\"\n    },\n    {\n      \"name\": \"Last Lexical Use\",\n      \"details\": \"Connect occurrence of variable name to its most recent previous occurrence\"\n    }\n  ],\n  \"vertex-features\": null,\n  \"edge-features\": null,\n  \"connectivity-features\": null,\n  \"graph-features\": null,\n  \"other-features\": \"During training, ground truth token is given as input x'_j;\\nduring testing, previous token x'_j is given as input.\"\n}",
      "new": "ast+sub-token w. ast/sub-token/ncs/data dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"AST with additional edges. \\n\\nThere might be more edges than listed in the list below. \\nThe paper is unclear about this.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"If Edge\",\n      \"details\": \"Connects If statement node with condition and block\"\n    },\n    {\n      \"name\": \"For Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"While Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/control dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"AST with data flow information\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"Data flow between leaf nodes\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Code tokens are one-hot encoded (unclear how  this works)\"\n}",
      "new": "ast w. ast/data flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"AST with data flow information\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Nodes are one-hot encoded.\\n\\nUnclear what specifically is encoded.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Source code is tokenizes line-by-line, with CamelCase and under_scores split up. Tokens are one-hot encoded.\"\n}",
      "new": "ast w. ast/data flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"AST with various additional edges\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Syntax Node\",\n      \"details\": \"internal node/corresponds to nonterminal\"\n    },\n    {\n      \"name\": \"Syntax Token\",\n      \"details\": \"leaf node/contains program tokens\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Child Edge\",\n      \"details\": \"AST Edge (undirected)\"\n    },\n    {\n      \"name\": \"Next Token Edge\",\n      \"details\": \"NCS (undirected)\"\n    },\n    {\n      \"name\": \"Last Read Edge\",\n      \"details\": \"For syntax tokens corresponding to variables,\\nwe connect those tokens to all possible places \\nthe variable could have been read last. \\n(undirected)\"\n    },\n    {\n      \"name\": \"Last Write Edge\",\n      \"details\": \"For syntax tokens corresponding to variables,\\nwe connect those tokens to all possible places \\nthe variable could have been written to last.\\n(undirected)\"\n    },\n    {\n      \"name\": \"Computed From\",\n      \"details\": \"In an assignment v = expr, connect v to all\\nvariables used in the expression\\n(undirected)\"\n    },\n    {\n      \"name\": \"Last Lexical Use\",\n      \"details\": \"Connect occurrences of same variable in different \\ndata flow, e.g. if (...) { ... v ... } else { ... v ... }\\n(undirected)\"\n    },\n    {\n      \"name\": \"Returns To\",\n      \"details\": \"Connect return token to the method declaration (undirected)\"\n    },\n    {\n      \"name\": \"Formal Arg Name\",\n      \"details\": \"Connect actual arguments the formal arguments;\\ne.g. given bar(x) and bar(Integer y), connect x to y\\n(undirected)\"\n    },\n    {\n      \"name\": \"Guarded By\",\n      \"details\": \"Connect every variable token guarded by a conditional (if) \\nto the guard expression \\n(undirected)\"\n    },\n    {\n      \"name\": \"Guarded By Negation\",\n      \"details\": \"Connect every variable token guarded by the negation of a \\nconditional (else) to the guard expression \\n(undirected)\"\n    }\n  ],\n  \"vertex-features\": \"Syntax nodes use the node type name as a text feature.\\nSyntax tokens use the program content as a text feature.\\n\\nText payload is split into subtokens, each of which is \\nembedded (unclear how); average of embedding is computed.\\n\\nAll types are embedded using a trainable embedding layer.\\nEach variable has a type, which is encoded as the \\nelement-wise maximum of that type, and all its super-types\\n(including implementation relations).\",\n  \"edge-features\": \"In case of the var-misuse task, some adjustments are made to the graph:\\n1) The node corresponding to the slot is removed, and replaced with a context node\\n2) All LastUse, LastWrite, LastLexicalUse, and GuardedBy edges to the context node are removed \\n3) For every possible candidate variable, a new node is added, connected by the \\n    LastUse, LastWrite, and LastLexicalUse edges of the old node\",\n  \"connectivity-features\": \"adjacency list\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/ncs/data dependence/control flow/control dependence (_not_ cpg w/ ncs)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"AST with various additional edges\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Syntax Node\",\n      \"details\": \"internal node/corresponds to nonterminal\"\n    },\n    {\n      \"name\": \"Syntax Token\",\n      \"details\": \"leaf node/contains program tokens\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Child Edge\",\n      \"details\": \"AST Edge\"\n    },\n    {\n      \"name\": \"Subtoken Edge\",\n      \"details\": \"Sub token\"\n    },\n    {\n      \"name\": \"Next Token Edge\",\n      \"details\": \"NCS\"\n    },\n    {\n      \"name\": \"Last Read Edge\",\n      \"details\": \"For syntax tokens corresponding to variables,\\nwe connect those tokens to all possible places \\nthe variable could have been read last.\"\n    },\n    {\n      \"name\": \"Last Write Edge\",\n      \"details\": \"For syntax tokens corresponding to variables,\\nwe connect those tokens to all possible places \\nthe variable could have been written to last.\"\n    },\n    {\n      \"name\": \"Computed From\",\n      \"details\": \"In an assignment v = expr, connect v to all\\nvariables used in the expression\"\n    }\n  ],\n  \"vertex-features\": \"Unclear how tokens are embedded\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast + sub-token w. ast/sub-token/ncs/data dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"AST with various augmentations\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST node\",\n      \"details\": \"Basic structure is AST, with some simplifications:\\n\\n1) mentions of the same variable inside the name function are merged into a single node\\n2) mentions of the same function/class in a file are merged into a single node\\n3) All constants are erased and replaced with one global (shared) node \\n3) All identifiers are suffixed with their (inner-most) scope\"\n    },\n    {\n      \"name\": \"Subword node\",\n      \"details\": \"Identifiers in code are split into subwords, and each subword is represented by a separate node\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Next/Prev edge\",\n      \"details\": \"Next/prev edges between successive expressions\"\n    },\n    {\n      \"name\": \"Control block edge\",\n      \"details\": \"All expressions in a control block (e.g. if) link back to the parent control operator (e.g. if)\"\n    },\n    {\n      \"name\": \"function call edge (cross-file)\",\n      \"details\": \"Function callee is linked to called function\"\n    },\n    {\n      \"name\": \"Inheritance edge (cross-file)\",\n      \"details\": \"Child class is linked to parent class\"\n    },\n    {\n      \"name\": \"Import edge (cross-file)\",\n      \"details\": \"Link items in one file to items from other files\"\n    },\n    {\n      \"name\": \"Subword edge\",\n      \"details\": \"Edge from every subword (e.g. \\\"a\\\") to all nodes containing that subword (e.g. \\\"a@FunctionDef_scale\\\")\"\n    }\n  ],\n  \"vertex-features\": \"Not specified (unclear how initial vector representation is determined)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast + sub-token w. ast/linear control/control dependence/function call/inheritance/import/sub-token"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"Based on a meta model for source code and design patterns defined in \\n\\nMario Luca Bernardi, Marta Cimitile, and Giuseppe Di Lucca. 2014. Design\\npattern detection using a DSL-driven graph matching approach. Journal of\\nSoftware: Evolution and Process 26, 12 (2014), 1233\\u00e2\\u20ac\\u201c1266. https://doi.org/\\n10.1002/smr.1674\\n\\nThis describes graphs for design patterns\",\n  \"artefacts\": [\n    {\n      \"name\": \"Design Pattern Specifications\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Nodes from meta-model.\\n\\nGraphs are centered around pivotal nodes (classes, interfaces, methods);\\nother types of nodes are thus ignored.\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Edges from meta-model\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a (unclear how node embeddings are initialised)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "design pattern specification meta model -- design pattern"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"Based on a meta model for source code and design patterns defined in \\n\\nMario Luca Bernardi, Marta Cimitile, and Giuseppe Di Lucca. 2014. Design\\npattern detection using a DSL-driven graph matching approach. Journal of\\nSoftware: Evolution and Process 26, 12 (2014), 1233\\u00e2\\u20ac\\u201c1266. https://doi.org/\\n10.1002/smr.1674\\n\\nThis describes graphs for source code.\\n\\nFor source code specifically, k-hop neighbourhoods are extracted from the\\nsystem (metamodel) graph.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Nodes from meta-model\\n\\nGraphs are centered around pivotal nodes (classes, interfaces, methods);\\nother types of nodes are thus ignored.\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Edges from meta-model\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"n/a (unclear how node embeddings are initialised)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "design pattern specification meta model -- source code"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"Based on graphs in recommendation systems\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"multiple files/project\"\n    }\n  ],\n  \"vertex-type\": \"method declarations/APIs/structural (classes, packages, non-method stuff)\",\n  \"edge-type\": \"method <-> API calls/project structure  (e.g. belongs to)\",\n  \"vertex-features\": \"method/class/package name split up into words\\n\\nunique ID per node\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "program elements (methods, apis, classes packages etc) w. method <-> api calls/project structure (eg. belongs to)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"Based on syntactic dependency parsing from NLP\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code (methods)\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST leaf nodes\",\n      \"details\": \"During evaluation, tokens in the leaf nodes were lowered,\\nnon-identifier tokens were removed, and rare tokens were \\nalso removed, thus reducing the number of nodes present \\nin the final graph.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"n/a\",\n      \"details\": \"For every (source, target) pair (v1, v2) of AST nodes, \\nfind the least common ancestor of v1 and v2 in the AST.\\nThe edge label is given by \\n1) taking every node in the path from v1 to the ancestor,\\n  and adding an \\\"up\\\" arrow after every node type name\\n2) Taking every node in the path from the ancestor to v2,\\n  and adding an \\\"down\\\" arrow after every node type name\\n3) Concatenating all nodes in the path (as described above)\\n  using \\\"-\\\" symbols.\\n\\nIf the path is longer than some threshold, it is ignored.\\nOtherwise, the edge is present in the final graph.\"\n    }\n  ],\n  \"vertex-features\": \"Not specified, nor specified how vertex features are initialised\",\n  \"edge-features\": \"Not specified\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast leaf nodes (only!), connected by edges annotated with the path between the two leaf nodes (provided it is less than some length) [based on syntactic dependency parsing]"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"Bipartite graph relating users and repositories (temporal graph)\",\n  \"artefacts\": [\n    {\n      \"name\": \"Users\",\n      \"details\": \"from github\"\n    },\n    {\n      \"name\": \"Repositories\",\n      \"details\": \"from github\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"User\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Repository\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Vulnerability\",\n      \"details\": \"Denotes the introduction of a vulnerability in a repository by a user\\n\\nEvery interaction is annotated with a time (normalised to [0, 1]) at \\nwhich the interaction occurred.\"\n    }\n  ],\n  \"vertex-features\": \"Note: all features are time dependent! i.e. they change over time \\n\\nFor users;\\n  - Number of repositories owned\\n  - Number of repositories starred\\n  - Number of comments made by a user\\n  - Number of public repositories starred by a user\\n  - Number of vulnerabilities introduced _before this interaction_\\n  - Cumulative severity score of introduced vulnerabilities \\n\\nFor repositories;\\n  - Primary language used in the repository\\n  - Boolean indicating whether the repository has been forked \\n  - Number of open issues \\n  - Number of stars \\n  - Number of people watching \\n  - Number of forks \\n  - Number of pull requests \\n  - Size of the repository \\n  - Cumulative amount of vulnerability introduced _before this interaction_\\n  - Cumulative severity score of introduced vulnerabilities\",\n  \"edge-features\": \"Severity score, time t\",\n  \"connectivity-features\": \"Adjacency matrix (time dependent)\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "user/repository w. introduction of vulnerability in repo by user at specific time"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"CFG where each \\\"node\\\" has its own AST subtree\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"Smart contract\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement (CFG)\",\n      \"details\": \"Each such node has an AST tree as \\\"value\\\".\\n\\nEach statement has as type, based on the type \\nof the root of its AST subtree.\\nFor some types (e.g. Assignment), more analysis is \\nperformed to refine  the type (e.g. \\\"Memory Assignment\\\")\"\n    },\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Only occurs as the child of a CFG Node\"\n    },\n    {\n      \"name\": \"Virtual Function Node\",\n      \"details\": \"All CFG node in the graph has an edge to this node\"\n    },\n    {\n      \"name\": \"Virtual Loop Node\",\n      \"details\": \"All CFG nodes in a loop point to a Virtual Loop Node\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"Edge between CFG Nodes\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"Edge between CFG Nodes\"\n    },\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"Edge between AST Nodes\"\n    }\n  ],\n  \"vertex-features\": \"InferCode is used to encode nodes in AST subtrees,\\nand to encode the statement type of each CFG node\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "cfg with data flow edges, with an ast sub-tree per node"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"Code Property Graph with an additional edge type\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"dangerous function calls are identified and program slicing is performed based on their parameters.\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"CAD (Control And Data) Edge\",\n      \"details\": \"When in the PDG, there would be both control and data dependency edges between two nodes.\"\n    }\n  ],\n  \"vertex-features\": \"Node content is encoded using word2vec\",\n  \"edge-features\": \"Edge type is encoded using an ordinal encoding\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Static taint analysis (path of input data) of source code;\\nstatements encountered are put in sequence and embedded using word2vec.\"\n}",
      "new": "ast w. ast/control flow/control dependence/data dependence/joint edge type for control and data dependence between the same two nodes"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"Combination of AST and CFG\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"User defined names are normalised \\nNode type one-hot encoded \\ncontent of node is the average of the word2vec embeddings of all tokens in the content\\nthe two embeddings are concatenated\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/control flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"Combination of AST, PDF, and CFG\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Nodes\",\n      \"details\": \"Some degree of abstraction is applied to the node labels. \\nSpecifically, concrete identifiers are replaced by abstract ones.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"Edge from statement to every possible next statement\"\n    },\n    {\n      \"name\": \"Data Dependence Edge\",\n      \"details\": \"Assignment points to all variables usages\"\n    },\n    {\n      \"name\": \"Control Dependence Edge\",\n      \"details\": \"Edge from one statement which is affected by another (e.g. increment in loop body)\"\n    }\n  ],\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"A graph is represented using a bag of subgraphs feature.\\n\\nRoughly, every subgraph of size i is assigned a label. \\nThe feature vector is generated using some control parameter h;\\nthe final feature vector consists of a \\\"vector\\\" of all sets of subgraphs \\nof size 1, 2, ..., h.\\n\\n(Note: slightly inaccurate for simplicity))\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/control flow/data dependence/control dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"Combination of a graph showing module/class/function/method/field/variable relations\\nand an abstract syntax tree.\\n\\nNote that although vertices represent different things, in practice, there is only 1 vertex type.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Module\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Class\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Function\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Method\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Class Field\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Module Variable\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"AST Type\",\n      \"details\": \"Every AST Node has a type node pointing to it.\\nFor instance, every function definition has an incoming edge from the \\\"FunctionDef\\\" node.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Define\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Use\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Type use\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Import\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Call\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Import\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"AST Type Edge\",\n      \"details\": \"Every AST Node has a type node pointing to it.\\nFor instance, every function definition has an incoming edge from the \\\"FunctionDef\\\" node.\"\n    }\n  ],\n  \"vertex-features\": \"Not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Source code is tokenized. A FastText model is trained on the tokens.\\nThe tokens are encoded using FastText.\\n\\nFor every token, prefix and suffix information is collected.\"\n}",
      "new": "program elements (module, class function etc)/ast type node/ast node w. depencies (\"relations\")/ast type edge/ast edge"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"Complete old and new files are used in order to parse the changed method in full.\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"diff\"\n    },\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"Node types (internal nodes)\\n\\nLeaf nodes are split into sub-tokens\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"For both old and new code, paths between changed tokens are extracted from the \\nASTs obtained from the old/new files.\"\n}",
      "new": "ast"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"Control flow graph with data flow and AST subtrees\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": null\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST node\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Basic Block node\",\n      \"details\": \"Not entirely clear whether this is a node type on its own.\\n\\nEvery basic block is represented using an AST.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Call flow edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Exception flow edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data flow edge\",\n      \"details\": \"Links variable definitions to their uses\"\n    },\n    {\n      \"name\": \"Exception Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Sequential Execution Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Conditional True Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Conditional False Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "cfg with data flow and ast sub-tree per basic block node"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"For each method in a commit, a PDG of both the old \\nand new version of that method is constructed.\\n\\nThe PDGs are sliced based on the nodes changed in \\nthe commit.\\n\\nAll graphs are represented as a sequence \\nL = (s, p_1, \\\\hdots, p_x, n_1, \\\\hdots, n_y, t_1, \\\\hdots, t_z)\\n\\ns is the sliced graph, p_i are control flow paths, n_i are statements,\\nand t_i are tokens.\\n\\n(Note: many of the edge types/relations boil down to: control and dependence edges)\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"Diff\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Code Change Slice Node\",\n      \"details\": \"Represents the sliced graph\"\n    },\n    {\n      \"name\": \"Path\",\n      \"details\": \"Represents a control flow path in the sliced graph,\\nfrom the \\\"root\\\" node (method entry) to an exit point (i.e. return, throw, etc)\"\n    },\n    {\n      \"name\": \"Statement\",\n      \"details\": \"Statement in the source code\"\n    },\n    {\n      \"name\": \"Token\",\n      \"details\": \"Token in the source code\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"R1 - Control Flow Path\",\n      \"details\": \"Edge between code change slide node and path node\"\n    },\n    {\n      \"name\": \"R2 - Control Flow Path (2)\",\n      \"details\": \"Edge between control flow path and nodes contained in said path\"\n    },\n    {\n      \"name\": \"R3 - Changed node relation\",\n      \"details\": \"Denote a relation (data or dependency) between two changed nodes.\"\n    },\n    {\n      \"name\": \"R4 - Data Dependency\",\n      \"details\": \"Denote data dependency between two nodes which are members of \\nN_{change} \\\\cup N_{ctrl}, \\nwhere the first set is the set of changed nodes,\\nand the second is the set of nodes with a control dependency on \\nsome node in the set of changed nodes\"\n    },\n    {\n      \"name\": \"R5 - Data Dependency\",\n      \"details\": \"Denote data dependency between two nodes from N_{data},\\nWhere N_{data} is the set of nodes with a data dependency on \\nsome node in the set of changed nodes\"\n    },\n    {\n      \"name\": \"R6 - Control Dependency\",\n      \"details\": \"Denote control dependency between two nodes which are members of \\nN_{change} \\\\cup N_{data}, \\nwhere the first set is the set of changed nodes,\\nand the second is the set of nodes with a data dependency on \\nsome node in the set of changed nodes\"\n    },\n    {\n      \"name\": \"R7 - Control Dependency\",\n      \"details\": \"Denote control dependency between two nodes from N_{ctrl},\\nWhere N_{ctrl} is the set of nodes with a control dependency on \\nsome node in the set of changed nodes\"\n    },\n    {\n      \"name\": \"R8 - Token Edge\",\n      \"details\": \"Edge between statement and the nodes of tokens it contains\"\n    }\n  ],\n  \"vertex-features\": \"Token nodes are encoded using a word embedding.\\n\\nOther node types are encoded as zeros.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "one node represents entire graph (pdg)/nodes representing control flow paths/nodes representing statements/node representing tokens w. graph <-> path edges, path <-> statement edges, changed node edge (old/new)/data dependence/control dependence/token <-> statement edge"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"Graph describing and connecting multiple Python packages\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Packages\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Function\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Class field\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Class\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Module\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Class Method\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Non-indexed Symbol\",\n      \"details\": \"Not clearly explained\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Call\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Define/contain\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Type use\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Import\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Inherit\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "function/class/class field/module/method w. call/define/type use/import/inherit"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"Graph relation names of program variables\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"program\"\n    }\n  ],\n  \"vertex-type\": \"constants, properties, methods, globals\",\n  \"edge-type\": \"Relations (e.g. L += R, L < R where L = left, R = right; anything relating two names, essentially)/alias relation/may call/may access\",\n  \"vertex-features\": \"Program Element Names\",\n  \"edge-features\": \"Relation Type\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "constants/properties/methods/globals w. relations (e.g. L += R; anything relating to names)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"Graph relation names of program variables\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"program\"\n    }\n  ],\n  \"vertex-type\": \"expressions, constants\",\n  \"edge-type\": \"Relations (e.g. L += R, L < R where L = left, R = right; anything relating two names, essentially)/alias relation/may call/may access\",\n  \"vertex-features\": \"data types associated with nodes\",\n  \"edge-features\": \"Relation Type\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "expressions/constants w. relations (e.g. L += R; anything relating two names)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"Graph representation of repositories\",\n  \"artefacts\": [\n    {\n      \"name\": \"Repository\",\n      \"details\": \"Source files, directories, repository information\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Source File\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Directory\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Repository\",\n      \"details\": \"Used as \\\"root\\\" node\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"n/a (Parent)\",\n      \"details\": \"Each node (e.g. file) is connected to its parent. \\nTop-level nodes are connected to the repository nodes.\"\n    }\n  ],\n  \"vertex-features\": \"Files use the file attention representation based on the \\nuser-file interaction graph.\\n\\nFor directories, their names are split up into words,\\nwhich are encoded using TF-IDF.\\n\\nRepository features are obtained by combining\\nproject owners, creation timestamps, and top 5 \\nprogramming languages.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "file/directory/repository w. file system structure edges"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"Graph representing a commit.\\nBased on the \\\"hunks\\\" (added and removed lines)\\nfrom a commit.\\n\\nBoth hunks are parsed into ASTs,\\ncalled the old and new AST.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"commit\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Code Node\",\n      \"details\": \"Either an AST node, \\nor a result of the fact that\\nSnake and camel case names are split up; the tokens are added as child nodes of the original AST node\"\n    },\n    {\n      \"name\": \"Edit Node\",\n      \"details\": \"Several different types:\\nV_ADD: For nodes not present in the old AST, but which are present in the new AST\\nV_DEL: Connect a node which is present in the old AST, but not in the new AST\\nV_MOVE: Connect two nodes present in both ASTs, but the subtree has moved in the new AST\\nV_UPDATE: Connect two nodes present in both ASTs, but the content of the node was updated in the new AST.\\nV_MATCH: Connect two nodes present in both AST, with matching location and content\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Edit Edge\",\n      \"details\": \"Each edit node is connect to two AST nodes using edit edges\"\n    },\n    {\n      \"name\": \"Token Node\",\n      \"details\": \"The leaf nodes in the AST (containing the tokens) are connected in token (NCS) order\"\n    }\n  ],\n  \"vertex-features\": null,\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast/sub-token/edit (add, del, etc) w. ast/edit/sub-token"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"Graph representing program elements in a smart contract. \\nIt is not entirely clear what constitutes a program element.\\nIt seems to be variables and function invocations, based on the \\nproposed node features.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"smart contract\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Core Node\",\n      \"details\": \"Critical for vulnerability detection (e.g. money transfer, call.value)\"\n    },\n    {\n      \"name\": \"Normal Node\",\n      \"details\": \"Nodes that are not marked as core\"\n    },\n    {\n      \"name\": \"Fallback Node\",\n      \"details\": \"Simulates fallback function of a contract\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Fallback Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Depend on node type:\\n  1) Function Invocation Nodes\\n      i) Function Identifier\\n      ii) Caller Address\\n      iii) Node Type\\n      iv) Flag indicating whether the function has limited access (e.g. must be owner)\\n\\n  2) Variable/fallback nodes\\n      i) Identifier\\n      ii) Node Type\\n\\n  Next, feedback and normal nodes are removed. \\n  Their features are \\\"assigned\\\" to the nearest core\\n  node (to multiple in case of multiple closest core nodes).\\n  The removed edges become self-loops on the core nodes. \\n\\n  As a result, only core vertices remain, and they have \\n  three sets of features:\\n  1) Self-features (their original ones)\\n  2) In-features: all features from normal nodes that\\n      were pointing toward the core node\\n  3) Out-features: all features from normal nodes that\\n      were pointed away from the core node\\n\\n  It is unclear how exactly the features are _encoded_\",\n  \"edge-features\": \"Order (sequential order in the function), edge type\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Various hand-crafted/expert features are used (0/1 values indicating existence of certain patterns)\"\n}",
      "new": "core(critical for vulnerability; statement)/normal(not core)/fallback(fallback function) w. control flow/data flow/fallback"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"Graph structure for use in variable misuse prediction.\\nA graph structure is build for every single possible variable\\nwhich can be substituted in the spot of interest. \\nA graph structure with the node at the point of interest removed is \\nalso built.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Function (C#)\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST  Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"NCS Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"(Data Flow) Last Use\",\n      \"details\": \"Connect variable use with all previous reads and definitions with (still) the same value\"\n    },\n    {\n      \"name\": \"(Data Flow) Last Write\",\n      \"details\": \"Connect use of variable with all its definitions\"\n    },\n    {\n      \"name\": \"(Data Flow) Last Lexical Use\",\n      \"details\": \"Represent the shortcut in reversed token chain between nearest entries of the specified variable\"\n    },\n    {\n      \"name\": \"(Data Flow) Computed From\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"(Data Flow) Formal Args\",\n      \"details\": \"Connect actual arguments and formal parameters of a method\"\n    },\n    {\n      \"name\": \"(Data Flow) Next Operand\",\n      \"details\": \"Connect operands of a single operation and parameters of a method (in lexical order)\"\n    }\n  ],\n  \"vertex-features\": \"Syntax tokens have their node type encoded using word2vec Token tokens have their tokens and language type (variable/property/field) encoded using word2vec.\\nFor encoding, text (camel case, underscores) is split up, and the final vector is the average.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/ncs/data flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"Heterogeneous graph mapping tokens to \\\"sentences\\\"\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Sentence Node\",\n      \"details\": \"For Java code, a sentence is a statement. For control statement, the portion before the opening { is used as a sentence.\\nFor Python code, each line is considered a sentence.\"\n    },\n    {\n      \"name\": \"Token Node\",\n      \"details\": \"Represents a single token. One unique node for every unique token\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"sentence/token edge\",\n      \"details\": \"connects a sentence node to every token contained in said sentence\"\n    }\n  ],\n  \"vertex-features\": \"Node payload, embedded using embedding layers\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Previously generated tokens are used as input.\"\n}",
      "new": "statement/token (one for every unique token) w. statement <-> token edge"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"Hypergraph based on AST\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Internal node (non-token)\"\n    },\n    {\n      \"name\": \"Identifier Node\",\n      \"details\": \"Token node\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Directed Hyper Edge\",\n      \"details\": \"If a node aggregates multiple items in e.g. a list,\\nthen the items in the list are connected to the parent \\nnode using a hyper edge (going _from_ multiple children _to_ the parent).\\n\\nEdges have distinct types, based on the type of relation \\nbetween parent and children (e.g. \\\"elements\\\" for list elements).\"\n    }\n  ],\n  \"vertex-features\": \"Node value (payload)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast, but whenever a list of nodes is aggregated (e.g. block body), a hyperedge is used instead"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"Interconnected ASTs with data flow and control flow edges\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"Source code taken from multiple source files.\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"First, file containing unit tests are parsed. \\nTest _bodies_ are isolated and used to construct the initial graph.\\nThe graph is expanded by including the AST bodies of all (possibly non-test)\\nmethods called in the unit test.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data flow edge\",\n      \"details\": \"No details given\"\n    },\n    {\n      \"name\": \"Control flow edge\",\n      \"details\": \"No details given\"\n    }\n  ],\n  \"vertex-features\": \"Not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/control flow/data flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"Mix of AST and CFG\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Javascript\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Ast Edge\",\n      \"details\": \"Directed\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Node content is split up into \\\"words\\\", and embedded using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Taint analysis is applied to the program. \\nResulting sub-program text is split up into \\\"words\\\" and embedded using word2vec,\\nand put into a sequence of vectors\"\n}",
      "new": "ast w. ast/control flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"Mix of AST, CFG, DF G\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"file\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/control flow/data flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"Mix of AST, CFG, DFG, NCS\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"functions\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Certain node types are merged. Nodes representing the same variables are merged.\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"NCS Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Source code in node tokenised and \\nencoded using word2vec. \\nFinal vector is average of token embeddings.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/control flow/data flow/ncs"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"Mix of AST, CFG, DFG, NCS\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"functions\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"NCS Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Node type encoded using label encoding\\nSource code encoded using word2vec\\nthe two encodings are concatenated\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/control flow/data flow/ncs"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"Mixture of AST and CFG.\\n\\nCode slicing is performed based on function calls,\\narithmetic expressions, pointer usage, and array usage.\\nSlicing was done based on control and data dependencies. \\n\\nEvery function may result into multiple code slices!\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"Source code slice from function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Token\",\n      \"details\": \"Each unique token has a vertex\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Co-occurrence edge\",\n      \"details\": \"Edge between tokens if they co-occur in a sliding window of some given size\"\n    }\n  ],\n  \"vertex-features\": \"Tokens encoded using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "token w. sliding window co-occurrence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"Network connecting developers, issues, source files, and tags assigned to issues.\",\n  \"artefacts\": [\n    {\n      \"name\": \"Issues\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"User Data\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"Files\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Developer\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Issue\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Source File\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Issue Tag\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Labelled\",\n      \"details\": \"Connects issues with their labels\"\n    },\n    {\n      \"name\": \"Review\",\n      \"details\": \"Linked Developers with Issues they were involved in\"\n    },\n    {\n      \"name\": \"Commit\",\n      \"details\": \"Link developers to source files they committed\"\n    },\n    {\n      \"name\": \"Similar\",\n      \"details\": \"Link issues to possibly related source files, based on cosine similarity (len(issue & code) / len(code))\"\n    }\n  ],\n  \"vertex-features\": \"Nodes are embedded of numerical vectors with equal dimensions for all node types.\\n\\nFor issues, they are encoded using Word2Vec, by taking the average of all words in the issue description.\\n\\nDevelopers are encoded by taking the average of the embeddings of all the issues created by the developer.\\n\\nEmbeddings for other nodes are not discussed.\",\n  \"edge-features\": \"Various meta paths are used\",\n  \"connectivity-features\": \"Adjacency matrix\",\n  \"graph-features\": \"Link and node masking are applied.\",\n  \"other-features\": \"n/a\"\n}",
      "new": "developers/isues/files/tags w. labelled/reviewed/comitted/similar (link issues to possibly related source files)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"Network of statements, where every statement has its AST subtree attached\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement Node\",\n      \"details\": \"All type names are fully expanded. Variable names are replaced with their fully expanded type.\"\n    },\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"Between statements\"\n    },\n    {\n      \"name\": \"PDG Edge\",\n      \"details\": \"Between statements\"\n    }\n  ],\n  \"vertex-features\": \"Node content is encoded using doc2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "statement w. control flow/control dependence/data depenendence, where every node has an AST sub-tree"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"Obtained from PDG through slicing based on system API calls \\nand statements containing arithmetic operations\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data Dependence Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Dependence Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Names are normalised\\nStatements encoded using doc2vec (DM-PV)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "pdg (statement)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"PDG enhanced with call information\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Statement\",\n      \"details\": \"Slicing (based on sys API calls and pointer variables) is performed to reduce the amount of nodes\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Data flow (dependence) Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control flow (dependence) Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Call Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Return Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Statements in nodes encoded using doc2vec\",\n  \"edge-features\": \"Back-edges are added.\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "pdg (statement) w/ call"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"Program Dependency Graph with additional heterogeneous information\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"methods\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Method Node\",\n      \"details\": \"Represents the method. Only one such node exists in the graph\"\n    },\n    {\n      \"name\": \"Statement Node\",\n      \"details\": \"b/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"Connects successive statements\"\n    },\n    {\n      \"name\": \"Control Dependency Edge\",\n      \"details\": \"Connects statements where the execution of one is controlled by the other\"\n    },\n    {\n      \"name\": \"Data Dependency Edge\",\n      \"details\": \"Connects statements with variables to the statement where the variable is defined\"\n    },\n    {\n      \"name\": \"Include Edge\",\n      \"details\": \"Edge from Method Node to Statement Node\"\n    }\n  ],\n  \"vertex-features\": \"Method Node Features; 1) LOC -- Amount of statements in the method 2) CC -- McCabe's Cyclomatic Complexity of the method 3) PC -- Parameter count of the method 4) LCOM1 to LCOM4 -- Four type of cohesion metrics propoposed by Charalampidou\\nStatement Node Features; 1) ABCL --  Metric proposed by Fitzpatrick, representing the type of statement (assignment, branch, condition, loop) 2) FUC -- Amount of fields used in a statement 3) LMUC -- Total amount of local (same class) methods used in the statement 4) PUC -- Number of parameters used in the statement 5) NBD -- Nesting depth of the statement 6) VUC -- Amount of variables used in a statement 7) WC -- Word count of the statement\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "pdg (statement) w. control flow, and one root \"method\" node connected to all statements"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"Simplified AST\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source Code\",\n      \"details\": \"Pairs of files; One old file and a revised version\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"Some statement (internal) nodes are removed\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Word embedding is used to encode nodes. \\n\\nUnclear what exactly (node type, token payload) is encoded.\\nThe images in the paper suggests that the node type is encoded\\nfor internal nodes, and the payload for lexical nodes.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast (trimmed)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"ast w/ ncs; AST of the old source code\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"diff\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/ncs\",\n  \"vertex-features\": \"not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/ncs"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"ast with additional edges. The AST is the thing being generated by the model.\",\n  \"artefacts\": null,\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/sibling/parent/next-use/next token\",\n  \"vertex-features\": null,\n  \"edge-features\": null,\n  \"connectivity-features\": null,\n  \"graph-features\": null,\n  \"other-features\": \"Context code (which contains the hole to be filled in) is used as feature.\"\n}",
      "new": "ast w. ast/sibling/data flow/ncs"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"ast with data flow\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/data flow/ncs\",\n  \"vertex-features\": \"not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/data flow/ncs"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"based on AST, but with abstracted/less information\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"API call/control unit/variable declaration/assignment\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"not clearly specified, but seems to be node content (type for control unit; tokens for the others)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Generated statements _without variables_ are ranked based on classifier confidence,\\nand a score computed based on a (non ML) data flow analysis of the graph,\\nwhich intuitively measures whether the variables in the statements \\nmake sense, given the graph full training corpus, \\nis used to fill in the names of the variables.\"\n}",
      "new": "ast (trimmed)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"bipartite network\",\n  \"artefacts\": [\n    {\n      \"name\": \"github repositories\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"github user data\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"repositories/users\",\n  \"edge-type\": \"contributes\",\n  \"vertex-features\": \"for users: potential passwords/keys, occurrences of string \\\"password\\\" in a file, sensitive filetypes.\\n\\nfor repos: vulnerability type(s) detected by scanner tool (secret leakage, classical vulnerabilities such as sql, etc.)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"The bipartite network is projected into two mono-partite networks (user network and repo network)\\n\\nGraphs are encoded using text associated deep walk\",\n  \"other-features\": \"n/a\"\n}",
      "new": "repository/user w/ contributes"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"collection of connected ASTs,\\ncollected based on method call chains\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"file (?)\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"word2vec for node content\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"average pooling over node features\",\n  \"other-features\": \"average pooling over the graph embedding of all ASTs\"\n}",
      "new": "connected asts based on method call chain"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"collection of connected CFGs,\\ncollected based on method call chains\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"file (?)\"\n    }\n  ],\n  \"vertex-type\": \"statement/entry/exit\",\n  \"edge-type\": \"control flow\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"graph2vec\",\n  \"other-features\": \"apply graph2vec on the graph of connected cfg\"\n}",
      "new": "connected cfgs based on method call chain"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"difference between old and new ast\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"diff\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/added/removed/replaced/unchanged\",\n  \"vertex-features\": \"not specified\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "two contwo connected variants of ast w. ast/changes (old/new)/unchanged"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"heterogeneous graph with developers' github and stackoverflow activity\",\n  \"artefacts\": [\n    {\n      \"name\": \"github data\",\n      \"details\": \"projects, user data, topics (\\\"abilities\\\")\"\n    },\n    {\n      \"name\": \"stackoverflow data\",\n      \"details\": \"questions, answers, users, tags (\\\"abilities\\\")\"\n    }\n  ],\n  \"vertex-type\": \"developers/projects/questions/abilities\",\n  \"edge-type\": \"follows (developer -> developer) / answered (Q -> D) / ask (D -> Q) / commit/committed (D <-> P) / label/labelled (P <-> A, Q <-> A)\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"Edges are weighted (1 for most, except \\\\# committ(ed), \\\\# asked/answered)\",\n  \"connectivity-features\": \"transition probability matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": null\n}",
      "new": "developer/project/question/ability w. follows (dev -> dev)/answered/asked/commit (d <-> p)/labelled (p <-> a, q<->a)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"mix of AST, CFG, PDG\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"smart contract\"\n    }\n  ],\n  \"vertex-type\": \"AST Node (slicing applied)\",\n  \"edge-type\": \"ast/control flow/data dependence/control dependence\",\n  \"vertex-features\": \"tokens encoded using fasttext\",\n  \"edge-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/control dependence/control flow/data dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"modified control flow graph\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Token\",\n      \"details\": \"CFG is created based on statements, then every statement is split into tokens\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow\",\n      \"details\": \"CFG is created based on statements, then every statement is split into tokens\"\n    },\n    {\n      \"name\": \"Next Token (statement)\",\n      \"details\": \"Connect consecutive tokens in a statement\"\n    }\n  ],\n  \"vertex-features\": \"token\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "token (in statement) w. control flow (between statement)/next token (in statement)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"modified control flow graph, where multiple control flow graphs of calling/callee functions are combined\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"statement\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Control Flow\",\n      \"details\": \"CFG is created based on statements\"\n    }\n  ],\n  \"vertex-features\": \"tokens (in the statement)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "interprocedural cfg"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code (function/method)\",\n      \"details\": \"first compiled to LLVM IR\"\n    }\n  ],\n  \"vertex-type\": \"identifiers in the instructions (some trimmed)\",\n  \"edge-type\": \"control dependence/flow and data dependence/flow\",\n  \"vertex-features\": \"identifiers in the instructions (one hot)\",\n  \"edge-features\": \"edge type\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"code summary/query\"\n}",
      "new": "identifiers in instructions w. control/data flow/dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"file\"\n    }\n  ],\n  \"vertex-type\": \"ast (merge certain types, prune some stuff)\",\n  \"edge-type\": \"ast\",\n  \"vertex-features\": \"node type encoded using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"bug report encoded using word2vec \\nraw source code encoded using word2vec\"\n}",
      "new": "ast (trimmed)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Child Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Next Token Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Computed From Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Last Use Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Guarded By Negation Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Guarded By Edge\",\n      \"details\": \"e.g. Edge to surrounding if statement\"\n    },\n    {\n      \"name\": \"Jump Edge\",\n      \"details\": \"e.g. from if to else\"\n    }\n  ],\n  \"vertex-features\": \"Normalise names.\\nNode type and tokens encoded using word2vec\\n(return) type of variables, functions, constants encoded using word2vec\\ntype and type/payload embeddings concatenated.\",\n  \"edge-features\": null,\n  \"connectivity-features\": \"Adjacency matrices (one for each edge type; 9 in total)\",\n  \"graph-features\": null,\n  \"other-features\": null\n}",
      "new": "ast w. ast/control flow/data flow/ncs/data dependence/control dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow EDge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Node type (nonterminal, terminal, or value (contains actual token)) is used as feature\\nType of syntactic node is used as feature \\n\\nUnclear what exact features are used, and how they are encoded.\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/control flow/data flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"AST Node\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"AST Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Control Flow Edge\",\n      \"details\": \"n/a\"\n    },\n    {\n      \"name\": \"Data Flow Edge\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-features\": \"Variable names are normalised.\\nNode payload embedded using word2vec\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/control flow/data flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"Source code\",\n      \"details\": null\n    }\n  ],\n  \"vertex-type\": [\n    {\n      \"name\": \"Tokens\",\n      \"details\": \"Source code is tokenized. Every token has a node\"\n    }\n  ],\n  \"edge-type\": [\n    {\n      \"name\": \"Edge\",\n      \"details\": \"There exists an edge between successive tokens.\\n\\nTODO: This is probably not right but I do not understand \\nwhat the authors mean by \\\"co-occurrence\\\"\"\n    }\n  ],\n  \"vertex-features\": \"Tokens are embedding using BERT\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"Adjacency Matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "tokens w. sliding window co-occurrence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"repository\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"user/repository/file\",\n  \"edge-type\": \"user interactions (comment, fork, star, contribute)/repository has file\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"Various (eight) meta paths are used\",\n  \"other-features\": \"n/a\"\n}",
      "new": "user/repository/file w. repository has file/comment/fork/star/contribute"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"first compiled to IR\"\n    }\n  ],\n  \"vertex-type\": \"operands/opcode/labels in IR\",\n  \"edge-type\": \"control dependency (or flow; not clearly specified)/data dependency\",\n  \"vertex-features\": \"both exact feature and encoding unclear\",\n  \"edge-features\": \"edge have a weight\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "operands/opcode/labels in ir w. control dependence/flow (not clear)/data dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"first compiled to IR\"\n    }\n  ],\n  \"vertex-type\": \"operands/opcode/labels in IR\",\n  \"edge-type\": \"control dependency/data dependency/oop related links (e.g. link method to object instance)\",\n  \"vertex-features\": \"variables in ir instruction (one hot)\",\n  \"edge-features\": \"edge type\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"code summary/query\"\n}",
      "new": "operands/opcodes/labels in ir w. control dependence/data dependence/oop related links (e.g. link method to instance)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"function\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/control flow/control dependence/data dependence/dominator/post dominator\",\n  \"vertex-features\": \"node type (presumably one-hot), code associated with node encoded using word2vec\",\n  \"edge-features\": \"edge type one-hot encoded\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"the heterogeneous graph is split into multiple homogeneous graphs based on edge type\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/control flow/control dependence/data dependence/dominator/post dominator"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"method\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/control flow/data dependence\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"weighted sum of adjacency matrices (A)\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"source code is used as feature \\n\\nshortest path length matrix is used as feature (normalised) (M)\"\n}",
      "new": "ast w. control flow/data dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/control flow (might well be dependence; not a good distinction is made)/data dependence\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"weighted sum of the three adjacency matrices for the different edge types\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"code tokens are used as input\"\n}",
      "new": "ast w. control flow (or  dependence; unclear)/data dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/data flow (different types, e.g. lastUse)\",\n  \"vertex-features\": \"node type\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/data dependence"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/data flow/ncs/function call/control flow\",\n  \"vertex-features\": \"not specified\",\n  \"edge-features\": \"edge type\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/data flow/ncs/function call/control flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/ncs\",\n  \"vertex-features\": \"node type one-hot\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/ncs"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"ast/sibling\",\n  \"vertex-features\": \"type (nonterminal), code tokens (terminal)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"presumably adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"source code text is used as feature\"\n}",
      "new": "ast w. ast/sibling"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast\",\n  \"edge-type\": \"data flow/ncs/function call/control flow\",\n  \"vertex-features\": \"not specified\",\n  \"edge-features\": \"edge type\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"The regular AST is taken, and all connections are \\\"moved down\\\" to the leaf nodes;\\nnon-leaf nodes are removed.\",\n  \"other-features\": \"n/a\"\n}",
      "new": "ast w. ast/data flow/ncs/function call/control flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"ast/sub-tokens\",\n  \"edge-type\": \"ast/control flow/ncs/sibling/data flow\",\n  \"vertex-features\": \"node type (nonterminal), token (terminal); encoding not specified\",\n  \"edge-features\": \"edge type (presumably); encoding not specified\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"the source code (raw) is used as feature, encoded using CodeBERT \\n\\nsummary thus far is used as feature\"\n}",
      "new": "ast/sub-tokens w. ast/control flow/ncs/sibling/data flow/sub token"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"variable\",\n  \"edge-type\": \"data flow (values comes from; directed)\",\n  \"vertex-features\": \"variable name\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"comment (for function, e.g. javadoc) is used as feature\\n\\nfunction source is used as feature \\n\\ngraph is linearised and used as feature \\n\\nsequence starts with [CLS], the three parts are separated with [SEP]\"\n}",
      "new": "variable w. data flow"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"project\"\n    }\n  ],\n  \"vertex-type\": \"class/property/method/parameter/variable\",\n  \"edge-type\": \"inheritance/has (class has property, class has method, method has parameter, method has variable)/instance_of/return_type/call\",\n  \"vertex-features\": \"see graph features\",\n  \"edge-features\": \"see graph features\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"knowledge graph is embedded using one of: TransE, TransH, TransR.\\nidea: every (source, edge, tail) triple should have encodings (h, r, t) such that h + r \\\\approx t\",\n  \"other-features\": \"bug report used as feature, encoded using word2vec \\n\\ncode text used as feature, encoded using word2vec\"\n}",
      "new": "class/property/method/paremeter/variable w. inheritance/has/instance_of/return_type/call"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"project\"\n    }\n  ],\n  \"vertex-type\": \"classes/interfaces\",\n  \"edge-type\": \"dependencies between classes/interfaces (implements, data access, etc.)\",\n  \"vertex-features\": \"n/a\",\n  \"edge-features\": \"edges have weights (fine-tuned using simulated annealing)\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "class/interface dependency network"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"project\"\n    }\n  ],\n  \"vertex-type\": \"module\",\n  \"edge-type\": \"data dependency/call dependency\",\n  \"vertex-features\": \"node level network metrics\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"graph level network metrics\",\n  \"other-features\": \"n/a\"\n}",
      "new": "module w. data dependency/call dependency"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"repository\"\n    }\n  ],\n  \"vertex-type\": \"repository/token (frequently occurring source code tokens from malicious repositories)\",\n  \"edge-type\": \"source file in repository contains token\",\n  \"vertex-features\": \"node embeddings computed using deepwalk (random walk w/ skipgram)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "repository/token w. source file in repo contains token"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"version history information\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"developer\",\n  \"edge-type\": \"two devs are connected if they made changes to the same file in the same release\",\n  \"vertex-features\": \"\\\"classical\\\" network metrics (connectivity, centrality, degree, betweenness, closeness)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"For every file in a project, the average, maximum, and sum of the developer metrics \\nof all developers who contributed to that file (overall, not per release; unweighted)\\nare computed. \\n\\nFiles have various other (more traditional) code changes metrics, such as \\ncode churn (# modified lines over history), # updates, # distinct developers\"\n}",
      "new": "developer w. worked on same file in same release"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"n/a\",\n  \"description\": \"tokens (unique) w/ co-occurrence sliding window\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"unique code tokens\",\n  \"edge-type\": \"co-occurrence in sliding window\",\n  \"vertex-features\": \"token CodeBERT / GraphCodeBERT (two different methods proposed)\",\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"adjacency matrix\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "unique code tokens w. co-occurrence sliding window"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"pdg\",\n  \"description\": \"n/a\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"statement\",\n  \"edge-type\": \"control dependence/data dependence\",\n  \"vertex-features\": null,\n  \"edge-features\": \"n/a\",\n  \"connectivity-features\": \"n/a\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"Paths of homogeneous edge type (either all control or all data dependence) (incl. directions)\\nare used as features.\\n\\nExact details not specified, but based on code2vec we would have that the path (sequence of types, incl. directions) is the feature\"\n}",
      "new": "pdg (statement)"
    },
    {
      "action": "refine",
      "old": "{\n  \"name\": \"sdg (system dependence graph)\",\n  \"description\": \"derived from a set of pdgs\",\n  \"artefacts\": [\n    {\n      \"name\": \"source code\",\n      \"details\": \"n/a\"\n    }\n  ],\n  \"vertex-type\": \"statement\",\n  \"edge-type\": \"control dependence (data dependence not used)\",\n  \"vertex-features\": \"for each statement, max-pool over embeddings of all nodes in corresponding ast subtree\",\n  \"edges\": \"n/a\",\n  \"connectivity-features\": \"not specified\",\n  \"graph-features\": \"n/a\",\n  \"other-features\": \"n/a\"\n}",
      "new": "statement w. control dependence"
    },
    {
      "action": "refine",
      "old": "ast + sub-token",
      "new": "ast + sub-tokens"
    },
    {
      "action": "refine",
      "old": "ast + subtokens",
      "new": "ast + sub-tokens"
    },
    {
      "action": "refine",
      "old": "class w. dependencies (weighted)",
      "new": "class/interface dependency network"
    },
    {
      "action": "refine",
      "old": "pdg (instruction)",
      "new": "pdg"
    },
    {
      "action": "refine",
      "old": "pdg (line)",
      "new": "pdg"
    },
    {
      "action": "refine",
      "old": "pdg (statement)",
      "new": "pdg"
    },
    {
      "action": "refine",
      "old": "pdg w/ additional node types for some control flow constructs",
      "new": "pdg"
    },
    {
      "action": "refine",
      "old": "pdg (instruction) w. call edges",
      "new": "pdg w. call edges"
    },
    {
      "action": "refine",
      "old": "pdg (statement) w. call dependence",
      "new": "pdg w. call edges"
    },
    {
      "action": "refine",
      "old": "pdg (statement) w/ call",
      "new": "pdg w. call edges"
    },
    {
      "action": "refine",
      "old": "token w. sliding window co-occurence",
      "new": "token w. sliding window co-occurrence"
    },
    {
      "action": "refine",
      "old": "token w. token sliding window",
      "new": "token w. sliding window co-occurrence"
    },
    {
      "action": "refine",
      "old": "tokens w. sliding window co-occurrence",
      "new": "token w. sliding window co-occurrence"
    },
    {
      "action": "refine",
      "old": "variable w. data dependence",
      "new": "variable w. data {flow,dependence}"
    },
    {
      "action": "refine",
      "old": "variable w. data flow",
      "new": "variable w. data {flow,dependence}"
    },
    {
      "action": "refine",
      "old": "variables ('vulnerability related') w. data flow",
      "new": "variable w. data {flow,dependence}"
    },
    {
      "action": "refine",
      "old": "api dependency graph (api w. edges denoting that api x uses api y)",
      "new": "api dependency graph"
    },
    {
      "action": "refine",
      "old": "ast w. ast/control flow/control dependence/data dependence",
      "new": "ast w. ast/control dependence/control flow/data dependence"
    },
    {
      "action": "refine",
      "old": "ast w. ast/control flow/data flow (cpg)",
      "new": "ast w. ast/control dependence/control flow/data dependence"
    },
    {
      "action": "refine",
      "old": "cfg (basic block)",
      "new": "cfg"
    },
    {
      "action": "refine",
      "old": "cfg (statement)",
      "new": "cfg"
    },
    {
      "action": "refine",
      "old": "cfg (line)",
      "new": "cfg"
    },
    {
      "action": "refine",
      "old": "cfg (but nodes represent operations in the code, incl. function calls and return)",
      "new": "cfg"
    },
    {
      "action": "refine",
      "old": "cfg (instruction)",
      "new": "cfg"
    },
    {
      "action": "refine",
      "old": "ast (syntax nodes only)",
      "new": "ast (syntax nodes)"
    },
    {
      "action": "refine",
      "old": "ast w/ ast/control dependence/data dependence/ncs",
      "new": "sat w. ast/control dependence/data dependence/ncs"
    },
    {
      "action": "refine",
      "old": "ast w/ ast/ncs/data dependence",
      "new": "ast w. ast/data dependence/ncs"
    },
    {
      "action": "refine",
      "old": "ast w/ ast/sibling/control flow/data flow",
      "new": "ast w. ast/sibling/control flow/data flow"
    },
    {
      "action": "refine",
      "old": "ast + unique variable node w. ast/sibling/data dependence/ordering of nodes accessing the same variable/all occurrences of a variable connected to the unique variable node",
      "new": "ast/unique variable node w. all occurrences of a variable connected to the unique variable node/ast/data dependence/ordering of nodes accessing the same variable/sibling"
    },
    {
      "action": "refine",
      "old": "ast w.  control flow/data flow/call/ncs",
      "new": "ast w. call/control flow/data flow/ncs"
    },
    {
      "action": "refine",
      "old": "ast w. ast/control flow/control dependence/data dependence/dominator/post dominator",
      "new": "ast w. ast/control dependence/control flow/data dependence/dominator/post dominator"
    },
    {
      "action": "refine",
      "old": "ast w. ast/control flow/control dependence/data dependence/function call/ncs",
      "new": "ast w. ast/control dependence/control flow/data dependence/function call/ncs"
    },
    {
      "action": "refine",
      "old": "ast w. ast/control flow/control dependence/data dependence/joint edge type for control and data dependence between the same two nodes",
      "new": "ast w. ast/control dependence/control flow/data dependence/joint edge type for control and data dependence between the same two nodes"
    },
    {
      "action": "refine",
      "old": "ast w. ast/control flow/control dependence/data dependence/ncs",
      "new": "ast w. ast/control dependence/control flow/data dependence/ncs"
    },
    {
      "action": "refine",
      "old": "ast w. ast/control flow/data dependence/control dependence",
      "new": "ast w. ast/control dependence/control flow/data dependence"
    },
    {
      "action": "refine",
      "old": "ast w. ast/control flow/data flow/ncs/data dependence/control dependence",
      "new": "ast w. ast/control dependence/control flow/data dependence/data flow/ncs"
    },
    {
      "action": "refine",
      "old": "ast w. ast/data flow/call",
      "new": "ast w. ast/call/data flow"
    },
    {
      "action": "refine",
      "old": "ast w. ast/data flow/control flow",
      "new": "ast w. ast/control flow/data flow"
    },
    {
      "action": "refine",
      "old": "ast w. ast/data flow/data dependence/control flow/ncs",
      "new": "ast w. ast/control flow/data dependence/data flow/ncs"
    },
    {
      "action": "refine",
      "old": "ast w. ast/data flow/ncs/function call/control flow",
      "new": "ast w. ast/control flow/data flow/function call/ncs"
    },
    {
      "action": "refine",
      "old": "ast w. ast/ncs/control flow/data dependence",
      "new": "ast w. ast/control flow/data dependence/ncs"
    },
    {
      "action": "refine",
      "old": "ast w. ast/ncs/data flow",
      "new": "ast w. ast/data flow/ncs"
    },
    {
      "action": "refine",
      "old": "ast w. ast/ncs/sibling/data flow/control flow",
      "new": "ast w. ast/control flow/data flow/ncs/sibling"
    },
    {
      "action": "refine",
      "old": "ast w. ast/sibling/control flow/data flow",
      "new": "ast w. ast/control flow/data flow/sibling"
    },
    {
      "action": "refine",
      "old": "ast w. ast/sibling/data flow",
      "new": "ast w. ast/data flow/sibling"
    },
    {
      "action": "refine",
      "old": "ast w. ast/sibling/data flow/ncs",
      "new": "ast w. ast/data flow/ncs/sibling"
    },
    {
      "action": "refine",
      "old": "ast w. ast/sibling/ncs/data flow/control flow",
      "new": "ast w. ast/control flow/data flow/ncs/sibling"
    },
    {
      "action": "refine",
      "old": "ast w/ ast/calls/control flow/data flow",
      "new": "ast w. ast/calls/control flow/data flow"
    },
    {
      "action": "refine",
      "old": "ast w/ ast/ncs/control flow/data dependence",
      "new": "ast w. ast/control flow/data dependence/ncs"
    },
    {
      "action": "refine",
      "old": "basic block w. control flow/call",
      "new": "basic block w. call/control flow"
    },
    {
      "action": "refine",
      "old": "file w. dependency/association",
      "new": "file w. association/dependency"
    },
    {
      "action": "refine",
      "old": "instruction w. data flow/control flow/data dependence/control dependence",
      "new": "instruction w. control dependence/control flow/data dependence/data flow"
    },
    {
      "action": "refine",
      "old": "instructions w. control flow/call/data flow/data dependence",
      "new": "instructions w. call/control flow/data dependence/data flow"
    },
    {
      "action": "refine",
      "old": "module w. data dependency/call dependency",
      "new": "module w. call dependency/data dependency"
    },
    {
      "action": "refine",
      "old": "operands w/ data flow/call",
      "new": "operands w. call/data flow"
    },
    {
      "action": "refine",
      "old": "statement w. control dependence/data dependence/data flow/call",
      "new": "statement w. call/control dependence/data dependence/data flow"
    },
    {
      "action": "refine",
      "old": "statement w/ control flow/data flow",
      "new": "statement w. control flow/data flow"
    },
    {
      "action": "refine",
      "old": "ast + ssub-tokens w. ast/ncs/data dependence/control flow/sub token",
      "new": "ast/ssub-tokens w. ast/control flow/data dependence/ncs/sub token"
    },
    {
      "action": "refine",
      "old": "ast + sub-token + api invocation nodes w. ast/ncs/data flow/sub token",
      "new": "api invocation nodes/ast/sub-token w. ast/data flow/ncs/sub token"
    },
    {
      "action": "refine",
      "old": "ast + sub-token w. ast/sibling/ncs/sub token",
      "new": "ast/sub-token w. ast/ncs/sibling/sub token"
    },
    {
      "action": "refine",
      "old": "ast/ssub-tokens w. ast/control flow/data dependence/ncs/sub token",
      "new": "ast/sub-tokens w. ast/control flow/data dependence/ncs/sub token"
    },
    {
      "action": "refine",
      "old": "ast + sub-token w. ast/linear control/control dependence/function call/inheritance/import/sub-token",
      "new": "ast/sub-token w. ast/control dependence/function call/import/inheritance/linear control/sub-token"
    },
    {
      "action": "refine",
      "old": "ast + sub-token w. ast/sub-token/ncs/data dependence",
      "new": "ast/sub-token w. ast/data dependence/ncs/sub-token"
    },
    {
      "action": "refine",
      "old": "ast + sub-tokens w. ast/ncs/data dependence/sub-token",
      "new": "ast/sub-tokens w. ast/data dependence/ncs/sub-token"
    },
    {
      "action": "refine",
      "old": "ast+sub-token w. ast/sub-token/ncs/data dependence",
      "new": "ast/sub-token w. ast/data dependence/ncs/sub-token"
    },
    {
      "action": "refine",
      "old": "component w. dependency/co-evolution",
      "new": "component w. co-evolution/dependency"
    },
    {
      "action": "refine",
      "old": "ast",
      "new": "ast|ast"
    },
    {
      "action": "refine",
      "old": "ast|ast",
      "new": "ast|ast|ast"
    },
    {
      "action": "refine",
      "old": "ast w. ast/block/control flow/ncs",
      "new": "none|ast|ast/block/control flow/ncs"
    },
    {
      "action": "refine",
      "old": "ast w ast/sibling",
      "new": "none|ast|ast/sibling"
    },
    {
      "action": "refine",
      "old": "file/user w. contribution",
      "new": "none|file/user|contribution"
    },
    {
      "action": "refine",
      "old": "ast w. ast/control flow/data flow/ncs/sibling",
      "new": "none|ast|ast/control flow/data flow/ncs/sibling"
    },
    {
      "action": "refine",
      "old": "statement w. control flow/data flow",
      "new": "none|statement|control flow/data flow"
    },
    {
      "action": "refine",
      "old": "variables/labels in IR w. data flow/data dependence/control flow",
      "new": "none|variables/labels in IR|data flow/data dependence/control flow"
    },
    {
      "action": "refine",
      "old": "instructions w. call/control flow/data dependence/data flow",
      "new": "none|instructions|call/control flow/data dependence/data flow"
    },
    {
      "action": "refine",
      "old": "ast/sub-tokens w. ast/control flow/ncs/sibling/data flow/sub token",
      "new": "none|ast/sub-tokens|ast/control flow/ncs/sibling/data flow/sub token"
    },
    {
      "action": "refine",
      "old": "component w. depedencies",
      "new": "dependency graph|component|depedencies"
    },
    {
      "action": "refine",
      "old": "ast w. ast/data dependence",
      "new": "none|ast|ast/data dependence"
    },
    {
      "action": "refine",
      "old": "ast w. control flow",
      "new": "none|ast|control flow"
    },
    {
      "action": "refine",
      "old": "ast w. ast/control dependence/control flow/data dependence/dominator/post dominator",
      "new": "none|ast|ast/control dependence/control flow/data dependence/dominator/post dominator"
    },
    {
      "action": "refine",
      "old": "ast w. call/control flow/data flow/ncs",
      "new": "none|ast|call/control flow/data flow/ncs"
    },
    {
      "action": "refine",
      "old": "ast w. data flow",
      "new": "none|ast|data flow"
    },
    {
      "action": "refine",
      "old": "ast w. ast/control flow/data flow/ncs",
      "new": "none|ast|ast/control flow/data flow/ncs"
    },
    {
      "action": "refine",
      "old": "sat w. ast/control dependence/data dependence/ncs",
      "new": "none|sat|ast/control dependence/data dependence/ncs"
    },
    {
      "action": "refine",
      "old": "ast/sub-token w. ast/data dependence/ncs/sub-token",
      "new": "none|ast/sub-token|ast/data dependence/ncs/sub-token"
    },
    {
      "action": "refine",
      "old": "ast w. ast/def-use relations",
      "new": "none|ast|ast/def-use relations"
    },
    {
      "action": "refine",
      "old": "user/repository/file w. repository has file/comment/fork/star/contribute",
      "new": "none|user/repository/file|repository has file/comment/fork/star/contribute"
    },
    {
      "action": "refine",
      "old": "identifiers in instructions w. control/data flow/dependence",
      "new": "none|identifiers in instructions|control {dependence,flow}/data {dependence,flow}"
    },
    {
      "action": "refine",
      "old": "operands w. call/data flow",
      "new": "none|operands|call/data flow"
    },
    {
      "action": "refine",
      "old": "api invocation nodes/ast/sub-token w. ast/data flow/ncs/sub token",
      "new": "none|api invocation nodes/ast/sub-token|ast/data flow/ncs/sub token"
    },
    {
      "action": "refine",
      "old": "user/repository w. introduction of vulnerability in repo by user at specific time",
      "new": "none|user/repository|introduction of vulnerability in repo by user at specific time"
    },
    {
      "action": "refine",
      "old": "pdg w. call edges",
      "new": "none|pdg|call edges"
    },
    {
      "action": "refine",
      "old": "ast w. ast/data dependence/ncs",
      "new": "none|ast|ast/data dependence/ncs"
    },
    {
      "action": "refine",
      "old": "ast w. ast/control flow",
      "new": "none|ast|ast/control flow"
    },
    {
      "action": "refine",
      "old": "instruction w. control dependence/control flow/data dependence/data flow",
      "new": "none|instruction|control dependence/control flow/data dependence/data flow"
    },
    {
      "action": "refine",
      "old": "statement w. data dependence",
      "new": "none|statement|data dependence"
    },
    {
      "action": "refine",
      "old": "statement w. call/control dependence/data dependence/data flow",
      "new": "none|statement|call/control dependence/data dependence/data flow"
    },
    {
      "action": "refine",
      "old": "ast w. ast/data flow/ncs/sibling",
      "new": "none|ast|ast/data flow/ncs/sibling"
    },
    {
      "action": "refine",
      "old": "ast w. ast/call/data flow",
      "new": "none|ast|ast/call/data flow"
    },
    {
      "action": "refine",
      "old": "statement w. control dependence",
      "new": "none|statement|control dependence"
    },
    {
      "action": "refine",
      "old": "ast/unique variable node w. all occurrences of a variable connected to the unique variable node/ast/data dependence/ordering of nodes accessing the same variable/sibling",
      "new": "none|ast/unique variable node|all occurrences of a variable connected to the unique variable node/ast/data dependence/ordering of nodes accessing the same variable/sibling"
    },
    {
      "action": "refine",
      "old": "user/repository w. contribution",
      "new": "none|user/repository|contribution"
    },
    {
      "action": "refine",
      "old": "operations/operands w. data dependence/data flow",
      "new": "none|operations/operands|data dependence/data flow"
    },
    {
      "action": "refine",
      "old": "ast/sub-token w. ast/control dependence/function call/import/inheritance/linear control/sub-token",
      "new": "none|ast/sub-token|ast/control dependence/function call/import/inheritance/linear control/sub-token"
    },
    {
      "action": "refine",
      "old": "token w. edges between identical tokens",
      "new": "none|token|edges between identical tokens"
    },
    {
      "action": "refine",
      "old": "component w. co-evolution/dependency",
      "new": "none|component|co-evolution/dependency"
    },
    {
      "action": "refine",
      "old": "ast w. ast/control flow/data dependence/dominator/post dominator",
      "new": "none|ast|ast/control flow/data dependence/dominator/post dominator"
    },
    {
      "action": "refine",
      "old": "ast w. ast/control flow/data flow",
      "new": "none|ast|ast/control flow/data flow"
    },
    {
      "action": "refine",
      "old": "file w. association/dependency",
      "new": "none|file|association/dependency"
    },
    {
      "action": "refine",
      "old": "ast w. ast/control dependence/control flow/data dependence/data flow/ncs",
      "new": "none|ast|ast/control dependence/control flow/data dependence/data flow/ncs"
    },
    {
      "action": "refine",
      "old": "statement w. data flow",
      "new": "none|statement|data flow"
    },
    {
      "action": "refine",
      "old": "repository/token w. source file in repo contains token",
      "new": "none|repository/token|source file in repo contains token"
    },
    {
      "action": "refine",
      "old": "ast w. ast/control flow/data dependence/ncs",
      "new": "none|ast|ast/control flow/data dependence/ncs"
    },
    {
      "action": "refine",
      "old": "module w. call dependency/data dependency",
      "new": "none|module|call dependency/data dependency"
    },
    {
      "action": "refine",
      "old": "ast w. ast/data flow/ncs",
      "new": "none|ast|ast/data flow/ncs"
    },
    {
      "action": "refine",
      "old": "control flow statements w. control flow",
      "new": "none|control flow statements|control flow"
    },
    {
      "action": "refine",
      "old": "ast w. ast/control dependence/control flow/data dependence/ncs",
      "new": "none|ast|ast/control dependence/control flow/data dependence/ncs"
    },
    {
      "action": "refine",
      "old": "developer w. worked on same file in same release",
      "new": "none|developer|worked on same file in same release"
    },
    {
      "action": "refine",
      "old": "basic block w. call/control flow",
      "new": "none|basic block|call/control flow"
    },
    {
      "action": "refine",
      "old": "ast w. ast/control dependence/data dependence",
      "new": "none|ast|ast/control dependence/data dependence"
    },
    {
      "action": "refine",
      "old": "operations/operands w. call/control flow/data dependence",
      "new": "none|operations/operands|call/control flow/data dependence"
    },
    {
      "action": "refine",
      "old": "api invocation/control statement w. usage order/data dependency",
      "new": "none|api invocation/control statement|usage order/data dependency"
    },
    {
      "action": "refine",
      "old": "ast w. ast/sibling",
      "new": "none|ast|ast/sibling"
    },
    {
      "action": "refine",
      "old": "ast w. ast/ncs",
      "new": "none|ast|ast/ncs"
    },
    {
      "action": "refine",
      "old": "ast w. ncs",
      "new": "none|ast|ncs"
    },
    {
      "action": "refine",
      "old": "ast w. control flow/data dependence",
      "new": "none|ast|control flow/data dependence"
    },
    {
      "action": "refine",
      "old": "package w. class/interface dependencies of classes/interfaces in packages",
      "new": "none|package|class/interface dependencies of classes/interfaces in packages"
    },
    {
      "action": "refine",
      "old": "ast w. ast/control dependence",
      "new": "none|ast|ast/control dependence"
    },
    {
      "action": "refine",
      "old": "ast w. ast/control dependence/control flow/data dependence/joint edge type for control and data dependence between the same two nodes",
      "new": "none|ast|ast/control dependence/control flow/data dependence/joint edge type for control and data dependence between the same two nodes"
    },
    {
      "action": "refine",
      "old": "ast w. ast/control dependence/control flow/data dependence",
      "new": "none|ast|ast/control dependence/control flow/data dependence"
    },
    {
      "action": "refine",
      "old": "ast/sub-token w. ast/ncs/sibling/sub token",
      "new": "none|ast/sub-token|ast/ncs/sibling/sub token"
    },
    {
      "action": "refine",
      "old": "ast w. ast/calls/control flow/data flow",
      "new": "none|ast|ast/calls/control flow/data flow"
    },
    {
      "action": "refine",
      "old": "ast w. ast/control flow/data flow/function call/ncs",
      "new": "none|ast|ast/control flow/data flow/function call/ncs"
    },
    {
      "action": "refine",
      "old": "ast w. ast/data flow",
      "new": "none|ast|ast/data flow"
    },
    {
      "action": "refine",
      "old": "token w. sliding window co-occurrence",
      "new": "none|token|sliding window co-occurrence"
    },
    {
      "action": "refine",
      "old": "module w. dependency",
      "new": "none|module|dependency"
    },
    {
      "action": "refine",
      "old": "ast w. ast/control flow/data flow/sibling",
      "new": "none|ast|ast/control flow/data flow/sibling"
    },
    {
      "action": "refine",
      "old": "repository/user/topic w. belongs to/contains topic/forked by/starred by",
      "new": "none|repository/user/topic|belongs to/contains topic/forked by/starred by"
    },
    {
      "action": "refine",
      "old": "developer/component w. contribution/dependencies",
      "new": "none|developer/component|contribution/dependencies"
    },
    {
      "action": "refine",
      "old": "ast w. ast/data flow/sibling",
      "new": "none|ast|ast/data flow/sibling"
    },
    {
      "action": "refine",
      "old": "ast/markdown token/CLS w. ast/ast-markdown edge/every node connected to CLS",
      "new": "none|ast/markdown token/CLS|ast/ast-markdown edge/every node connected to CLS"
    },
    {
      "action": "refine",
      "old": "ast w. ast/control flow/data dependence/data flow/ncs",
      "new": "none|ast|ast/control flow/data dependence/data flow/ncs"
    },
    {
      "action": "refine",
      "old": "file/directory/repository w. file system structure edges",
      "new": "none|file/directory/repository|file system structure edges"
    },
    {
      "action": "refine",
      "old": "function/class/class field/module/method w. call/define/type use/import/inherit",
      "new": "none|function/class/class field/module/method|call/define/type use/import/inherit"
    },
    {
      "action": "refine",
      "old": "ast w. ast/control dependence/control flow/data dependence/function call/ncs",
      "new": "none|ast|ast/control dependence/control flow/data dependence/function call/ncs"
    },
    {
      "action": "refine",
      "old": "ast/sub-tokens w. ast/control flow/data dependence/ncs/sub token",
      "new": "none|ast/sub-tokens|ast/control flow/data dependence/ncs/sub token"
    },
    {
      "action": "refine",
      "old": "unique code tokens w. co-occurrence sliding window",
      "new": "none|unique code tokens|co-occurrence sliding window"
    },
    {
      "action": "refine",
      "old": "ast/sub-tokens w. ast/data dependence/ncs/sub-token",
      "new": "none|ast/sub-tokens|ast/data dependence/ncs/sub-token"
    },
    {
      "action": "refine",
      "old": "pdg",
      "new": "pdg|statement|control dependence/data dependence"
    },
    {
      "action": "refine",
      "old": "cfg",
      "new": "cfg|statement|control flow"
    },
    {
      "action": "refine",
      "old": "ast/sub-token/edit (add, del, etc) w. ast/edit/sub-token",
      "new": "none|ast/sub-token/edit operation|ast/edit/sub-token"
    },
    {
      "action": "refine",
      "old": "ast, but whenever a list of nodes is aggregated (e.g. block body), a hyperedge is used instead",
      "new": "none|ast|ast/ast hyper-edge [for aggregation]"
    },
    {
      "action": "refine",
      "old": "ast + sub-tokens",
      "new": "none|ast/sub-tokens|ast/sub-tokens"
    },
    {
      "action": "refine",
      "old": "ast (trimmed)",
      "new": "none|ast [trimmed]|ast"
    },
    {
      "action": "refine",
      "old": "ast (syntax nodes)",
      "new": "none|ast [internal]|ast"
    },
    {
      "action": "refine",
      "old": "ncs",
      "new": "ncs|token|ncs"
    },
    {
      "action": "refine",
      "old": "fcg",
      "new": "fcg|function|call flow"
    },
    {
      "action": "refine",
      "old": "class/interface dependency network",
      "new": "dependency graph|class/interface|class & interface relationships"
    },
    {
      "action": "refine",
      "old": "dependency graph|class/interface|class & interface relationships",
      "new": "class dependency graph|class/interface|class & interface relationships"
    },
    {
      "action": "refine",
      "old": "parse tree (token/constituency symbol (eg. VERB) w. constituency edge/word ordering)",
      "new": "parse tree|token/constituency symbol (e.g. verb)|constituency edge/word ordering"
    },
    {
      "action": "refine",
      "old": "variable w. data {flow,dependence}",
      "new": "none|variable|data {flow,dependence}"
    },
    {
      "action": "refine",
      "old": "variable (every occurrence)/control statement w. data flow/control flow",
      "new": "none|variable [every occurrene]/control statement|data flow/control flow"
    },
    {
      "action": "refine",
      "old": "repository/user w/ contributes",
      "new": "none|repository/user|contributes"
    },
    {
      "action": "refine",
      "old": "pdg (statement) w. control flow, and one root \"method\" node connected to all statements",
      "new": "none|statement|control dependence/data dependence/control flow/root statement edge"
    },
    {
      "action": "refine",
      "old": "operands/opcode/labels in ir w. control dependence/flow (not clear)/data dependence",
      "new": "none|operands/opcode/labels in ir|control {dependence,flow}/data dependence"
    },
    {
      "action": "refine",
      "old": "code change genealogy (code change w/ change dependency)",
      "new": "code change genealogy|code change|change dependency"
    },
    {
      "action": "refine",
      "old": "ast (binarised)",
      "new": "ast[binarised]|ast|ast"
    },
    {
      "action": "refine",
      "old": "ast (trimmed) w. ast/control flow/data flow",
      "new": "none|ast[trimmed]|ast/control flow/data flow"
    },
    {
      "action": "refine",
      "old": "ast w/ special node _types_ for every api call",
      "new": "none|ast/node type per api call|ast"
    },
    {
      "action": "refine",
      "old": "ast w. control flow (or  dependence; unclear)/data dependence",
      "new": "none|ast|control {flow,dependence}/data dependence"
    },
    {
      "action": "refine",
      "old": "ast w. ast/ncs/data dependence/control flow/control dependence (_not_ cpg w/ ncs)",
      "new": "none|ast|ast/ncs/data dependence/control flow/control dependence"
    },
    {
      "action": "refine",
      "old": "none|ast|ast/control dependence/control flow/data dependence",
      "new": "cpg|ast|ast/control dependence/control flow/data dependence"
    },
    {
      "action": "refine",
      "old": "data item (shared variable, function) w. call/return/data flow",
      "new": "none|data item (e.g shared variable, function)|call/return/data flow"
    },
    {
      "action": "refine",
      "old": "cross method data dependency graph (vertex unclear, edge is data dependence)",
      "new": "none|statement|data dependence[inter and intra method]"
    },
    {
      "action": "refine",
      "old": "ast w. ast/ncs/hub (connect nodes which generally have many child nodes)",
      "new": "none|ast|ast/ncs/hub[connect node types which commonly have many children]"
    },
    {
      "action": "refine",
      "old": "ast w. ast/next subtree (connect nodes on same level)/data flow/control flow",
      "new": "none|ast|ast/data flow/control flow/next subtree (connect nodes on same level)"
    },
    {
      "action": "refine",
      "old": "ast (partial; generated by model)",
      "new": "ast[partial; generated by model]|ast|ast"
    },
    {
      "action": "refine",
      "old": "ast node type node (node per ast node type) -- edge between two nodes exists iff an edge exists between two nodes of those types in the original ast",
      "new": "none|ast node type node (node per ast node type)|edge iff edge between nodes of those types in ast"
    },
    {
      "action": "refine",
      "old": "two pdgs (old/new version) with mapping edges and control flow edges",
      "new": "none|statement[from old and new  code]|control dependence/data dependence/old to new statement mapping"
    },
    {
      "action": "refine",
      "old": "token (in statement) w. control flow (between statement)/next token (in statement)",
      "new": "none|token[in statement]|control flow[between statements]/ncs[in statement]"
    },
    {
      "action": "refine",
      "old": "statement/token (one for every unique token) w. statement <-> token edge",
      "new": "none|statement/token[unique]|statement contains token"
    },
    {
      "action": "refine",
      "old": "partial ast (generated during code completion)",
      "new": "ast[partial, generated]|ast|ast"
    },
    {
      "action": "refine",
      "old": "partial ast (generated during code completion) w. ast/sibling",
      "new": "ast[partial, generated]|ast|ast/sibling"
    },
    {
      "action": "refine",
      "old": "ast[partial; generated by model]|ast|ast",
      "new": "ast[partial; generated]|ast|ast"
    },
    {
      "action": "refine",
      "old": "ast[partial; generated]|ast|ast",
      "new": "ast[partial, generated]|ast|ast"
    },
    {
      "action": "refine",
      "old": "ast (merged nodes) w. ast/ncs/leaf to root",
      "new": "node|ast[merged]|ast/ncs/leaf to root"
    },
    {
      "action": "refine",
      "old": "ast (with some edges reversed to point to statements in particular)",
      "new": "none|ast|ast[some edges reversed to point to statements]"
    },
    {
      "action": "refine",
      "old": "class/property/method/paremeter/variable w. inheritance/has/instance_of/return_type/call",
      "new": "none|class/property/method/parameter/variable|inheritance/has/instance of/return type/call"
    },
    {
      "action": "refine",
      "old": "connected asts based on method call chain",
      "new": "ast[inter method]|ast|ast"
    },
    {
      "action": "refine",
      "old": "connected cfgs based on method call chain",
      "new": "cfg[inter method]|statement|control flow"
    },
    {
      "action": "refine",
      "old": "interprocedural cfg",
      "new": "cfg[inter method]|statement|control flow"
    },
    {
      "action": "refine",
      "old": "ast (split up)",
      "new": "ast[split up]|ast|ast"
    },
    {
      "action": "refine",
      "old": "cfg (basic block; interprocedural) with ast subtrees per node",
      "new": "cfg[inter method] + ast subtrees|basic block/ast|control flow/ast"
    },
    {
      "action": "refine",
      "old": "cfg with data flow edges, with an ast sub-tree per node",
      "new": "cfg + ast subtree|statement/ast|control flow/data flow/ast"
    },
    {
      "action": "refine",
      "old": "cfg with data flow and ast sub-tree per basic block node",
      "new": "cfg + ast subtree|basic block/ast|control flow/data flow/ast"
    },
    {
      "action": "refine",
      "old": "cfg with ast-subtree per node",
      "new": "cfg + ast subtree|statement/ast|control flow/ast"
    },
    {
      "action": "refine",
      "old": "pdg with more specific node and edge types",
      "new": "pdg[more specific edge types]|statement|control dependence/data dependence"
    },
    {
      "action": "refine",
      "old": "program elements at different levels (variables, statements, methods, classes, packages) w. control dependence/data dependence/program relations (e.g. inherit)",
      "new": "none|program elements at different levels[variables, statements, methods, classes, packages]|control dependence/program relationships (e.g inherit)/data dependence"
    },
    {
      "action": "refine",
      "old": "statement w. control flow/control dependence/data depenendence, where every node has an AST sub-tree",
      "new": "none + ast subtrees|statement/ast|ast/control flow/control dependence/data dependence"
    },
    {
      "action": "refine",
      "old": "pdg (w/ specific edge types for control/data dependencies of particular interest to vulnerability, determined using SyVC -- syntactic vulnerability candidate)",
      "new": "pdg[specific edge types for vulnerability specific constructs]|statement|control dependence/data dependence"
    },
    {
      "action": "refine",
      "old": "pdg[specific edge types for vulnerability specific constructs]|statement|control dependence/data dependence",
      "new": "pdg[more specific edge types]|statement|control dependence/data dependence"
    },
    {
      "action": "refine",
      "old": "operands/opcodes/labels in ir w. control dependence/data dependence/oop related links (e.g. link method to instance)",
      "new": "none|operands/opcodes/labels in ir|control dependence/data dependence/oop related links (e.g. method to intance)"
    },
    {
      "action": "refine",
      "old": "methods/fields/constructors/semantic relation nodes (callls, reads, writes, sync, modifier); the former node types are connected through untyped edges with a semntic relation node in between",
      "new": "none|methods/fields/constructors/relation nodes[calls, reads, writes, sync, modified]|nodes connected with relation node in between"
    },
    {
      "action": "refine",
      "old": "line w. control flow/data flow/re-entrancy (call.value)/first <-> last line",
      "new": "none|line|control flow/data flow/re-entrancy (call.value)/first to last line"
    },
    {
      "action": "refine",
      "old": "labelled pushdown system (states w. transitions)",
      "new": "labelled pushdown system|state|transitions between states"
    },
    {
      "action": "refine",
      "old": "ir instructions + types w. control flow/data flow",
      "new": "none|ir instructions + types|control flow/data flow"
    },
    {
      "action": "refine",
      "old": "developers/isues/files/tags w. labelled/reviewed/comitted/similar (link issues to possibly related source files)",
      "new": "none|developers/issues/files/tags|labelled/reviewed/committed/issue similar to file"
    },
    {
      "action": "refine",
      "old": "developer/software component w. contribution (dev <-> component)/dependencies (component <-> component)",
      "new": "none|developer/software component|contribution/dependency"
    },
    {
      "action": "refine",
      "old": "developer/module w. contribution/dependency (co-evolution, call)/collaboration",
      "new": "none|developer/module|contribution/co-evolution/dependency (eg call)/collaboration"
    },
    {
      "action": "refine",
      "old": "expressions/constants w. relations (e.g. L += R; anything relating two names)",
      "new": "none|expressions/constants|relationships (e.g. L += R)"
    },
    {
      "action": "refine",
      "old": "dependency parse graph (token w. ncs and dependencies)",
      "new": "dependency parse graph|token|ncs/parse dependencies"
    },
    {
      "action": "refine",
      "old": "dependency parse graph (token + sub-token w. dependency/ncs/sub token)",
      "new": "dependency parse graph|token/sub-token|ncs/parse dependency/sub-token"
    },
    {
      "action": "refine",
      "old": "api usages w. control flow and data flow",
      "new": "none|api usages|control flow/data flow"
    },
    {
      "action": "refine",
      "old": "api dependency graph",
      "new": "api dependency graph|api (e.g. method)|dependency"
    },
    {
      "action": "refine",
      "old": "ast leaf nodes (only!), connected by edges annotated with the path between the two leaf nodes (provided it is less than some length) [based on syntactic dependency parsing]",
      "new": "none|ast leaf|edge annotated with path between two nodes in full ast"
    },
    {
      "action": "refine",
      "old": "constants/properties/methods/globals w. relations (e.g. L += R; anything relating to names)",
      "new": "none|constants/properties/methods/globals|relations (e.g. L += R)"
    },
    {
      "action": "refine",
      "old": "ast (annotated according to changes in old vs new version)",
      "new": "ast|ast[both old and new code, annotated {old,unchanged,new}]|ast"
    },
    {
      "action": "refine",
      "old": "core(critical for vulnerability; statement)/normal(not core)/fallback(fallback function) w. control flow/data flow/fallback",
      "new": "none|statement[marked core or normal]/fallback (fallback function)|control flow/data flow/fallback"
    },
    {
      "action": "refine",
      "old": "developer/project/question/ability w. follows (dev -> dev)/answered/asked/commit (d <-> p)/labelled (p <-> a, q<->a)",
      "new": "none|developer/project/question/ability|follows/answered/asked/committed/labelled (project - ability or question - ability)"
    },
    {
      "action": "refine",
      "old": "hypergraph connecting types. Edges include subtype, function arguments, call parameters, a=b.l, ,similar names, usage",
      "new": "none|types|hyperedge encoding relations between types (e.g. function signature, property access, has name, is boolean)"
    },
    {
      "action": "refine",
      "old": "none|types|hyperedge encoding relations between types (e.g. function signature, property access, has name, is boolean)",
      "new": "none|types|hyperedges encoding relations between types (e.g. function signature, property access, has name, is boolean)"
    },
    {
      "action": "refine",
      "old": "two contwo connected variants of ast w. ast/changes (old/new)/unchanged",
      "new": "none|ast[old + new]|ast/new/old/unchanged"
    },
    {
      "action": "refine",
      "old": "statement w. control dependence/data dependence/name flow (two graphs old/new, merged based on unchanged nodes)",
      "new": "none|statement[old + new merged on unchanged nodes]|control dependence/data dependence/name flow"
    },
    {
      "action": "refine",
      "old": "statement w. contrlol flow/data flow/name flow/sub-token co-occurence (two graphs old/new merged on unchanged nodes)",
      "new": "none|statement[old + new merged on unchanged nodes]|control flow/data flow/name flow/sub-token co-occurrence"
    },
    {
      "action": "refine",
      "old": "pull requests/work items/author/reviewer/source  code file/repository/tokens in prs -- w. -- creates/reviews/contains/changes/li nked to/comments on/parent of /token edge",
      "new": "none|pull request/work item/author/reviewer/source code file/repository/tokens in PR|creates/reviews/repository contains PR/PR changes file/PR linked to work item/reviewer comments on PR/work item parent of work item/token in PR"
    },
    {
      "action": "refine",
      "old": "objects/values/operations in source code/field access etc. w. call flow/control flow (specific edge types)",
      "new": "none|objects/values/method invocations/constructor calls/field access/conditional checks/inheritance|call/control flow/sequential execution/synchronization/throw/handle/param"
    },
    {
      "action": "refine",
      "old": "program elements (module, class function etc)/ast type node/ast node w. depencies (\"relations\")/ast type edge/ast edge",
      "new": "none|program elements (modules, classes, functions etc)/ast type/ast|dependencies/ast type/ast"
    },
    {
      "action": "refine",
      "old": "program elements (methods, apis, classes packages etc) w. method <-> api calls/project structure (eg. belongs to)",
      "new": "none|methods/api/structural (e.g. class or package)|method uses api/project structure"
    },
    {
      "action": "refine",
      "old": "none|pdg|call edges",
      "new": "none[inter method]|statement|control dependence/data dependence/call"
    },
    {
      "action": "refine",
      "old": "one node represents entire graph (pdg)/nodes representing control flow paths/nodes representing statements/node representing tokens w. graph <-> path edges, path <-> statement edges, changed node edge (old/new)/data dependence/control dependence/token <-> statement edge",
      "new": "none|node representing cfg/nodes representing control flow paths/statement/tokens|graph to path/path to statement/changed node (old vs new)/data dependence/control dependence/statement to node"
    },
    {
      "action": "refine",
      "old": "design pattern specification meta model -- source code",
      "new": "design pattern specification - source code|types/members of types (fields or methods)|structural relationships in and between types"
    },
    {
      "action": "refine",
      "old": "design pattern specification meta model -- design pattern",
      "new": "design pattern specification - patterns|types/members of types/behaviours|type has <property>"
    },
    {
      "action": "refine",
      "old": "none|operands/opcode/labels in ir|control {dependence,flow}/data dependence",
      "new": "none|operands/opcode/labels in IR|control {dependence,flow}/data dependence"
    },
    {
      "action": "refine",
      "old": "none|control flow statements|control flow",
      "new": "none|control statement|control flow"
    },
    {
      "action": "refine",
      "old": "none|ast/unique variable node|all occurrences of a variable connected to the unique variable node/ast/data dependence/ordering of nodes accessing the same variable/sibling",
      "new": "none|ast/variable [unique]|all occurrences of a variable connected to the unique variable node/ast/data dependence/ordering of nodes accessing the same variable/sibling"
    },
    {
      "action": "refine",
      "old": "none|instructions|call/control flow/data dependence/data flow",
      "new": "none|instruction|call/control flow/data dependence/data flow"
    },
    {
      "action": "refine",
      "old": "none|ast/sub-tokens|ast/data dependence/ncs/sub-token",
      "new": "none|ast/sub-token|ast/data dependence/ncs/sub-token"
    },
    {
      "action": "refine",
      "old": "none|variables/labels in IR|data flow/data dependence/control flow",
      "new": "none|variable/labels in IR|data flow/data dependence/control flow"
    },
    {
      "action": "refine",
      "old": "none|methods/fields/constructors/relation nodes[calls, reads, writes, sync, modified]|nodes connected with relation node in between",
      "new": "none|method/fields/constructors/relation nodes [calls, reads, writes, sync, modified]|nodes connected with relation node in between"
    },
    {
      "action": "refine",
      "old": "none|ast/sub-tokens|ast/control flow/data dependence/ncs/sub token",
      "new": "none|ast/sub-token|ast/control flow/data dependence/ncs/sub token"
    },
    {
      "action": "refine",
      "old": "none|program elements (modules, classes, functions etc)/ast type/ast|dependencies/ast type/ast",
      "new": "none|program elements (modules, classes, functions etc)/ast node type/ast|dependencies/ast type/ast"
    },
    {
      "action": "refine",
      "old": "none|developers/issues/files/tags|labelled/reviewed/committed/issue similar to file",
      "new": "none|developer/issues/file/tags|labelled/reviewed/committed/issue similar to file"
    },
    {
      "action": "refine",
      "old": "none|operands/opcodes/labels in ir|control dependence/data dependence/oop related links (e.g. method to intance)",
      "new": "none|operands/opcode/labels in IR|control dependence/data dependence/oop related links (e.g. method to intance)"
    },
    {
      "action": "refine",
      "old": "none|ast node type node (node per ast node type)|edge iff edge between nodes of those types in ast",
      "new": "none|ast node type (node per ast node type)|edge iff edge between nodes of those types in ast"
    },
    {
      "action": "refine",
      "old": "none|unique code tokens|co-occurrence sliding window",
      "new": "none|token [code, unique]|co-occurrence sliding window"
    },
    {
      "action": "refine",
      "old": "none|ast/sub-tokens|ast/sub-tokens",
      "new": "none|ast/sub-token|ast/sub-tokens"
    },
    {
      "action": "refine",
      "old": "none|methods/api/structural (e.g. class or package)|method uses api/project structure",
      "new": "none|method/api/structural (e.g. class or package)|method uses api/project structure"
    },
    {
      "action": "refine",
      "old": "none|pull request/work item/author/reviewer/source code file/repository/tokens in PR|creates/reviews/repository contains PR/PR changes file/PR linked to work item/reviewer comments on PR/work item parent of work item/token in PR",
      "new": "none|pull request/work item/author/reviewer/source code file/repository/token [PR]|creates/reviews/repository contains PR/PR changes file/PR linked to work item/reviewer comments on PR/work item parent of work item/token in PR"
    },
    {
      "action": "refine",
      "old": "none|constants/properties/methods/globals|relations (e.g. L += R)",
      "new": "none|constants/property/method/globals|relations (e.g. L += R)"
    },
    {
      "action": "refine",
      "old": "none|ast/sub-tokens|ast/control flow/ncs/sibling/data flow/sub token",
      "new": "none|ast/sub-token|ast/control flow/ncs/sibling/data flow/sub token"
    },
    {
      "action": "refine",
      "old": "none|node representing cfg/nodes representing control flow paths/statement/tokens|graph to path/path to statement/changed node (old vs new)/data dependence/control dependence/statement to node",
      "new": "none|node representing cfg/nodes representing control flow paths/statement/token|graph to path/path to statement/changed node (old vs new)/data dependence/control dependence/statement to node"
    },
    {
      "action": "refine",
      "old": "none|pull request/work item/author/reviewer/source code file/repository/token [PR]|creates/reviews/repository contains PR/PR changes file/PR linked to work item/reviewer comments on PR/work item parent of work item/token in PR",
      "new": "none|pull request/work item/author/reviewer/source code file/repository/token [PR]|creates/reviewed/repository contains PR/PR changes file/PR linked to work item/reviewer comments on PR/work item parent of work item/token in PR"
    },
    {
      "action": "refine",
      "old": "none|function/class/class field/module/method|call/define/type use/import/inherit",
      "new": "none|function/class/class field/module/method|call/define/type use/import/inheritance"
    },
    {
      "action": "refine",
      "old": "none|ast|ast/control dependence/control flow/data dependence/function call/ncs",
      "new": "none|ast|ast/control dependence/control flow/data dependence/call/ncs"
    },
    {
      "action": "refine",
      "old": "none|repository/user|contributes",
      "new": "none|repository/user|contribution"
    },
    {
      "action": "refine",
      "old": "none|ast|ast/calls/control flow/data flow",
      "new": "none|ast|ast/call/control flow/data flow"
    },
    {
      "action": "refine",
      "old": "none|ast/sub-token|ast/sub-tokens",
      "new": "none|ast/sub-token|ast/sub-token"
    },
    {
      "action": "refine",
      "old": "none|variable|data {flow,dependence}",
      "new": "none|variable|data {dependence,flow}"
    },
    {
      "action": "refine",
      "old": "fcg|function|call flow",
      "new": "fcg|function|call"
    },
    {
      "action": "refine",
      "old": "none|module|call dependency/data dependency",
      "new": "none|module|call dependency/data dependence"
    },
    {
      "action": "refine",
      "old": "none|ast/sub-token|ast/control dependence/function call/import/inheritance/linear control/sub-token",
      "new": "none|ast/sub-token|ast/control dependence/call/import/inheritance/linear control/sub-token"
    },
    {
      "action": "refine",
      "old": "none|expressions/constants|relationships (e.g. L += R)",
      "new": "none|expressions/constants|relations (e.g. L += R)"
    },
    {
      "action": "refine",
      "old": "none|repository/user/topic|belongs to/contains topic/forked by/starred by",
      "new": "none|repository/user/topic|belongs to/contains topic/fork/starred by"
    },
    {
      "action": "refine",
      "old": "none|ast/sub-token|ast/control flow/ncs/sibling/data flow/sub token",
      "new": "none|ast/sub-token|ast/control flow/ncs/sibling/data flow/sub-token"
    },
    {
      "action": "refine",
      "old": "dependency parse graph|token|ncs/parse dependencies",
      "new": "dependency parse graph|token|ncs/parse dependency"
    },
    {
      "action": "refine",
      "old": "none|ast|ast/control flow/data flow/function call/ncs",
      "new": "none|ast|ast/control flow/data flow/call/ncs"
    },
    {
      "action": "refine",
      "old": "none|user/repository/file|repository has file/comment/fork/star/contribute",
      "new": "none|user/repository/file|repository has file/comment/fork/star/contribution"
    },
    {
      "action": "refine",
      "old": "dependency graph|component|depedencies",
      "new": "dependency graph|component|dependencies"
    },
    {
      "action": "refine",
      "old": "none|api invocation/control statement|usage order/data dependency",
      "new": "none|api invocation/control statement|usage order/data dependence"
    },
    {
      "action": "refine",
      "old": "none|ast|control {flow,dependence}/data dependence",
      "new": "none|ast|control {dependence,flow}/data dependence"
    },
    {
      "action": "refine",
      "old": "none|ast/sub-token|ast/ncs/sibling/sub token",
      "new": "none|ast/sub-token|ast/ncs/sibling/sub-token"
    },
    {
      "action": "refine",
      "old": "none|api invocation nodes/ast/sub-token|ast/data flow/ncs/sub token",
      "new": "none|api invocation nodes/ast/sub-token|ast/data flow/ncs/sub-token"
    },
    {
      "action": "refine",
      "old": "none|ast/sub-token|ast/control flow/data dependence/ncs/sub token",
      "new": "none|ast/sub-token|ast/control flow/data dependence/ncs/sub-token"
    },
    {
      "action": "refine",
      "old": "none|objects/values/method invocations/constructor calls/field access/conditional checks/inheritance|call/control flow/sequential execution/synchronization/throw/handle/param",
      "new": "none|objects/values/method invocations/constructor calls/field access/control statement/inheritance|call/control flow/sequential execution/synchronization/throw/handle/param"
    },
    {
      "action": "refine",
      "old": "none|file/directory/repository|file system structure edges",
      "new": "none|source code file/directory/repository|file system structure edges"
    },
    {
      "action": "refine",
      "old": "none|sat|ast/control dependence/data dependence/ncs",
      "new": "none|ast|ast/control dependence/data dependence/ncs"
    },
    {
      "action": "refine",
      "old": "none|developer/issues/file/tags|labelled/reviewed/committed/issue similar to file",
      "new": "none|developer/issues/source code file/tags|labelled/reviewed/committed/issue similar to file"
    },
    {
      "action": "refine",
      "old": "none|file|association/dependency",
      "new": "none|source code file|association/dependency"
    },
    {
      "action": "refine",
      "old": "none|method/fields/constructors/relation nodes [calls, reads, writes, sync, modified]|nodes connected with relation node in between",
      "new": "none|method/class field/constructors/relation nodes [calls, reads, writes, sync, modified]|nodes connected with relation node in between"
    },
    {
      "action": "refine",
      "old": "none|api invocation nodes/ast/sub-token|ast/data flow/ncs/sub-token",
      "new": "none|api invocation/ast/sub-token|ast/data flow/ncs/sub-token"
    },
    {
      "action": "refine",
      "old": "none|developer/software component|contribution/dependency",
      "new": "none|developer/component|contribution/dependency"
    },
    {
      "action": "refine",
      "old": "none|file/user|contribution",
      "new": "none|source code file/user|contribution"
    },
    {
      "action": "refine",
      "old": "none|user/repository/file|repository has file/comment/fork/star/contribution",
      "new": "none|user/repository/source code file|repository has file/comment/fork/star/contribution"
    },
    {
      "action": "refine",
      "old": "none|ast|control {dependence,flow}/data dependence",
      "new": "none|ast|control {dependence,flow}/data flow or dependence"
    },
    {
      "action": "refine",
      "old": "none|ast|ast/call/control flow/data flow",
      "new": "none|ast|ast/call/control flow/data flow or dependence"
    },
    {
      "action": "refine",
      "old": "none|statement|data dependence[inter and intra method]",
      "new": "none|statement|data flow or dependence [inter and intra method]"
    },
    {
      "action": "refine",
      "old": "none|instruction|call/control flow/data dependence/data flow",
      "new": "none|instruction|call/control flow/data flow or dependence/data flow or dependence"
    },
    {
      "action": "refine",
      "old": "none|ast[trimmed]|ast/control flow/data flow",
      "new": "none|ast [trimmed]|ast/control flow/data flow or dependence"
    },
    {
      "action": "refine",
      "old": "none|ast|ast/ncs/data dependence/control flow/control dependence",
      "new": "none|ast|ast/ncs/data flow or dependence/control flow/control dependence"
    },
    {
      "action": "refine",
      "old": "none|instruction|control dependence/control flow/data dependence/data flow",
      "new": "none|instruction|control dependence/control flow/data flow or dependence/data flow or dependence"
    },
    {
      "action": "refine",
      "old": "none|ast/sub-token|ast/control flow/ncs/sibling/data flow/sub-token",
      "new": "none|ast/sub-token|ast/control flow/ncs/sibling/data flow or dependence/sub-token"
    },
    {
      "action": "refine",
      "old": "none|ast|ast/data dependence/ncs",
      "new": "none|ast|ast/data flow or dependence/ncs"
    },
    {
      "action": "refine",
      "old": "none[inter method]|statement|control dependence/data dependence/call",
      "new": "none[inter method]|statement|control dependence/data flow or dependence/call"
    },
    {
      "action": "refine",
      "old": "none|ast|ast/control flow/data dependence/data flow/ncs",
      "new": "none|ast|ast/control flow/data flow or dependence/data flow or dependence/ncs"
    },
    {
      "action": "refine",
      "old": "none|objects/values/method invocations/constructor calls/field access/control statement/inheritance|call/control flow/sequential execution/synchronization/throw/handle/param",
      "new": "none|objects/values/method invocations/constructor calls/field access/control statement/inheritance|call/control flow/control flow [linear]/synchronization/throw/handle/param"
    },
    {
      "action": "refine",
      "old": "none|api invocation/control statement|usage order/data dependence",
      "new": "none|api invocation/control statement|usage order/data flow or dependence"
    },
    {
      "action": "refine",
      "old": "none|ast|control flow/data dependence",
      "new": "none|ast|control flow/data flow or dependence"
    },
    {
      "action": "refine",
      "old": "none|data item (e.g shared variable, function)|call/return/data flow",
      "new": "none|data item (e.g shared variable, function)|call/return/data flow or dependence"
    },
    {
      "action": "refine",
      "old": "none|ast/variable [unique]|all occurrences of a variable connected to the unique variable node/ast/data dependence/ordering of nodes accessing the same variable/sibling",
      "new": "none|ast/variable [unique]|all occurrences of a variable connected to the unique variable node/ast/data flow or dependence/ordering of nodes accessing the same variable/sibling"
    },
    {
      "action": "refine",
      "old": "none|statement|data flow",
      "new": "none|statement|data flow or dependence"
    },
    {
      "action": "refine",
      "old": "none|ast|ast/control flow/data flow/sibling",
      "new": "none|ast|ast/control flow/data flow or dependence/sibling"
    },
    {
      "action": "refine",
      "old": "none|ast|data flow",
      "new": "none|ast|data flow or dependence"
    },
    {
      "action": "refine",
      "old": "none|ir instructions + types|control flow/data flow",
      "new": "none|ir instructions + types|control flow/data flow or dependence"
    },
    {
      "action": "refine",
      "old": "none|ast/sub-token|ast/data dependence/ncs/sub-token",
      "new": "none|ast/sub-token|ast/data flow or dependence/ncs/sub-token"
    },
    {
      "action": "refine",
      "old": "none|ast|ast/data dependence",
      "new": "none|ast|ast/data flow or dependence"
    },
    {
      "action": "refine",
      "old": "none|statement|control dependence/data dependence/control flow/root statement edge",
      "new": "none|statement|control dependence/data flow or dependence/control flow/root statement edge"
    },
    {
      "action": "refine",
      "old": "none|ast|ast/data flow/ncs",
      "new": "none|ast|ast/data flow or dependence/ncs"
    },
    {
      "action": "refine",
      "old": "none|class/property/method/parameter/variable|inheritance/has/instance of/return type/call",
      "new": "none|class/property/method/parameter/variable|class & interface relationships/has/instance of/return type/call"
    },
    {
      "action": "refine",
      "old": "none|ast|ast/control flow/data flow/call/ncs",
      "new": "none|ast|ast/control flow/data flow or dependence/call/ncs"
    },
    {
      "action": "refine",
      "old": "none|api usages|control flow/data flow",
      "new": "none|api usages|control flow/data flow or dependence"
    },
    {
      "action": "refine",
      "old": "none|ast|ast/control dependence/control flow/data dependence/ncs",
      "new": "none|ast|ast/control dependence/control flow/data flow or dependence/ncs"
    },
    {
      "action": "refine",
      "old": "none|ast|ast/data flow/sibling",
      "new": "none|ast|ast/data flow or dependence/sibling"
    },
    {
      "action": "refine",
      "old": "none|source code file/directory/repository|file system structure edges",
      "new": "none|source code file/directory/repository|project structure"
    },
    {
      "action": "refine",
      "old": "none|ast/sub-token|ast/control flow/data dependence/ncs/sub-token",
      "new": "none|ast/sub-token|ast/control flow/data flow or dependence/ncs/sub-token"
    },
    {
      "action": "refine",
      "old": "none|statement[marked core or normal]/fallback (fallback function)|control flow/data flow/fallback",
      "new": "none|statement [marked core or normal]/fallback (fallback function)|control flow/data flow or dependence/call"
    },
    {
      "action": "refine",
      "old": "none|ast|ast/control flow/data flow/ncs",
      "new": "none|ast|ast/control flow/data flow or dependence/ncs"
    },
    {
      "action": "refine",
      "old": "none|statement[old + new merged on unchanged nodes]|control flow/data flow/name flow/sub-token co-occurrence",
      "new": "none|statement [old + new merged on unchanged nodes]|control flow/data flow or dependence/name flow/sub-token co-occurrence"
    },
    {
      "action": "refine",
      "old": "none|ast|ast/def-use relations",
      "new": "none|ast|ast/data flow or dependence"
    },
    {
      "action": "refine",
      "old": "none|operands/opcode/labels in IR|control {dependence,flow}/data dependence",
      "new": "none|operands/opcode/labels in IR|control {dependence,flow}/data flow or dependence"
    },
    {
      "action": "refine",
      "old": "none|variable|data {dependence,flow}",
      "new": "none|variable|data flow or dependence"
    },
    {
      "action": "refine",
      "old": "none|module|call dependency/data dependence",
      "new": "none|module|call dependency/data flow or dependence"
    },
    {
      "action": "refine",
      "old": "none|operations/operands|call/control flow/data dependence",
      "new": "none|operations/operands|call/control flow/data flow or dependence"
    },
    {
      "action": "refine",
      "old": "none|ast|ast/data flow/control flow/next subtree (connect nodes on same level)",
      "new": "none|ast|ast/data flow or dependence/control flow/next subtree (connect nodes on same level)"
    },
    {
      "action": "refine",
      "old": "none|ast|ast/control dependence/control flow/data dependence/dominator/post dominator",
      "new": "none|ast|ast/control dependence/control flow/data flow or dependence/dominator/post dominator"
    },
    {
      "action": "refine",
      "old": "none|token [code, unique]|co-occurrence sliding window",
      "new": "none|token [code, unique]|sliding window co-occurrence"
    },
    {
      "action": "refine",
      "old": "none|ast|ast/control flow/data dependence/ncs",
      "new": "none|ast|ast/control flow/data flow or dependence/ncs"
    },
    {
      "action": "refine",
      "old": "none|node representing cfg/nodes representing control flow paths/statement/token|graph to path/path to statement/changed node (old vs new)/data dependence/control dependence/statement to node",
      "new": "none|node representing cfg/nodes representing control flow paths/statement/token|graph to path/path to statement/changed node (old vs new)/data flow or dependence/control dependence/statement to node"
    },
    {
      "action": "refine",
      "old": "none|ast|call/control flow/data flow/ncs",
      "new": "none|ast|call/control flow/data flow or dependence/ncs"
    },
    {
      "action": "refine",
      "old": "none|operations/operands|data dependence/data flow",
      "new": "none|operations/operands|data flow or dependence/data flow or dependence"
    },
    {
      "action": "refine",
      "old": "none|function/class/class field/module/method|call/define/type use/import/inheritance",
      "new": "none|function/class/class field/module/method|call/define/type use/import/class & interface relationships"
    },
    {
      "action": "refine",
      "old": "none|identifiers in instructions|control {dependence,flow}/data {dependence,flow}",
      "new": "none|identifiers in instructions|control {dependence,flow}/data flow or dependence"
    },
    {
      "action": "refine",
      "old": "none|variable [every occurrene]/control statement|data flow/control flow",
      "new": "none|variable [every occurrene]/control statement|data flow or dependence/control flow"
    },
    {
      "action": "refine",
      "old": "none|statement|data dependence",
      "new": "none|statement|data flow or dependence"
    },
    {
      "action": "refine",
      "old": "pdg|statement|control dependence/data dependence",
      "new": "pdg|statement|control dependence/data flow or dependence"
    },
    {
      "action": "refine",
      "old": "none|ast/sub-token|ast/control dependence/call/import/inheritance/linear control/sub-token",
      "new": "none|ast/sub-token|ast/control dependence/call/import/class & interface relationships/control flow [linear]/sub-token"
    },
    {
      "action": "refine",
      "old": "none|ast|ast/control dependence/control flow/data dependence/data flow/ncs",
      "new": "none|ast|ast/control dependence/control flow/data flow or dependence/data flow or dependence/ncs"
    },
    {
      "action": "refine",
      "old": "none|statement[old + new merged on unchanged nodes]|control dependence/data dependence/name flow",
      "new": "none|statement [old + new merged on unchanged nodes]|control dependence/data flow or dependence/name flow"
    },
    {
      "action": "refine",
      "old": "none|variable/labels in IR|data flow/data dependence/control flow",
      "new": "none|variable/labels in IR|data flow or dependence/data flow or dependence/control flow"
    },
    {
      "action": "refine",
      "old": "none|ast|ast/data flow",
      "new": "none|ast|ast/data flow or dependence"
    },
    {
      "action": "refine",
      "old": "none|operands|call/data flow",
      "new": "none|operands|call/data flow or dependence"
    },
    {
      "action": "refine",
      "old": "none|ast|ast/control flow/data flow",
      "new": "none|ast|ast/control flow/data flow or dependence"
    },
    {
      "action": "refine",
      "old": "none|operands/opcode/labels in IR|control dependence/data dependence/oop related links (e.g. method to intance)",
      "new": "none|operands/opcode/labels in IR|control dependence/data flow or dependence/oop related links (e.g. method to intance)"
    },
    {
      "action": "refine",
      "old": "none|repository/user/topic|belongs to/contains topic/fork/starred by",
      "new": "none|repository/user/topic|belongs to/contains topic/fork/star"
    },
    {
      "action": "refine",
      "old": "pdg[more specific edge types]|statement|control dependence/data dependence",
      "new": "pdg[more specific edge types]|statement|control dependence/data flow or dependence"
    },
    {
      "action": "refine",
      "old": "none|api invocation/ast/sub-token|ast/data flow/ncs/sub-token",
      "new": "none|api invocation/ast/sub-token|ast/data flow or dependence/ncs/sub-token"
    },
    {
      "action": "refine",
      "old": "cfg + ast subtree|basic block/ast|control flow/data flow/ast",
      "new": "cfg + ast subtree|basic block/ast|control flow/data flow or dependence/ast"
    },
    {
      "action": "refine",
      "old": "none|statement|call/control dependence/data dependence/data flow",
      "new": "none|statement|call/control dependence/data flow or dependence/data flow or dependence"
    },
    {
      "action": "refine",
      "old": "cpg|ast|ast/control dependence/control flow/data dependence",
      "new": "cpg|ast|ast/control dependence/control flow/data flow or dependence"
    },
    {
      "action": "refine",
      "old": "none|ast|ast/control flow/data flow/ncs/sibling",
      "new": "none|ast|ast/control flow/data flow or dependence/ncs/sibling"
    },
    {
      "action": "refine",
      "old": "none|ast|ast/control dependence/data dependence",
      "new": "none|ast|ast/control dependence/data flow or dependence"
    },
    {
      "action": "refine",
      "old": "none|line|control flow/data flow/re-entrancy (call.value)/first to last line",
      "new": "none|line|control flow/data flow or dependence/control flow (call.value)/first to last line"
    },
    {
      "action": "refine",
      "old": "none|statement|control flow/data flow",
      "new": "none|statement|control flow/data flow or dependence"
    },
    {
      "action": "refine",
      "old": "none|ast|ast/control dependence/control flow/data dependence/joint edge type for control and data dependence between the same two nodes",
      "new": "none|ast|ast/control dependence/control flow/data flow or dependence/joint edge type for control and data dependence between the same two nodes"
    },
    {
      "action": "refine",
      "old": "none + ast subtrees|statement/ast|ast/control flow/control dependence/data dependence",
      "new": "none + ast subtrees|statement/ast|ast/control flow/control dependence/data flow or dependence"
    },
    {
      "action": "refine",
      "old": "none|ast|ast/data flow/ncs/sibling",
      "new": "none|ast|ast/data flow or dependence/ncs/sibling"
    },
    {
      "action": "refine",
      "old": "none|ast|ast/control dependence/control flow/data dependence/call/ncs",
      "new": "none|ast|ast/control dependence/control flow/data flow or dependence/call/ncs"
    },
    {
      "action": "refine",
      "old": "none|ast|ast/call/data flow",
      "new": "none|ast|ast/call/data flow or dependence"
    },
    {
      "action": "refine",
      "old": "cfg + ast subtree|statement/ast|control flow/data flow/ast",
      "new": "cfg + ast subtree|statement/ast|control flow/data flow or dependence/ast"
    },
    {
      "action": "refine",
      "old": "none|ast|ast/control flow/data dependence/dominator/post dominator",
      "new": "none|ast|ast/control flow/data flow or dependence/dominator/post dominator"
    },
    {
      "action": "refine",
      "old": "none|ast|ast/control dependence/data dependence/ncs",
      "new": "none|ast|ast/control dependence/data flow or dependence/ncs"
    },
    {
      "action": "refine",
      "old": "none|program elements at different levels[variables, statements, methods, classes, packages]|control dependence/program relationships (e.g inherit)/data dependence",
      "new": "none|program elements at different levels [variables, statements, methods, classes, packages]|control dependence/program relationships (e.g inherit)/data flow or dependence"
    },
    {
      "action": "refine",
      "old": "none|statement[from old and new  code]|control dependence/data dependence/old to new statement mapping",
      "new": "none|statement [from old and new  code]|control dependence/data flow or dependence/old to new statement mapping"
    },
    {
      "action": "refine",
      "old": "none|repository/token|source file in repo contains token",
      "new": "none|repository/token|<node> contains token"
    },
    {
      "action": "refine",
      "old": "none|user/repository/source code file|repository has file/comment/fork/star/contribution",
      "new": "none|user/repository/source code file|<node> contains <node>/comment/fork/star/contribution"
    },
    {
      "action": "refine",
      "old": "none|ast/markdown token/CLS|ast/ast-markdown edge/every node connected to CLS",
      "new": "none|ast/markdown token/CLS|ast/ast-markdown edge/connection to central node"
    },
    {
      "action": "refine",
      "old": "none|pull request/work item/author/reviewer/source code file/repository/token [PR]|creates/reviewed/repository contains PR/PR changes file/PR linked to work item/reviewer comments on PR/work item parent of work item/token in PR",
      "new": "none|pull request/work item/author/reviewer/source code file/repository/token [PR]|creates/reviewed/<node> contains <node>/PR changes file/PR linked to work item/reviewer comments on PR/work item parent of work item/<node> contains token"
    },
    {
      "action": "refine",
      "old": "none|statement|control dependence/data flow or dependence/control flow/root statement edge",
      "new": "none|statement|control dependence/data flow or dependence/control flow/connection to central node"
    },
    {
      "action": "refine",
      "old": "none|statement/token[unique]|statement contains token",
      "new": "none|statement/token [unique]|<node> contains token"
    },
    {
      "action": "refine",
      "old": "node|ast[merged]|ast/ncs/leaf to root",
      "new": "node|ast [merged]|ast/ncs/connection to central node"
    },
    {
      "action": "refine",
      "old": "none|node representing cfg/nodes representing control flow paths/statement/token|graph to path/path to statement/changed node (old vs new)/data flow or dependence/control dependence/statement to node",
      "new": "none|node representing cfg/nodes representing control flow paths/statement/token|graph to path/<node> contains <node>/changed node (old vs new)/data flow or dependence/control dependence/<node> contains <node>"
    },
    {
      "action": "refine",
      "old": "none|statement/token [unique]|<node> contains token",
      "new": "none|statement/token [unique]|<node> contains <node>"
    },
    {
      "action": "refine",
      "old": "none|repository/token|<node> contains token",
      "new": "none|repository/token|<node> contains <node>"
    },
    {
      "action": "refine",
      "old": "none|pull request/work item/author/reviewer/source code file/repository/token [PR]|creates/reviewed/<node> contains <node>/PR changes file/PR linked to work item/reviewer comments on PR/work item parent of work item/<node> contains token",
      "new": "none|pull request/work item/author/reviewer/source code file/repository/token [PR]|creates/reviewed/<node> contains <node>/PR changes file/PR linked to work item/reviewer comments on PR/work item parent of work item/<node> contains <node>"
    }
  ],
  "locked": {
    "none|ast[trimmed]|ast/control flow/data flow": true,
    "none|ast|ast/control dependence/control flow/data dependence": true,
    "none|token[in statement]|control flow[between statements]/ncs[in statement]": true,
    "none|ast|ast/ncs/data dependence/control flow/control dependence": true,
    "cpg|ast|ast/control dependence/control flow/data dependence": true,
    "none|ast|ast/data flow/sibling": true,
    "none|types|hyperedges encoding relations between types (e.g. function signature, property access, has name, is boolean)": true,
    "none|ast|ast/def-use relations": true,
    "none|statement|control flow/data flow": true,
    "node|ast[merged]|ast/ncs/leaf to root": true,
    "parse tree|token/constituency symbol (e.g. verb)|constituency edge/word ordering": true,
    "pdg[more specific edge types]|statement|control dependence/data dependence": true,
    "none|statement|data dependence": true,
    "none|repository/user|contributes": true,
    "none|data item (e.g shared variable, function)|call|return|data flow": true,
    "none|ir instructions + types|control flow/data flow": true,
    "none|ast [trimmed]|ast": true,
    "none|ast/markdown token/CLS|ast/ast-markdown edge/every node connected to CLS": true,
    "none|ast|ast/control flow/data flow": true,
    "none|ast|ast/control flow": true,
    "none|token|sliding window co-occurrence": true,
    "none|developer/project/question/ability|follows/answered/asked/committed/labelled (project - ability or question - ability)": true,
    "dependency graph|class/interface|class & interface relationships": true,
    "none|ast leaf|edge annotated with path between two nodes in full ast": true,
    "none|ast|control {flow,dependence}/data dependence": true,
    "none|ast|call/control flow/data flow/ncs": true,
    "none|operands/opcode/labels in ir|control {dependence,flow}/data dependence": true,
    "none|line|control flow/data flow/re-entrancy (call.value)/first to last line": true,
    "none|ast|ast/control flow/data dependence/dominator/post dominator": true,
    "none|developer|worked on same file in same release": true,
    "none|api usages|control flow/data flow": true,
    "none|instruction|control dependence/control flow/data dependence/data flow": true,
    "ast|ast|ast": true,
    "none|node representing cfg/nodes representing control flow paths/statement/tokens|graph to path/path to statement/changed node (old vs new)/data dependence/control dependence/statement to node": true,
    "none|ast/sub-token|ast/data dependence/ncs/sub-token": true,
    "none|ast/sub-tokens|ast/sub-tokens": true,
    "none|statement|data dependence[inter and intra method]": true,
    "none|module|dependency": true,
    "cfg + ast subtree|basic block/ast|control flow/data flow/ast": true,
    "none + ast subtrees|statement/ast|ast/control flow/control dependence/data dependence": true,
    "none|statement|data flow": true,
    "ast[partial, generated]|ast|ast/sibling": true,
    "none|ast/sub-token|ast/ncs/sibling/sub token": true,
    "none|ast|ast/calls/control flow/data flow": true,
    "none|statement[from old and new  code]|control dependence/data dependence/old to new statement mapping": true,
    "none|variable [every occurrene]/control statement|data flow/control flow": true,
    "none|methods/fields/constructors/relation nodes[calls, reads, writes, sync, modified]|nodes connected with relation node in between": true,
    "none|ast|ast/control dependence/control flow/data dependence/function call/ncs": true,
    "none|statement|control dependence": true,
    "none|class/property/method/parameter/variable|inheritance/has/instance of/return type/call": true,
    "none|basic block|call/control flow": true,
    "none|pull request/work item/author/reviewer/source code file/repository/tokens in PR|creates/reviews/repository contains PR/PR changes file/PR linked to work item/reviewer comments on PR/work item parent of work item/token in PR": true,
    "none|component|co-evolution/dependency": true,
    "none|ast|ast/ncs/hub[connect node types which commonly have many children]": true,
    "none|operations/operands|data dependence/data flow": true,
    "none|ast|control flow": true,
    "none|instructions|call/control flow/data dependence/data flow": true,
    "none|ast/sub-tokens|ast/control flow/ncs/sibling/data flow/sub token": true,
    "none|expressions/constants|relationships (e.g. L += R)": true,
    "none|constants/properties/methods/globals|relations (e.g. L += R)": true,
    "none|ast/sub-tokens|ast/data dependence/ncs/sub-token": true,
    "none|ast|ast/data flow/ncs": true,
    "none|ast|ast/ncs": true,
    "none|ast|data flow": true,
    "ast|ast[both old and new code, annotated {old,unchanged,new}]|ast": true,
    "none|ast|ast/control dependence": true,
    "none|file|association/dependency": true,
    "none|ast|control flow/data dependence": true,
    "ncs|token|ncs": true,
    "none|ast|ast/control flow/data dependence/ncs": true,
    "none|api invocation nodes/ast/sub-token|ast/data flow/ncs/sub token": true,
    "ast[inter method]|ast|ast": true,
    "none|ast/unique variable node|all occurrences of a variable connected to the unique variable node/ast/data dependence/ordering of nodes accessing the same variable/sibling": true,
    "none|ast|ast/control flow/data flow/sibling": true,
    "none|ast[old + new]|ast/new/old/unchanged": true,
    "none|pdg|call edges": true,
    "cfg[inter method] + ast subtrees|basic block/ast|control flow/ast": true,
    "none|user/repository/file|repository has file/comment/fork/star/contribute": true,
    "code change genealogy|code change|change dependency": true,
    "design pattern specification - source code|types/members of types (fields or methods)|structural relationships in and between types": true,
    "none|user/repository|introduction of vulnerability in repo by user at specific time": true,
    "none|ast|ast/control dependence/control flow/data dependence/data flow/ncs": true,
    "none|sat|ast/control dependence/data dependence/ncs": true,
    "ast[split up]|ast|ast": true,
    "none|developers/issues/files/tags|labelled/reviewed/committed/issue similar to file": true,
    "none|ast|ncs": true,
    "pdg|statement|control dependence/data dependence": true,
    "none|function/class/class field/module/method|call/define/type use/import/inherit": true,
    "none|operands|call/data flow": true,
    "none|ast|ast/control dependence/data dependence": true,
    "none|ast/sub-token|ast/control dependence/function call/import/inheritance/linear control/sub-token": true,
    "none|statement[old + new merged on unchanged nodes]|control dependence/data dependence/name flow": true,
    "dependency parse graph|token/sub-token|ncs/dependency/sub-token": true,
    "class dependency graph|class/interface|class & interface relationships": true,
    "none|file/directory/repository|file system structure edges": true,
    "none|ast node type node (node per ast node type)|edge iff edge between nodes of those types in ast": true,
    "none|program elements (modules, classes, functions etc)/ast type/ast|dependencies/ast type/ast": true,
    "none|objects/values/method invocations/constructor calls/field access/conditional checks/inheritance|call/control flow/sequential execution/synchronization/throw/handle/param": true,
    "none|statement[marked core or normal]/fallback (fallback function)|control flow/data flow/fallback": true,
    "none|unique code tokens|co-occurrence sliding window": true,
    "none|methods/api/structural (e.g. class or package)|method uses api/project structure": true,
    "none|user/repository|contribution": true,
    "none|ast|ast/data flow": true,
    "none|file/user|contribution": true,
    "cfg[inter method]|statement|control flow": true,
    "none|repository/token|source file in repo contains token": true,
    "ast[binarised]|ast|ast": true,
    "none|ast/node type per api call|ast": true,
    "ast[partial, generated]|ast|ast": true,
    "none|identifiers in instructions|control/data flow/dependence": true,
    "none|control flow statements|control flow": true,
    "labelled pushdown system|state|transitions between states": true,
    "none|ast|ast/data dependence/ncs": true,
    "design pattern specification - patterns|types/members of types/behaviours|type has <property>": true,
    "none|variables/labels in IR|data flow/data dependence/control flow": true,
    "none|api invocation/control statement|usage order/data dependency": true,
    "none|ast|ast/call/data flow": true,
    "api dependency graph|api (e.g. method)|dependency": true,
    "none|ast|ast[some edges reversed to point to statements]": true,
    "ast[partial; generated by model]|ast|ast": true,
    "dependency parse graph|token|ncs/dependencies": true,
    "none|ast|ast/sibling": true,
    "none|repository/user/topic|belongs to/contains topic/forked by/starred by": true,
    "none|ast|ast/control flow/data flow/ncs": true,
    "none|developer/module|constribution/co-evolution/dependency (eg call)/collaboration": true,
    "none|variable|data {flow,dependence}": true,
    "none|operations/operands|call/control flow/data dependence": true,
    "none|ast|ast/ast hyper-edge [for aggregation]": true,
    "none|ast/sub-tokens|ast/control flow/data dependence/ncs/sub token": true,
    "none|token|edges between identical tokens": true,
    "none|ast/sub-token/edit operation|ast/edit/sub-token": true,
    "none|statement/token[unique]|statement contains token": true,
    "none|statement|call/control dependence/data dependence/data flow": true,
    "none|program elements at different levels[variables, statements, methods, classes, packages]|control dependence/program relationships (e.g inherit)/data dependence": true,
    "none|ast|ast/block/control flow/ncs": true,
    "cfg|statement|control flow": true,
    "cfg + ast subtree|statement/ast|control flow/ast": true,
    "none|ast|ast/control flow/data flow/ncs/sibling": true,
    "none|ast|ast/data dependence": true,
    "any graph": true,
    "none|ast|ast/data flow/ncs/sibling": true,
    "none|operands/opcodes/labels in ir|control dependence/data dependence/oop related links (e.g. method to intance)": true,
    "fcg|function|call flow": true,
    "dependency graph|component|depedencies": true,
    "none|package|class/interface dependencies of classes/interfaces in packages": true,
    "none|statement[old + new merged on unchanged nodes]|control flow/data flow/name flow/sub-token co-occurrence": true,
    "none|ast|ast/control dependence/control flow/data dependence/ncs": true,
    "none|ast|ast/control flow/data flow/function call/ncs": true,
    "none|module|call dependency/data dependency": true,
    "none|statement|control dependence/data dependence/control flow/root statement edge": true,
    "none|developer/software component|contribution/dependency": true,
    "none|developer/component|contribution/dependencies": true,
    "none|ast|ast/control dependence/control flow/data dependence/dominator/post dominator": true,
    "none|ast|ast/data flow/control flow/next subtree (connect nodes on same level)": true,
    "none|ast|ast/control dependence/control flow/data dependence/joint edge type for control and data dependence between the same two nodes": true,
    "cfg + ast subtree|statement/ast|control flow/data flow/ast": true,
    "none|ast [internal]|ast": true,
    "none[inter method]|statement|control dependence/data dependence/call": true,
    "none|ast|ast/control flow/data dependence/data flow/ncs": true
  }
}