paper-id: sb-115
pdf-id: sb-161
graphs:
  graph:
    name: AST Graph
    description: generated from the code to be repaired, with a faulty statement located through e.g. a fault localisation model
    artefacts:
      - name: source code
        details: method
    vertex-type: ast
    edge-type: ast/direct left sibling
    vertex-features: n/a
    edge-features: n/a
    connectivity-features: adjacency matrix
    graph-features: n/a
    other-features: |-
      The AST (sub-)structure is traversed (pre-order),
      and two sequences are created:
        1) word2vec encoded sequence of nodes 
        2) the corresponding tagging sequence, where each tag denotes whether the current statement
            belongs to the fault statement, the statement before the faulty statement,
            the statement after the faulty statement, or another statement.
  partial-ast:
    name: AST (partial)
    description: n/a
    artefacts:
      - name: n/a
        details: generated by model
    vertex-type: ast
    edge-type: ast
    vertex-features:
    edge-features:
    connectivity-features: adjacency matrix
    graph-features: n/a
    other-features: |-
      Sequence of rules used to generate the AST, encoded as real vectors.
models:
  model:
    name: n/a
    architecture-attributes:
      - AST node sequence, enriched with positional encoding, is encoded using multi-head self attention
      - Gating mechanism (TreeGen) is applied to attention output, based on tagging sequence
      - GCN based on ast graph is applied to output of gated mechanism
      - rule sequence into multi-head self-attention
      - AST Reader with blocks with the following structure; (input is rule sequence) |-
          1) Self-attention
          2) gating mechanism
          3) Attention w/ NL query
          4)  GCN based on ast graph is applied to output of gated mechanism
      - Tree path reader with following structure' |-
          1) Attention w/ AST 
          2) Attention with code 
          3) FNN
      - Decoder which computed three different actions based on tree path encoder output; |-
          1) Generate next expansion (softmax)
          2) Propose tree to be copied (pointer network)
          3) Propose modification to existing node (pointer)
      
          A decider component (which also takes tree path reader as input) decides which computed action to use
tasks:
  automated-code-repair:
    training-objective: Given a snippet with a faulty statement, generate an AST with the correct code
    training-granularity: n/a
    working-objective: Given a snippet with a faulty statement, generate an AST with the correct code
    working-granularity: n/a
    application: automated code repair
    supervision: supervised
combinations:
  - graph: graph + partial-ast
    model: model
    task: automated-code-repair
    comments:
comments: # list