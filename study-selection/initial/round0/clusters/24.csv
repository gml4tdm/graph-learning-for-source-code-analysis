Title,Abstract
Graph Neural Networks for Mapping Variables Between Programs,"Automated program analysis is a pivotal research domain in many areas of Computer Science - Formal Methods and Artificial Intelligence, in particular. Due to the undecidability of the problem of program equivalence, comparing two programs is highly challenging. Typically, in order to compare two programs, a relation between both programs' sets of variables is required. Thus, mapping variables between two programs is useful for a panoply of tasks such as program equivalence, program analysis, program repair, and clone detection. In this work, we propose using graph neural networks (GNNs) to map the set of variables between two programs based on both programs' abstract syntax trees (ASTs). To demonstrate the strength of variable mappings, we present three use-cases of these mappings on the task of program repair to fix well-studied and recurrent bugs among novice programmers in introductory programming assignments (IPAs). Experimental results on a dataset of 4166 pairs of incorrect/correct programs show that our approach correctly maps 83% of the evaluation dataset. Moreover, our experiments show that the current state-of-the-art on program repair, greatly dependent on the programs' structure, can only repair about 72% of the incorrect programs. In contrast, our approach, which is solely based on variable mappings, can repair around 88.5%. © 2023 The Authors."
Assessing the Importance of Global Relationships for Source Code Analysis Using Graph Neural Networks,"Representing the source code as a sequence of tokens does not capture long-distance dependencies and inter-project dependencies. In this study, we analyze to which extent inter-project (global) relationships can be used in machine learning tasks related to source code analysis. Our findings show that information implicitly stored in inter-project relationships can be used to select the next called function among candidates with an accuracy of 92%. We demonstrate that source code embeddings achieve the best performance on transfer learning tasks when they are computed with graph neural networks in a multitask mode. © 2023, The Author(s), under exclusive license to Springer Nature Switzerland AG."
Is JavaScript Call Graph Extraction Solved Yet? A Comparative Study of Static and Dynamic Tools,"Code analysis is more important than ever because JavaScript is increasingly popular and actively used, both on the client and server sides. Most algorithms for analyzing vulnerabilities, finding coding issues, or inferring type depend on the call graph representation of the underlying program. Luckily, there are quite a few tools to get this job done already. However, their performance in vitro and especially in vivo has not yet been extensively compared and evaluated. In this paper, we compare several approaches for building JavaScript call graphs, namely five static and two dynamic approaches on 26 WebKit SunSpider programs, and two static and two dynamic approaches on 12 real-world Node.js programs. The tools under examination using static techniques were npm call graph, IBM WALA, Google Closure Compiler, Approximate Call Graph, and Type Analyzer for JavaScript. We performed dynamic analyzes relying on the nodejs-cg tool (a customized Node.js runtime) and the NodeProf instrumentation and profiling framework. We provide a quantitative evaluation of the results, and a result quality analysis based on 941 manually validated call edges. On the SunSpider programs, which do not take any inputs, so dynamic extraction could be complete, all the static tools also performed well. For example, TAJS found 93% of all edges while having a 97% precision compared to the precise dynamic call graph. When it comes to real-world Node.js modules, our evaluation shows that static tools struggle with parsing the code and fail to detect a significant amount of call edges that dynamic approaches can capture. Nonetheless, a significant number of edges not detected by dynamic approaches are also reported. Among these, however, there are also edges that are real, but for some reason the unit tests did not execute the branches in which these calls were included. © 2013 IEEE."
Synthesizing code quality rules from examples,"Static Analysis tools have rules for several code quality issues and these rules are created by experts manually. In this paper, we address the problem of automatic synthesis of code quality rules from examples. We formulate the rule synthesis problem as synthesizing first order logic formulas over graph representations of code. We present a new synthesis algorithm RhoSynth that is based on Integer Linear Programming-based graph alignment for identifying code elements of interest to the rule. We bootstrap RhoSynth by leveraging code changes made by developers as the source of positive and negative examples. We also address rule refinement in which the rules are incrementally improved with additional user-provided examples. We validate RhoSynth by synthesizing more than 30 Java code quality rules. These rules have been deployed as part of Amazon CodeGuru Reviewer and their precision exceeds 75% based on developer feedback collected during live code-reviews within Amazon. Through comparisons with recent baselines, we show that current state-of-the-art program synthesis approaches are unable to synthesize most of these rules.  © 2022 Owner/Author."
Leveraging structural properties of source code graphs for just-in-time bug prediction,"The most common use of data visualization is to minimize the complexity for proper understanding. A graph is one of the most commonly used representations for understanding relational data. It produces a simplified representation of data that is challenging to comprehend if kept in a textual format. In this study, we propose a methodology to utilize the relational properties of source code in the form of a graph to identify Just-in-Time (JIT) bug prediction in software systems during different revisions of software evolution and maintenance. We presented a method to convert the source codes of commit patches to equivalent graph representations and named it Source Code Graph (SCG). To understand and compare multiple source code graphs, we extracted several structural properties of these.graphs, such as the density, number of cycles, nodes, edges, etc. We then utilized the attribute values of those SCGs to visualize and detect buggy software commits. We process more than 246 K software commits from 12 subject systems in this investigation. Our investigation on these 12 open-source software projects written in C++ and Java programming languages shows that if we combine the features from SCG with conventional features used in similar studies, we will get the increased performance of Machine Learning (ML) based buggy commit detection models. We also find the increase of F1 Scores in predicting buggy and non-buggy commits statistically significant using the Wilcoxon Signed Rank Test. Since SCG-based feature values represent the style or structural properties of source code updates or changes in the software system, it suggests the importance of careful maintenance of source code style or structure for keeping a software system bug-free. © 2022, The Author(s), under exclusive licence to Springer Science+Business Media, LLC, part of Springer Nature."
Graph Expression for Various Software Documents As Unified Format,"We are developing an educational environment system named VRale-SCM to foster IT engineers necessary for the recent information society. VRale-SCM allows students to deepen their understanding by viewing source code and class diagrams in a virtual space. In this paper, we examined the possibility of using graphs to represent not only source code and class diagrams but also various software documents generated during the software development lifecycle as a framework for viewing them in a virtual space. While there have been attempts to represent individual software documents using a graph, there have been no attempts to represent relationships among these software documents. It will become possible to trace their relationships by interconnecting them, which is expected to facilitate the understanding of the students. In this paper, we shall examine the composition of some of the software documents in each process and attempt to represent the source code and design patterns in the graphs. We shall also check them with visualization tools. Using the graph representation is expected to contribute to understanding by presenting various metrics by applying the analysis in existing studies. © 2022 IEEE."
Graph representations in genetic programming,"Graph representations promise several desirable properties for genetic programming (GP); multiple-output programs, natural representations of code reuse and, in many cases, an innate mechanism for neutral drift. Each graph GP technique provides a program representation, genetic operators and overarching evolutionary algorithm. This makes it difficult to identify the individual causes of empirical differences, both between these methods and in comparison to traditional GP. In this work, we empirically study the behaviour of Cartesian genetic programming (CGP), linear genetic programming (LGP), evolving graphs by graph programming and traditional GP. By fixing some aspects of the configurations, we study the performance of each graph GP method and GP in combination with three different EAs: generational, steady-state and (1 + λ). In general, we find that the best choice of representation, genetic operator and evolutionary algorithm depends on the problem domain. Further, we find that graph GP methods can increase search performance on complex real-world regression problems and, particularly in combination with the (1 + λ) EA, are significantly better on digital circuit synthesis tasks. We further show that the reuse of intermediate results by tuning LGP’s number of registers and CGP’s levels back parameter is of utmost importance and contributes significantly to better convergence of an optimization algorithm when solving complex problems that benefit from code reuse. © 2021, The Author(s)."
Graph based answer set programming solver systems,"Answer set programming (ASP) is a popular nonmonotonic-logic based paradigm for knowledge representation and solving combinatorial problems. Computing the answer set of an ASP program is NP-hard in general, and researchers have been investing significant effort to speed it up. The majority of current ASP solvers employ SAT solver-like technology to find these answer sets. As a result, justification for why a literal is in the answer set is hard to produce. There are dependency graph based approaches to find answer sets, but due to the representational limitations of dependency graphs, such approaches are limited. This paper proposes a novel dependency graph-based approach for finding answer sets in which conjunction of goals is explicitly represented as a node which allows arbitrary answer set programs to be uniformly represented. Our representation preserves causal relationships allowing for justification for each literal in the answer set to be elegantly found. In this paper, we explore two different approaches based on the graph representation: bottom-up and top-down. The bottom-up approach finds models by assigning truth values along with the topological order, while the top-down approach generates models starting from the constraints. © F. Li This work is licensed under the Creative Commons Attribution License."
Graphs based on IR as Representation of Code: Types and Insights,"Mainstream compilers infer code properties from data structures, such as trees and graphs. The latter is useful to represent the control flow and the data dependencies in a code. In addition, graphs can also be used in learning tasks, such as classifying applications given their raw code, predicting the best-performing compute device (e.g., CPU, GPU) or predicting the optimal thread coarsening factor. This paper investigates the performance of graph neural networks on classifying applications given their raw code, for different type of graphs extracted from LLVM's intermediate representation. The results indicate that adding new (different) edges and/or nodes is not a fact of performance improvement. This paper shows a compact representation tends to achieve the best performance. As a result of such investigation, this paper has three main contributions: (1) an infrastructure to explore such graphs on different tasks, (2) compact graphs from LLVM's intermediate representation, (3) and a detailed evaluation of different types of graphs on a learning task.  © 2021 ACM."
EAGO.jl: easy advanced global optimization in Julia,"An extensible open-source deterministic global optimizer (EAGO) programmed entirely in the Julia language is presented. EAGO was developed to serve the need for supporting higher-complexity user-defined functions (e.g. functions defined implicitly via algorithms) within optimization models. EAGO embeds a first-of-its-kind implementation of McCormick arithmetic in an Evaluator structure allowing for the construction of convex/concave relaxations using a combination of source code transformation, multiple dispatch, and context-specific approaches. Utilities are included to parse user-defined functions into a directed acyclic graph representation and perform symbolic transformations enabling dramatically improved solution speed. EAGO is compatible with a wide variety of local optimizers, the most exhaustive library of transcendental functions, and allows for easy accessibility through the JuMP modelling language. Together with Julia's minimalist syntax and competitive speed, these powerful features make EAGO a versatile research platform enabling easy construction of novel meta-solvers, incorporation and utilization of new relaxations, and extension to advanced problem formulations encountered in engineering and operations research (e.g. multilevel problems, user-defined functions). The applicability and flexibility of this novel software is demonstrated on a diverse set of examples. Lastly, EAGO is demonstrated to perform comparably to state-of-the-art commercial optimizers on a benchmarking test set. © 2020 Informa UK Limited, trading as Taylor & Francis Group."
Towards Version Controlling in RefactorErl,"Static source code analyser tools are operating on an intermediate representation of the source code that is usually a tree or a graph. Those representations need to be updated according to the different versions of the source code. However, the developers might be interested in the changes or might need information about previous versions, therefore, keeping different versions of the source code analysed by the tools are required. RefactorErl is an open-source static analysis and transformation tool for Erlang that uses a graph representation to store and manipulate the source code. The aim of our research was to create an extension of the Semantic Program Graph of RefactorErl that is able to store different versions of the source code in a single graph. The new method resulted in 30% memory footprint decrease compared to the available workaround solutions. © 2021 University of Szeged, Institute of Informatics. All rights reserved."
Learning Code Representations Using Multifractal-based Graph Networks,"Learning representations of software codes is a critical problem for a wide range of system applications, e.g., compiler optimization, software classification, malicious software detection, and performance optimization. Recently, learning graph-based representations of software programs has been used to model the inherent structural dependencies in programming languages (e.g., C++, Python). In this paper, we propose a novel graph neural network framework that utilizes multifractal analysis for LLVM intermediate representations (IR). We then show empirically that the proposed framework is capable of capturing long-range structural dependencies that appear in software codes. We conduct experiments and comparisons on two downstream system applications: (1) predicting heterogeneous compute device mappings (graph classification), and (2) compiler reachability analysis (node classification). We observe that introducing a structural inductive bias through multifractal topological features enables GNNs to capture long-range dependencies among nodes, thus, it improves the accuracy of GNN models for applications that require learning code representations. © 2021 IEEE."
Generation of call graph for Java higher order functions,"The Lambda expression introduced in Java 8 gives a functional style to the object-oriented program. The major highlights of lambda expression include lazy evaluation, code readability, avoiding code duplication. A static call graph can be usedto visualize every possible run that the program might take. Due to the recent software development using Java, the new features aintroduced in Java 8 may be explored. Hence this demands the need for the call graphs generated for such software. This paper suggests an algorithm for the construction of a call graph for the lambda constructs. A static call graph will be generated by preserving the signature of the methods. The model suggested here uses an intermediate Abstract syntax tree (AST) like representation which is further transformed and optimized into a call graph representation. © 2020 IEEE."
A study on graph representations for genetic programming,"Graph representations promise several desirable properties for Genetic Programming (GP); multiple-output programs, natural representations of code reuse and, in many cases, an innate mechanism for neutral drift. Each graph GP technique provides a program representation, genetic operators and overarching evolutionary algorithm. This makes it difficult to identify the individual causes of empirical differences, both between these methods and in comparison to traditional GP. In this work, we empirically study the behavior of Cartesian Genetic Programming (CGP), Linear Genetic Programming (LGP), Evolving Graphs by Graph Programming (EGGP) and traditional GP. By fixing some aspects of the configurations, we study the performance of each graph GP method and GP in combination with three different EAs: generational, steady-state and (1 + λ). In general, we find that the best choice of representation, genetic operator and evolutionary algorithm depends on the problem domain. Further, we find that graph GP methods, particularly in combination with the (1 + λ) EA are significantly better on digital circuit synthesis tasks. © 2020 ACM."
An efficient and scalable platform for java source code analysis using overlaid graph representations,"Although source code programs are commonly written as textual information, they enclose syntactic and semantic information that is usually represented as graphs. This information is used for many different purposes, such as static program analysis, advanced code search, coding guideline checking, software metrics computation, and extraction of semantic and syntactic information to create predictive models. Most of the existing systems that provide these kinds of services are designed ad hoc for the particular purpose they are aimed at. For this reason, we created ProgQuery, a platform to allow users to write their own Java program analyses in a declarative fashion, using graph representations. We modify the Java compiler to compute seven syntactic and semantic representations, and store them in a Neo4j graph database. Such representations are overlaid, meaning that syntactic and semantic nodes of the different graphs are interconnected to allow combining different kinds of information in the queries/analyses. We evaluate ProgQuery and compare it to the related systems. Our platform outperforms the other systems in analysis time, and scales better to program sizes and analysis complexity. Moreover, the queries coded show that ProgQuery is more expressive than the other approaches. The additional information stored by ProgQuery increases the database size and associated insertion time, but these increases are significantly lower than the query/analysis performance gains obtained. © 2013 IEEE."
Unsupervised classifying of software source code using graph neural networks,Usually automated programming systems consist of two parts: Source code analysis and source code generation. This paper is focused on the first part. Automated source code analysis can be useful for errors and vulnerabilities searching and for representing source code snippets for further investigating. Also gotten representations can be used for synthesizing source code snippets of certain types. A machine learning approach is used in this work. The training set is formed by augmented abstract syntax trees of Java classes. A graph autoencoder is trained and a latent representation of Java classes graphs is inspected. Experiments showed that the proposed model can split Java classes graphs to common classes with some business logic implementation and interfaces and utility classes. The results are good enough be used for more accurate software source code generation. © 2019 FRUCT.
Loop-invariant Optimization in the Pifagor Language,"Abstract: The paper considers methods of program transformation equivalent to optimizing the cycle invariant, applied to the functional data-flow model implemented in the Pifagor programming language. Optimization of the cycle invariant in imperative programming languages is reduced to a displacement from the cycle of computations that do not depend on variables that are changes in the loop. A feature of the functional data flow parallel programming language Pifagor is the absence of explicitly specified cyclic computations (the loop operator). However, recurring calculations in this language can be specified recursively or by applying specific language constructs (parallel lists). Both mechanisms provide the possibility of parallel execution. In the case of optimizing a recursive function, repeated calculations are carried out into an auxiliary function, the main function performing only the calculation of the invariant. When optimizing the invariant in computations over parallel lists, the calculation of the invariant moves from the function that executes over the list items to the function containing the call. The paper provides a definition of “invariant” applied to the Pifagor language, algorithms for its optimization, and examples of program source codes, their graph representations (the program dependence graph) before and after optimization. The algorithm shown for computations over parallel lists is applicable only to the Pifagor language, because it rests upon specific data structures and the computational model of this language. However, the algorithm for transforming recursive functions may be applied to other programming languages. © 2018, Allerton Press, Inc."
Static javascript call graphs: A comparative study,"The popularity and wide adoption of JavaScript both at the client and server side makes its code analysis more important than ever before. Most of the algorithms for vulnerability analysis, coding issue detection, or type inference rely on the call graph representation of the underlying program. Despite some obvious advantages of dynamic analysis, static algorithms should also be considered for call graph construction as they do not require extensive test beds for programs and their costly execution and tracing. In this paper, we systematically compare five widely adopted static algorithms-implemented by the npm call graph, IBM WALA, Google Closure Compiler, Approximate Call Graph, and Type Analyzer for JavaScript tools-for building JavaScript call graphs on 26 WebKit SunSpider benchmark programs and 6 real-world Node.js modules. We provide a performance analysis as well as a quantitative and qualitative evaluation of the results. We found that there was a relatively large intersection of the found call edges among the algorithms, which proved to be 100% precise. However, most of the tools found edges that were missed by all others. ACG had the highest precision followed immediately by TAJS, but ACG found significantly more call edges. As for the combination of tools, ACG and TAJS together covered 99% of the found true edges by all algorithms, while maintaining a precision as high as 98%. Only two of the tools were able to analyze up-to-date multi-file Node.js modules due to incomplete language features support. They agreed on almost 60% of the call edges, but each of them found valid edges that the other missed. © 2018 IEEE."
Semantic consistency checking for model transformations,"Model transformation, as a key technique of MDA, is error-prone because of conceptual flaws in design and man-made errors in manual transformation rules. So the consistency checking of model transformations is of great importance for MDA. in this paper, a framework of semantic consistency checking for model transformation is proposed and discussed. In this framework, a graph representation is required to describe model languages, model transformation rules, and source code. Then several semantic properties are selected to be studied, and algorithms based on critical pairs are given to check whether these properties are preserved by model transformations. At last, a case study is performed to demonstrate the feasibility. © 2010 IEEE."
Impact analysis of UML design changes using model slicing,"We propose a technique for analysis of impact of design changes using dynamic slicing of UML models. For a software architecture specified using UML, we first transform a given model into a graph representation which we have named Model Dependency Graph (MDG). MDG combines information available in the interaction model along with the relevant information available in class model into an integrated model. For a given slicing criterion, our slicing algorithm traverses the constructed MDG to identify the relevant model elements forming the dynamic slice. We use these slices to identify the model changes, and their impact. Our impact analysis methodology is based on using the difference between the dynamic slices computed before and after changes are made to the model. Our methodology's novelty lies in performing impact analysis based on a graph metamodel as against independently processing separate UML models. © 2013 IEEE."
Incremental call graph reanalysis for AspectJ software,"Program call graph representation can be used to support many tasks in compiler optimization, program comprehension, and software maintenance. During software evolution, the call graph needs to remain fairly precise and be updated quickly in response to software changes. In this paper, we present an approach to incremental update, instead of exhaustive analysis of the initially constructed call graph in AspectJ software. Our approach first decomposes the source code edits between the updated and initial software versions into a set of atomic change representations, which capture the semantic differences. Then, we explore the relationship between atomic changes and call graph to incrementally update the initially constructed graph, instead of rebuilding it from the ground up. We implement the reanalysis approach on top of the ajc AspectJ compiler and perform an empirical study on 24 versions of eight AspectJ benchmarks. The experiment result shows that our approach can reduce a large portion of unnecessary reanalysis cost as program changes occur, and significant savings are observed for the incremental reconstruction of AspectJ call graph in comparison with an exhaustive analysis, with no loss in precision."
Towards a change propagation process in software architecture,"In the context of software architecture evolution, understanding the implications of change impact propagation is necessary for various activities including the change management. We propose in this paper a formal model and a platform based on eclipse plugins, for modeling and analysis of software architecture description. This will provide a graph representation of the architecture description, which is implemented in an eclipse platform. The model is based on graph rewriting and represents software architecture components and their corresponding various relationships that are extracted from the architecture description source code. The implementation uses parsers based on grammars specification files, which include features permitting to produce a graph representation of the software source codes. The Drools expert system is a knowledge based system, which performs rules on obtained graphs such as to deduce knowledge. This is used by a software change propagation engine to help identifying the change effects throughout different software architecture components."
MG++: Memory graphs for analyzing dynamic data structures,"Memory graphs are very useful in understanding the behavior of programs that use dynamically allocated data structures. We present a new memory graph representation, MG++, and a memory graph construction algorithm, that greatly enhance the utility of memory graphs. First, in addition to capturing the shapes of dynamically-constructed data structures, MG++ also captures how they evolve as the program executes and records the source code statements that play a role in their evolution to assist in debugging. Second, MG++ captures the history of actions performed by the memory allocator. This is useful in debugging programs that internally manage storage or in cases where understanding program behavior requires examining memory allocator actions. Our binary instrumentation-based algorithm for MG++ construction does not rely on the knowledge of memory allocator functions or on symbol table information. Our algorithm works for custom memory allocators as well as for in-program memory management. Experiments studying the time and space efficiency for real-world programs show that MG++ representation is space-efficient and the time overhead for MG++ construction algorithm is practical. We show that MG++ is effective for fault location and for analyzing binaries to detect heap buffer overflow attacks. © 2015 IEEE."
Learning to represent programs with graphs,"Learning tasks on source code (i.e., formal languages) have been considered recently, but most work has tried to transfer natural language methods and does not capitalize on the unique opportunities offered by code’s known sematics. For example, long-range dependencies induced by using the same variable or function in distant locations are often not considered. We propose to use graphs to represent both the syntactic and semantic structure of code and use graph-based deep learning methods to learn to reason over program structures. In this work, we present how to construct graphs from source code and how to scale Gated Graph Neural Networks training to such large graphs. We evaluate our method on two tasks: VARNAMING, in which a network attempts to predict the name of a variable given its usage, and VARMISUSE, in which the network learns to reason about selecting the correct variable that should be used at a given program location. Our comparison to methods that use less structured program representations shows the advantages of modeling known structure, and suggests that our models learn to infer meaningful names and to solve the VARMISUSE task in many cases. Additionally, our testing showed that VARMISUSE identifies a number of bugs in mature open-source projects. © Learning Representations, ICLR 2018 - Conference Track Proceedings.All right reserved."
Static analysis of complex software systems implemented in Erlang,"Static software analyser tools use different levels of intermediate source code representations that depend on the syntax and semantics of the language to be analysed. Most of the analyser tools use graph representation to efficiently retrieve information. Building such graphs for dynamically typed languages, such as Erlang, is not straightforward. In this paper we present static analysis methods to define the Dependency Graph representation of Erlang programs. The introduced methods cover the data-, control-, behaviour-flow and dependency analyses for sequential and parallel language constructs. © 2012 Springer-Verlag."
Program normalization for removing code variations,"Code variations are widely believed to impede program analysis. This paper introduces a program normalization approach to remove code variations. Semantic-preserving transformations are performed on the system dependence graphs of programs. As a result, various syntactically different but semantically equivalent constructs are transformed to the same system dependence graph representation, so that code variations are removed. This approach establishes a good framework for testing the semantic equivalence of source codes and it can facilitate program analysis. © 2008 IEEE."
An eclipse platform for analysis and manipulation of distributed multi-language software,"In this paper, we propose formal approach and a platform, based on eclipse plugins, for analysis of distributed multi-language software. These provide a graph representation of the distributed software software, integrated within formal models which are implemented in an eclipse platform. The models represent software components and their corresponding various relationships which are extracted from the source codes files of an eclipse project. The eclipse implementation uses javacc tool allowing to generate parsers based on grammars specifications files, which include features to produce a graph representation of the software components developed in various languages. We develop a distributed version of DROOLS expert system to perform rules on obtained graphs such as to deduce knowledge and to deal with change propagation process. The change propagation process is based on our expert system in order to evaluate the impact of a change performed on a local part of a software program to the distributed ones."
On the equivalence and range of applicability of graph-based representations of logic programs,"Logic programs under Answer Sets semantics can be studied, and actual computation can be carried out, by means of representing them by directed graphs. Several reductions of logic programs to directed graphs are now available. We compare our proposed representation, called Extended Dependency Graph, to the Block Graph representation recently defined by Linke [Proc. IJCAI-2001, 2001, pp. 641-648]. On the relevant fragment of well-founded irreducible programs, extended dependency and block graph turns out to be isomorphic. So, we argue that graph representation of general logic programs should be abandoned in favor of graph representation of well-founded irreducible programs, which are more concise, more uniform in structure while being equally expressive. © 2002 Elsevier Science B.V. All rights reserved."
Scripting refactorings with JunGL,"We describe JunGL, a language to script refactoring transformations. It manipulates a graph representation of the program, including extensible semantic information such as variable binding and dataflow. JunGL enables the full automation of complex refactorings: finding program elements of interest, checking preconditions and performing the transformation itself."
An eclipse platform extension for analysis and manipulation of multi-language software code,"In this paper, we propose formal model and a plat- form, based on eclipse plugins, for analysis of multi- language software. These provide a graph representa- Tion of the software source codes, database schemas, resource files, integrated within formal models which are implemented in an eclipse platform. The models are based on graphs rewriting, and represent software components and their corresponding various relation- ships which are extracted from the source codes files of an eclipse project. The implementation uses javacc tool allowing to generate parsers based on grammars specifications files, which include features permitting to produce a graph representation of the software compo- nents. The JBoss Rule expert system performs rules on obtained graphs such as to deduce knowledge which is not provided by the current eclipse platform. Ob- Tained knowledge concerns relationships between soft- ware components such as database tables and their use by Java Query Statements. Furthermore, this knowl- edge is used by a software change propagation plugins in order to evaluate the impact of changed database ta- bles."
A change propagation process for distributed software architecture,"In the context of software architecture evolution, understanding the impacts of a change to be applied on a distributed software architecture is necessary for various activities related to maintenance and change management. In this paper, we propose formal models and a platform based on eclipse plugins for modeling and analysis of the software architecture description and their related source codes. The proposed models aim at the construction of graph representation based on the architecture description and the software source codes. The graph implementation is mapped with facts of a distributed knowledge-based system, which performs change propagation rules to evaluate the impact of a change performed on distributed components."
Analysis and manipulation of distributed multi-language software code,"The authors propose a formal model and a platform to deal with distributed multi-language software analysis. These provide a graph representation of the software codes (source codes and byte-codes), a change propagation process based on graph rewriting, and an automatic profiling tool to measure the contribution of any component to the global performance of the software. The program codes are structured by a multi-graph in which the nodes represent the software components linked by edges representing the meaningful relationships. The software components and their relationships are extracted from the byte-code files, using the mocha decompiler tool, and from the source codes files, using the Javacc tool. Javacc allows one to generate parsers, based on grammar specification files, which include features to produce an XML (eXtensible Markup Language) representation of the software components. Furthermore, a graph of the software components is constructed on the top of the XML files, providing program analysis. This is implemented by an integrated platform including the mocha decompiler, a multi-language parsing tool, a software change management module, and a profiling tool. © 2001 IEEE."
genDMG: A generic graph representation layout to visualize existing software artifacts,"Examining software artifacts of an existing software system to understand their functionalities based on source codes can be a very daunting task. Many tools have emerged to assist software understanding or program comprehension, which normally consist of graph representations in a reverse engineering environment. These tools are known as reverse engineering or software visualization tools. This paper describes a document-like and modularized software visualization method called generic DocLike Modularized Graph (genDMG) that employs a graph drawing technique to represent software artifacts written either in structured or object-oriented. An example illustrates how the graph representations could assist software maintainers' program comprehension. A comparative study shows genDMG can improve what other methods could support in software visualization. © 2009 Springer-Verlag."
Sampling code clones from program dependence graphs with GRAPLE,"We present GRAPLE, a method to generate a representative sample of recurring (frequent) subgraphs of any directed labeled graph(s). GRAPLE is based on frequent subgraph mining, absorbing Markov chains, and Horvitz-Thompson estimation. It can be used to sample any kind of graph representation for programs. One of many software engineering applications for finding recurring subgraphs is detecting duplicated code (code clones) from representations such as program dependence graphs (PDGs) and abstract syntax trees. To assess the usefulness of clones detected from PDGs, we conducted a case study on a 73 KLOC commercial Android application developed over 5 years. Nine of the application's developers participated. To our knowledge, it is the first study to have professional developers examine code clones detected from PDGs. We describe a new PDG generation tool jpdg for JVM languages, which was used to generate the dependence graphs used in the study. © 2016 ACM."
Formalising behaviour preserving program transformations,"The notion of refactoring —transforming the source-code of an object-oriented program without changing its external behaviour— has increased the need for a precise definition of refactorings and their properties. This paper introduces a graph representation of those aspects of the source code that should be preserved by a refactoring, and graph rewriting rules as a formal specification for the refactoring transformations themselves. To this aim, we use type graphs, forbidden subgraphs, embedding mechansims, negative application conditions and controlled graph rewriting. We show that it is feasible to reason about the effect of refactorings on object-oriented programs independently of the programming language being used. This is crucial for the next generation of refactoring tools. © Springer-Verlag Berlin Heidelberg 2002."
Formalizing refactorings with graph transformations,"The widespread interest in refactoring - transforming the source-code of an object-oriented program without changing its external behaviour - has increased the need for a precise definition of refactoring transformations and their properties. In this paper we explore the use of graph rewriting for specifying refactorings and their effect on programs. We introduce a graph representation for programs and show how two representative refactorings can be expressed by graph productions. Then we demonstrate that it is possible to prove that refactorings preserve certain program properties, and that graph rewriting is a suitable formalism for such proofs. Copyright © 2005 John Wiley & Sons, Ltd."
Abstract Similarity Analysis,"Code similarity is an important component of program analysis that finds application in many fields of computer science. Graph based representations of programs, such as control flow graphs and dependency graphs, are often used as a basis for deciding code similarity. Indeed, many similarity algorithms observe particular properties of these graph-based representations of programs in order to decide whether two programs are similar or not. In this work we propose a general framework for similarity analysis where the similarity of programs is expressed in terms of abstractions of their control flow graphs representation. In particular, we consider abstractions of the basic blocks of a control flow graph. © 2017 The Author(s)"
Viewing software artifacts for different software maintenance categories using graph representations,"Information needed during an iterative process of a software maintenance process is much different from that of a software development process. Without up-dated documents, software maintainers need to gain information required to solve different maintenance categories through source codes hence consuming more time and effort. With the emergence of reverse engineering tools, the process of understanding source codes to solve maintenance tasks in different maintenance categories can be improved. Such tools employ diverse software visualisation methods that generate graph representations of parsed software artifacts. This paper discusses on how the graph representations provided by the proposed DocLike Modularised Graph (DMG) method employed in DocLike Viewer prototype tool can serve different levels of information needed by software maintainers in the case of corrective, adaptive and perfective maintenance category. It is observed that not only do software maintainers require diverse level of information; the necessity of the information is also not exactly of the same degree."
A program model based regression test selection technique for object-oriented programs,"We propose a regression test selection technique that is based on analysis of source code of an object-oriented program. First we construct a System dependency graph model of the original program from the source code. When some modification is executed in a program, the constructed model is updated to reflect the changes. Our approach in addition to capturing control and data dependencies represents the dependencies arising from object-relations. The test cases that exercise the affected model elements in the program model are selected for regression testing. In our approach System Design Graph representation will be used for regression test selection for analyzing and comparing the code changes of original and modified program. Empirical studies carried out by us show that our technique selects on an average of 26.36. % more fault-revealing test cases compared to a Control Dependence Graph based technique while incurring about 37.34% increase in regression test suite size. © 2015 IEEE."
JunGL: A scripting language for refactoring,"Refactorings are behaviour-preserving program transformations, typically for improving the structure of existing code. A few of these transformations have been mechanised in interactive development environments. Many more refactorings have been proposed, and it would be desirable for programmers to script their own refactorings. Implementing such source-to-source transformations, however, is quite complex: even the most sophisticated development environments contain significant bugs in their refactoring tools. We present a domain-specific language for refactoring, named JunGL. It manipulates a graph representation of the program: all information about the program, including ASTs for its compilation units, variable binding, control flow and so on is represented in a uniform graph format. The language is a hybrid of a functional language (in the style of ML) and a logic query language (akin to Datalog). JunGL furthermore has a notion of demand-driven evaluation for constructing computed information in the graph, such as control flow edges. Borrowing from earlier work on the specification of compiler optimisations, JunGL uses socalled 'path queries' to express dataflow properties. We motivate the design of JunGL via a number of nontrivial refactorings, and describe its implementation on the .NET platform. Copyright 2006 ACM."
Generating testing and analysis tools with Aria,"Many software testing and analysis tools manipulate graph representations of programs, such as abstract syntax trees or abstract semantics graphs. Handcrafting such tools in conventional programming languages can be difficult, error prone, and time consuming. Our approach is to use application generators targeted for the domain of graph-representation-based testing and analysis tools. Moreover, we generate the generators themselves, so that the development of tools based on different languages and/or representations can also be supported better. In this article we report on our experiences in developing and using a system called Aria that generates testing and analysis tools based on an abstract semantics graph representation for C and C++ called Reprise. Aria itself was generated by the Genoa system. We demonstrate the utility of Aria and, thereby, the power of our approach, by showing Aria's use in the development of a number of useful testing and analysis tools. © 1996 ACM."
Framework for selective recompilation in the presence of complex intermodule dependencies,"Compilers and other programming environment tools derive information from the source code of programs; derived information includes compiled code, interprocedural summary information, and call graph views. If the source program changes, the derived information needs to be updated. We present a simple framework for maintaining intermodule dependencies, embodying different tradeoffs in terms of space usage, speed of processing, and selectivity of invalidation, that eases the implementation of incremental update of derived information. Our framework augments a directed acyclic graph representation of dependencies with factoring nodes (to save space) and filtering nodes (to increase selectivity), and it includes an algorithm for efficient invalidation processing. We show how several schemes for selective recompilation, such as smart recompilation, filter sets for interprocedural summary information, and dependencies for whole-program optimization of object-oriented languages, map naturally onto our framework. For this latter application, by exploiting the facilities of our framework, we are able to reduce the number of lines of source code recompiled by a factor of seven over a header file-based scheme, and by a factor of two over the previous state-of-the-art selective dependency mechanism without consuming additional space."
Automated construction of testing and analysis tools,"Many software testing and analysis tool manipulate graph representations of programs, such as abstract syntax trees or abstract semantics graphs. Hand-crafting such tools in conventional programming languages can be difficult,error prone, and time consuming. Our approach is to use application generators targeted for the domain of graph-representation based testing and analysis tools. Moreover, we generate the generators themselves, so theat the development of tools based on different languages and or representations can also be supported better. In this paper we report on our experiences in developing a system called Aria that generates testing and analysis tools based on an abstract semantics graph representation for C and C++ called Reprise. Aria itself was generated by the Genoa system. We demonstrate the utility of Aria and, thereby, the power of our approach, by showing Aria's use in the development of a tool that derives control dependence graphs directly from Reprise abstract semantics graphs."
